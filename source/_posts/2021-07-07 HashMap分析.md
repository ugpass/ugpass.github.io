---
title:      "HashMap分析" 
date:       2021-07-07
tags:
    - iOS
categories:
    - iOS
---

#### 学习HashMap源码

##### Hash

1. Hash函数

   1. Hash函数是一种摘要算法，具有不可逆性
   2. 常见的Hash算法有MD5，SHA256，SHA512

2. Hash表

   1. 是一种根据key，快速访问内存上数据的数据结构

3. Hash冲突，如以下代码一样

   ``` 
   15 & (10 - 1) = 9
   13 & (10 - 1) = 9
   ```

##### Dictionary <key: value>

1. 实现方式：数组 + 链表
   1. 数组：查找O(1)，插入/删除O(n)
   2. 链表：查找O(n)，插入/删除O(1)

2. 伪代码

   1.  
```
      数据结构
      Class Node {	//链表结构
      	hash,			//key的hash值
      	key,
      	value,
      	Node *next
      };
      
      Class Table {	//数组结构
      	Nodes<Node>,		//存放Node的数组
      	Capacity,				//存放元素的个数
      	Length,					//数组的大小 default 1<<4 = 16
      	Factory,				//扩容因子 defalut 0.75
      }
      ```

   2. 数组的index计算方式

      1. Node.hash & (Table.Length - 1)

         > Table.Length 初始值为16，之后扩容方式为2的N次幂，这样(Table.Length - 1)为奇数，最后一位为1，和key的hash进行位运算之后，可能为奇数，可能为偶数，减少空间浪费。如果(Table.Length - 1)为偶数，则最后一位是0，与任何值进行hash与的运算均为偶数。

   3. 根据key 获取value

      1. ```
         Node getNode(key) {
         	int hash = hash(key);
         	int n; 
         	Node first;
         	if (table != null && (n = table.Nodes.Length) > 0 && (first = table.Nodes[hash & (n - 1)]) != null) {
         		if (first.hash == hash && first.key == key) {
         			return first;
         		}
         		while (first.next != null) {
         			Node tempNode = first.next;
         			if (tempNode.hash == hash && tempNode.key == key) {
         				return tempNode;
         			}
         			first = first.next;
         		}
         	}
         	return null;
         }
         ```

         首先判断数组不为空，数组长度大于0，根据hash算出第一个Node所在的index，取出对应的Node

         然后先判断第一个节点是否匹配，我理解的是因为hash冲突概率低，一般取出第一个即可命中，不需要进入循环

         之后如果不匹配，则遍历链表

   4.  存储key-value

      1. 在Android中，当冲突中的链表长度大于8时，则将链表转化为红黑树
      2. 使用红黑树的原因是查找效率更高
      3. 个数小于8时，不使用红黑树，是为了节省内存



















