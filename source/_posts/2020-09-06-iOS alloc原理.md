---
title:      "iOS alloc原理分析" 
date:       2020-09-06
tags:
    - iOS底层原理
categories:
    - iOS底层原理
---

首先自定义类`LSPerson`继承自`NSObject`

```
创建LSPerson对象
LSPerson *p1 = [LSPerson alloc];
```

断点在该行，`control` + `step into`进入断点即可看到调用`objc_alloc函数`，在[ojbc源码]([https://opensource.apple.com/tarballs/](https://opensource.apple.com/tarballs/)
)中源码如下

```
callAlloc源码
// Call [cls alloc] or [cls allocWithZone:nil], with appropriate 
// shortcutting optimizations.
static ALWAYS_INLINE id
callAlloc(Class cls, bool checkNil, bool allocWithZone=false)
{
#if __OBJC2__
    if (slowpath(checkNil && !cls)) return nil;
    if (fastpath(!cls->ISA()->hasCustomAWZ())) {
        return _objc_rootAllocWithZone(cls, nil);
    }
#endif

    // No shortcuts available.
    if (allocWithZone) {
        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);
    }
    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));
}
```

分析alloc流程如下：

![alloc流程](https://upload-images.jianshu.io/upload_images/1395687-66f1fbc4ee92add4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

其中`slowpath`和`fastpath`为宏定义，`__builtin_expect`用于编译器对代码优化，减少指令跳转。这个指令是gcc引入的，作用是"允许程序员将最有可能执行的分支告诉编译器"
```
#define fastpath(x) (__builtin_expect(bool(x), 1))
#define slowpath(x) (__builtin_expect(bool(x), 0))
```  

`!cls->ISA()->hasCustomAWZ()`判断该类是否有自定义的`allocWithZone`实现

1. instanceSize源码
```
size_t instanceSize(size_t extraBytes) const {
        if (fastpath(cache.hasFastInstanceSize(extraBytes))) {
            return cache.fastInstanceSize(extraBytes);
        }

        size_t size = alignedInstanceSize() + extraBytes;
        // CF requires all objects be at least 16 bytes.
        if (size < 16) size = 16;
        return size;
    }
```
根据调试信息从缓存中读取所需开辟空间大小`cache.fastInstanceSize`

fastInstanceSize源码
```
size_t fastInstanceSize(size_t extra) const
    {
        ASSERT(hasFastInstanceSize(extra));

        if (__builtin_constant_p(extra) && extra == 0) {
            return _flags & FAST_CACHE_ALLOC_MASK16;
        } else {
            size_t size = _flags & FAST_CACHE_ALLOC_MASK;
            // remove the FAST_CACHE_ALLOC_DELTA16 that was added
            // by setFastInstanceSize
            return align16(size + extra - FAST_CACHE_ALLOC_DELTA16);
        }
    }
```
`__builtin_constant_p(exp)`用于在编译器判断exp是否为常量，如果是则函数的值为1，否则为0。此处exp为非常量

align16源码
```
static inline size_t align16(size_t x) {
    return (x + size_t(15)) & ~size_t(15);
}
```
align16函数对变量x进行内存对齐，计算后为16的倍数，该算法是对x的二进制的后四位进行清零运算

![字节对齐算法示意图](https://upload-images.jianshu.io/upload_images/1395687-d42f8abca7382024.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

2. `calloc` 返回开辟内存的地址指针

3. `initInstanceIsa`源码  做了一件事即初始化isa `initIsa`
```
inline void 
objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)
{
    ASSERT(!cls->instancesRequireRawIsa());
    ASSERT(hasCxxDtor == cls->hasCxxDtor());

    initIsa(cls, true, hasCxxDtor);
}
```

`initIsa`源码
```
inline void 
objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) 
{ 
    ASSERT(!isTaggedPointer()); 
    
    if (!nonpointer) {
        isa = isa_t((uintptr_t)cls);
    } else {
        ASSERT(!DisableNonpointerIsa);
        ASSERT(!cls->instancesRequireRawIsa());

        isa_t newisa(0);

#if SUPPORT_INDEXED_ISA
        ASSERT(cls->classArrayIndex() > 0);
        newisa.bits = ISA_INDEX_MAGIC_VALUE;
        // isa.magic is part of ISA_MAGIC_VALUE
        // isa.nonpointer is part of ISA_MAGIC_VALUE
        newisa.has_cxx_dtor = hasCxxDtor;
        newisa.indexcls = (uintptr_t)cls->classArrayIndex();
#else
        newisa.bits = ISA_MAGIC_VALUE;
        // isa.magic is part of ISA_MAGIC_VALUE
        // isa.nonpointer is part of ISA_MAGIC_VALUE
        newisa.has_cxx_dtor = hasCxxDtor;
        newisa.shiftcls = (uintptr_t)cls >> 3;
#endif

        // This write must be performed in a single store in some cases
        // (for example when realizing a class because other threads
        // may simultaneously try to use the class).
        // fixme use atomics here to guarantee single-store and to
        // guarantee memory order w.r.t. the class index table
        // ...but not too atomic because we don't want to hurt instantiation
        isa = newisa;
    }
}
```
自定义类非taggedPointer，且nonpointer为true，走到else分支，初始化`isa_t newisa`结构体