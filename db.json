{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/avatar.jpg","path":"avatar.jpg","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/icons/icon-512x512.png","path":"icons/icon-512x512.png","modified":0,"renderable":0},{"_id":"themes/Chic/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/Chic/source/css/base.styl","path":"css/base.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/css/custom.styl","path":"css/custom.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/css/font.styl","path":"css/font.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/css/layout.styl","path":"css/layout.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/css/media.styl","path":"css/media.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/css/normalize.styl","path":"css/normalize.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/css/variable.styl","path":"css/variable.styl","modified":0,"renderable":1},{"_id":"themes/Chic/source/image/avatar.jpeg","path":"image/avatar.jpeg","modified":0,"renderable":1},{"_id":"themes/Chic/source/js/mathjax2.7.5.js","path":"js/mathjax2.7.5.js","modified":0,"renderable":1},{"_id":"themes/Chic/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/Chic/source/js/tocbot.min.js","path":"js/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/demo.css","path":"fonts/iconfont/demo.css","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/demo_index.html","path":"fonts/iconfont/demo_index.html","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.css","path":"fonts/iconfont/iconfont.css","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.eot","path":"fonts/iconfont/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.js","path":"fonts/iconfont/iconfont.js","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.json","path":"fonts/iconfont/iconfont.json","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.svg","path":"fonts/iconfont/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.ttf","path":"fonts/iconfont/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff","path":"fonts/iconfont/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff2","path":"fonts/iconfont/iconfont.woff2","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.TTF","path":"fonts/lanting/lanting.TTF","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.eot","path":"fonts/lanting/lanting.eot","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.otf","path":"fonts/lanting/lanting.otf","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff","path":"fonts/lanting/lanting.woff","modified":0,"renderable":1},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff2","path":"fonts/lanting/lanting.woff2","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/2019-08-16-hello-Leisure.md","hash":"6cdef18f19bdfa495a1abf27ea284b33f28a2c3a","modified":1624074384082},{"_id":"source/_posts/2019-08-30-react-native-WebView和H5交互.md","hash":"2a813429d6699776fb2d99300a5b505b6749d0d7","modified":1624074384082},{"_id":"source/avatar.jpg","hash":"e8e0dca78d92b9cd0681c1b7390980a8c89ea472","modified":1624074384088},{"_id":"source/favicon.ico","hash":"48678c6e2c4045a5945572d60bf53014a35c8aea","modified":1624074384088},{"_id":"source/_posts/2019-09-05-webrtc-视频采集.md","hash":"30f1ab83be31e9ecfd811672b5024519e6d5cc5d","modified":1624074384083},{"_id":"source/_posts/2020-07-02-OpenGL常见专业名词.markdown","hash":"630cbe5d99722e29cfd456731fa630b3c86390be","modified":1624074384083},{"_id":"source/_posts/2020-07-03-iOS图片解码.markdown","hash":"8507155199655e7081e120686e6cc86e51ee0b20","modified":1624074384083},{"_id":"source/_posts/2020-07-04-iOS保持界面流畅.markdown","hash":"1b3e10ba8ff0941ef76de8591932fea464f099f7","modified":1624074384084},{"_id":"source/_posts/2020-03-07-React Native是如何工作的.markdown","hash":"9571945c6828ad2dba3130e773f54142268feccd","modified":1624074384083},{"_id":"source/_posts/2020-07-07-OpenGL架构.markdown","hash":"d4cacde403ec7b6cc026d014cac1004062bc7d14","modified":1624074384084},{"_id":"source/_posts/2020-07-10-OpenGL正背面剔除和深度测试.markdown","hash":"703d1cd3b7983356ace6e0bcccef95659c89d02f","modified":1624074384084},{"_id":"source/_posts/2020-07-07-iOS离屏渲染解析.markdown","hash":"3dca27b6297dbbfdb6f43aebe477f1c8a812fa0f","modified":1624074384084},{"_id":"source/_posts/2020-07-17-OpenGL向量、矩阵相关.md","hash":"872ddb8b7d48b4bef65ba7ec86d3762a40a17722","modified":1624074384085},{"_id":"source/_posts/2020-07-21-Cocoapods安装与更新.md","hash":"a260d903913f6337ad417557453210a90e612600","modified":1624074384085},{"_id":"source/_posts/2020-07-13-OpenGL颜色混合.markdown","hash":"3764257ac856cd6adbb2e4b9fe498fffe8450057","modified":1624074384084},{"_id":"source/_posts/2020-07-28-OpenGL ES&GLKit加载纹理.md","hash":"a00fa6bdb18dd1952d72a7f70fb7d42061c993c6","modified":1624074384085},{"_id":"source/_posts/2020-07-22-OpenGL纹理加载与镜像.md","hash":"fc5cb985cc813e1124993f1ba261f6135dce572e","modified":1624074384085},{"_id":"source/_posts/2020-08-02-翻转纹理的5种方式.md","hash":"2232035cbb307afd6e0731cdaa8b0bcf58a7ae6d","modified":1624074384086},{"_id":"source/_posts/2020-08-02-OpenGL ES GLSL加载纹理.md","hash":"5e8866d0d4a9fbe8634e632606c2bc931c3f8be0","modified":1624074384086},{"_id":"source/_posts/2020-09-06-iOS alloc原理.md","hash":"62580c364efff7503ca80d321d765db0df70aea4","modified":1624074384086},{"_id":"source/_posts/2020-09-10-isa结构解析.md","hash":"ddaa7365572f98fdb89df560b2d4bad414e6b54e","modified":1624074384086},{"_id":"source/_posts/2020-09-13-iOS 类的结构分析.md","hash":"21eca6c22ab80efabd0043076ecd76593602cfb0","modified":1624074384086},{"_id":"source/_posts/2020-09-15-iOS 类的结构分析(二).md","hash":"a0c7feffa443ac05d775dbcb57df25e4a42c1435","modified":1624074384087},{"_id":"source/_posts/2020-09-18-iOS cache_t结构分析.md","hash":"a7de4188d2d0793b21e47edcfe18bea989cd3574","modified":1624074384087},{"_id":"source/_posts/2020-09-20-objc_msgSend源码解析(一).md","hash":"698db09af92f22a3bb6ac50e9bb5e33dcf54fcc3","modified":1624074384087},{"_id":"source/_posts/2020-09-23-objc_msgSend源码解析(二).md","hash":"80cb233412b0872a9f2b116646628bd0ab66198f","modified":1624074384087},{"_id":"source/_posts/2020-09-24-objc_msgSend源码解析(三).md","hash":"3a324b9f904d9fa863d9928f11fb73844c52c9eb","modified":1624074384087},{"_id":"source/_posts/2020-10-15-iOS APP启动流程.md","hash":"75dd13a394d37ee936c7f8d10ac0feb6a2409e41","modified":1624074384088},{"_id":"source/icons/icon-512x512.png","hash":"2d05e5b19ec60bde5e8474635a0424f1fa7f1bd9","modified":1624074384089},{"_id":"themes/Chic/README.md","hash":"e0bd27664e1d0b4ed1c8101d2bf69886c66c31d9","modified":1624084345721},{"_id":"themes/Chic/LICENSE.md","hash":"9911bdafa287bd65a822f84cc12012980bd10247","modified":1624084345720},{"_id":"themes/Chic/README-CN.md","hash":"af0765f26b72d49f1b29afe1a9d0c4a492912aaa","modified":1624084345720},{"_id":"themes/Chic/ChangeLogs.md","hash":"06653c18d7a861f784269c9fe9dd69aa72b0c242","modified":1624084345720},{"_id":"themes/Chic/package.json","hash":"8b4072879307eed0e74ae35390825c5e03b9229c","modified":1624084345726},{"_id":"themes/Chic/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1624084345721},{"_id":"themes/Chic/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1624084345721},{"_id":"themes/Chic/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1624084345721},{"_id":"themes/Chic/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1624084345721},{"_id":"themes/Chic/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1624084345722},{"_id":"themes/Chic/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1624084345722},{"_id":"themes/Chic/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1624084345722},{"_id":"themes/Chic/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1624084345722},{"_id":"themes/Chic/_config.yml","hash":"838cbaa6f927ed6b1f756254d7a0d46770398359","modified":1624585758380},{"_id":"themes/Chic/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1624084345722},{"_id":"themes/Chic/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1624084345722},{"_id":"themes/Chic/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1624084345722},{"_id":"themes/Chic/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1624084345722},{"_id":"themes/Chic/layout/category.ejs","hash":"cae7483c92ff639f74f8efe67959f37c97350800","modified":1624084345725},{"_id":"themes/Chic/layout/archive.ejs","hash":"48cdf67b628eb6a1c24d484ed252f5b0e3f06ddf","modified":1624084345725},{"_id":"themes/Chic/layout/layout.ejs","hash":"f874320edabdefc204f9e17d119a16d16f26c363","modified":1624084345725},{"_id":"themes/Chic/layout/index.ejs","hash":"b3344720176ad12dc88745cc5b31d497356ca4fa","modified":1624084345725},{"_id":"themes/Chic/layout/page.ejs","hash":"3179c527694a789760742e1923c7ac5f94b4997c","modified":1624084345725},{"_id":"themes/Chic/layout/post.ejs","hash":"a23f83d6c559ce88588472267468a54488d50e8e","modified":1624084345726},{"_id":"themes/Chic/scripts/imageTag.js","hash":"4b69804c1e4bf638eda7022499c440ce24e28587","modified":1624084345726},{"_id":"themes/Chic/layout/_page/archive.ejs","hash":"464549286c92ea0d6cb057c6936e0f1a5d1c1dd2","modified":1624084345723},{"_id":"themes/Chic/layout/tag.ejs","hash":"d85ca78392be138b1589499cba95186b20c3a902","modified":1624084345726},{"_id":"themes/Chic/layout/_page/category.ejs","hash":"e8464e11d08a711fe815ea1cd101aa41d7310ebf","modified":1624084345723},{"_id":"themes/Chic/layout/_page/page.ejs","hash":"1d875d59cf4d6b681cc8cf755f19b5355e5d1144","modified":1624084345723},{"_id":"themes/Chic/layout/_page/post.ejs","hash":"6eb9cd3ee904e99ff78509298ae31a29fdbf49cf","modified":1624084345723},{"_id":"themes/Chic/layout/_page/profile.ejs","hash":"c6d3cf2ef90e5d0fd580e7cff1db47c28fb36037","modified":1624084345723},{"_id":"themes/Chic/layout/_page/tag.ejs","hash":"0c20ff00532103f9a59639ca9956fc0bce4aabc2","modified":1624084345723},{"_id":"themes/Chic/source/favicon.ico","hash":"48678c6e2c4045a5945572d60bf53014a35c8aea","modified":1624090097453},{"_id":"themes/Chic/layout/_partial/footer.ejs","hash":"e1c332fab0d6cd713e36d46ccc14d0991067ba40","modified":1624084345724},{"_id":"themes/Chic/layout/_partial/head.ejs","hash":"8c8a2d95e0858cf0be9bf60d0ddf26876e1d9d35","modified":1624084345724},{"_id":"themes/Chic/layout/_partial/header.ejs","hash":"8f1e5272a4de96a3ed94de1db988b05b34515463","modified":1624084345724},{"_id":"themes/Chic/layout/_partial/paginator.ejs","hash":"ab59d5db77f2aa64dfe03656e72fd49702c62e23","modified":1624084345724},{"_id":"themes/Chic/layout/_partial/toc.ejs","hash":"10bb9c303c948f5615149981cd85cbbd3e7c781c","modified":1624084345724},{"_id":"themes/Chic/layout/_plugins/mathjax.ejs","hash":"53f088fe44d51c4d9fb61aeac4c23b3cfcc19762","modified":1624084345725},{"_id":"themes/Chic/source/css/base.styl","hash":"72aef06d738853f13f1697b091002d6d776bd56d","modified":1624084345746},{"_id":"themes/Chic/source/css/custom.styl","hash":"bf8dee1a094b104d87a53b43f6daa7ba43b67574","modified":1624084345747},{"_id":"themes/Chic/source/css/font.styl","hash":"8c1da30e223c0a3d7ef452abc9f0e4cc71dbc140","modified":1624084345747},{"_id":"themes/Chic/source/css/media.styl","hash":"f96c0dbb9653667906a6dc271f637543ac5c7212","modified":1624084345747},{"_id":"themes/Chic/source/css/layout.styl","hash":"9942d05bb2c55cf035d4bf9af325e1e81766a510","modified":1624084345747},{"_id":"themes/Chic/source/css/normalize.styl","hash":"b3337320133b7a336db7033aa6bbe94b054c0b21","modified":1624084345747},{"_id":"themes/Chic/source/css/style.styl","hash":"a13f2c38070a89b06a2ede599f5ce5fd160e11c9","modified":1624084345748},{"_id":"themes/Chic/source/css/variable.styl","hash":"906faa95457eba70118a0705e13b8f43409e502f","modified":1624084345748},{"_id":"themes/Chic/source/js/script.js","hash":"93694e4e16893f83611daa5ba3723b14ecc80abb","modified":1624084345843},{"_id":"themes/Chic/source/image/avatar.jpeg","hash":"e8e0dca78d92b9cd0681c1b7390980a8c89ea472","modified":1624090118118},{"_id":"themes/Chic/source/js/mathjax2.7.5.js","hash":"7ba18c783d543cfb4b45a0118ccb73d3f68cd46e","modified":1624084345843},{"_id":"themes/Chic/source/css/_highlight/agate.styl","hash":"53027913ed8d4f75ac3e49e76aad824f0df62da3","modified":1624084345726},{"_id":"themes/Chic/source/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1624084345844},{"_id":"themes/Chic/source/css/_highlight/androidstudio.styl","hash":"2af0861725f97f0ee2ded67c3d2d4548c62b2d16","modified":1624084345727},{"_id":"themes/Chic/source/css/_highlight/arduino-light.styl","hash":"15e8572585cd708221c513dea4bdd89d8fe56c10","modified":1624084345727},{"_id":"themes/Chic/source/css/_lib/looper.css","hash":"863144dc9af7c1e181670515bc85eaf768f4e287","modified":1624084345743},{"_id":"themes/Chic/source/css/_highlight/arta.styl","hash":"b3e81e3e694ceb8deed178adb8b91013c5120e30","modified":1624084345727},{"_id":"themes/Chic/source/css/_highlight/ascetic.styl","hash":"32cff3bef6fac3760fe78f203096477052a90552","modified":1624084345727},{"_id":"themes/Chic/source/css/_highlight/atelier-cave-dark.styl","hash":"ce63dd8548688d88254405eedfa75b1d7c82449e","modified":1624084345727},{"_id":"themes/Chic/source/css/_lib/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1624084345743},{"_id":"themes/Chic/source/css/_highlight/atelier-cave-light.styl","hash":"a5be0744a7ecf4a08f600ade4cfd555afc67bc15","modified":1624084345727},{"_id":"themes/Chic/source/css/_highlight/atelier-dune-light.styl","hash":"931435fbc6f974e8ce9e32722680035d248a9dc1","modified":1624084345728},{"_id":"themes/Chic/source/css/_highlight/atelier-dune-dark.styl","hash":"c196ff0ee064af0e507823694ae39020addfc280","modified":1624084345727},{"_id":"themes/Chic/source/css/_highlight/atelier-estuary-light.styl","hash":"344276ca9b27e51d4c907f76afe5d13cf8e60bdf","modified":1624084345728},{"_id":"themes/Chic/source/css/_highlight/atelier-estuary-dark.styl","hash":"0bb16a4eff93688f40787abc2f9e56e7d5cc93e7","modified":1624084345728},{"_id":"themes/Chic/source/css/_highlight/atelier-forest-dark.styl","hash":"effbc5d75fa87203c847039869c22031b40d5b7d","modified":1624084345728},{"_id":"themes/Chic/source/css/_highlight/atelier-heath-dark.styl","hash":"9a2e9a1d0a01bbdf158560c3ed1c134e098b2c68","modified":1624084345729},{"_id":"themes/Chic/source/css/_highlight/atelier-forest-light.styl","hash":"95228d9f2102fad425536aac44b80b2cba1f5950","modified":1624084345728},{"_id":"themes/Chic/source/css/_highlight/atelier-heath-light.styl","hash":"8c8c2e445abef85273be966d59770e9ced6aac21","modified":1624084345729},{"_id":"themes/Chic/source/css/_highlight/atelier-lakeside-dark.styl","hash":"10ee3882fca7b97a37bd309d2d35fce9868647bb","modified":1624084345729},{"_id":"themes/Chic/source/css/_highlight/atelier-lakeside-light.styl","hash":"2c54cb9bdb259ae3b5b29f63ac2469ed34b08578","modified":1624084345729},{"_id":"themes/Chic/source/css/_highlight/atelier-plateau-dark.styl","hash":"84c80e6f67f62fce958d25817c277d2360272617","modified":1624084345729},{"_id":"themes/Chic/source/css/_highlight/atelier-plateau-light.styl","hash":"d1a05fdd1ededc9063d181ab25bad55a164aeb4a","modified":1624084345730},{"_id":"themes/Chic/source/css/_highlight/atelier-savanna-dark.styl","hash":"e32c1c70def8060fce5e790979a126da650ac642","modified":1624084345730},{"_id":"themes/Chic/source/css/_highlight/atelier-savanna-light.styl","hash":"f8244c93711c7cb59dd79d2df966806b30d171ea","modified":1624084345730},{"_id":"themes/Chic/source/css/_highlight/atelier-seaside-dark.styl","hash":"2edf385215bbe1985b1a10106525d362667d28c2","modified":1624084345730},{"_id":"themes/Chic/source/css/_highlight/atelier-seaside-light.styl","hash":"0597342da6e2d0c5bdcc7d42dabb07322b1a4177","modified":1624084345730},{"_id":"themes/Chic/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"538a14321193cd8abf2ddc484306631e54149ffb","modified":1624084345731},{"_id":"themes/Chic/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"efa52713efc468abeeb2b9299704371583b857de","modified":1624084345731},{"_id":"themes/Chic/source/css/_highlight/brown-paper.styl","hash":"329b85ae9130a5587a6fb1c6f80396f9cca5ddc1","modified":1624084345731},{"_id":"themes/Chic/source/css/_highlight/codepen-embed.styl","hash":"8b7b34484f76a6c2c3b1a9e49abb9b382f439ae8","modified":1624084345731},{"_id":"themes/Chic/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1624084345731},{"_id":"themes/Chic/source/css/_highlight/color-brewer.styl","hash":"2a439d6214430e2f45dd4939b4dfe1fe1a20aa0f","modified":1624084345732},{"_id":"themes/Chic/source/css/_highlight/dark.styl","hash":"f5e6e75958de59e87fc6be3a1668e870e20bc836","modified":1624084345732},{"_id":"themes/Chic/source/css/_highlight/darkula.styl","hash":"9717efa9194837ba3fb4d762997d33075dcf8bfa","modified":1624084345732},{"_id":"themes/Chic/source/css/_highlight/docco.styl","hash":"b1c176378bb275f2e8caa759f36294e42d614bf1","modified":1624084345732},{"_id":"themes/Chic/source/css/_highlight/foundation.styl","hash":"bf8ddc94b4ad995b8b8805b5a4cf95004553fdac","modified":1624084345733},{"_id":"themes/Chic/source/css/_highlight/far.styl","hash":"aaac3028f5e33123cd123a583cddc9290c45ec8e","modified":1624084345733},{"_id":"themes/Chic/source/css/_highlight/github-gist.styl","hash":"48211a03d33e7f7ada0b261162bea06676155a71","modified":1624084345733},{"_id":"themes/Chic/source/css/_highlight/github.styl","hash":"3336aeba324c6d34a6fd41fef9b47bc598f7064c","modified":1624084345733},{"_id":"themes/Chic/source/css/_highlight/googlecode.styl","hash":"bda816beee7b439814b514e6869dc678822be1bc","modified":1624084345734},{"_id":"themes/Chic/source/css/_highlight/grayscale.styl","hash":"bf37d8b8d1e602126c51526f0cc28807440228ed","modified":1624084345734},{"_id":"themes/Chic/source/css/_highlight/highlightjs.styl","hash":"65b5981dc3c57cedd1cb668c0e377230987e08d1","modified":1624084345734},{"_id":"themes/Chic/source/css/_highlight/gruvbox-dark.styl","hash":"76b744c14fd5600bea64731c05df97c2df75523f","modified":1624084345734},{"_id":"themes/Chic/source/css/_highlight/hopscotch.styl","hash":"1378a6bc67a32c0cbff72ab771268b53f9aa586d","modified":1624084345734},{"_id":"themes/Chic/source/css/_highlight/hybrid.styl","hash":"b8eb5c69d12f2ee5ebc50265ae271699d7f1a8d3","modified":1624084345735},{"_id":"themes/Chic/source/css/_highlight/idea.styl","hash":"a02967cb51c16a34e0ee895d33ded2b823d35b21","modified":1624084345735},{"_id":"themes/Chic/source/css/_highlight/index.styl","hash":"002d5596f6379cc87dbd43d9145bc764aa666be1","modified":1624084345735},{"_id":"themes/Chic/source/css/_highlight/ir-black.styl","hash":"53e5d74326a4527b92272bbd6946d4fec92720e8","modified":1624084345735},{"_id":"themes/Chic/source/css/_highlight/kimbie.dark.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1624084345736},{"_id":"themes/Chic/source/css/_highlight/kimbie.light.styl","hash":"61f8baed25be05288c8604d5070afbcd9f183f49","modified":1624084345736},{"_id":"themes/Chic/source/css/_highlight/kimbie.styl","hash":"51b889ca7c6fe178cfbbe28d875a6ea427184441","modified":1624084345736},{"_id":"themes/Chic/source/css/_highlight/magula.styl","hash":"16d323f989b1420a0f72ef989242ece9bf17a456","modified":1624084345736},{"_id":"themes/Chic/source/css/_highlight/mono-blue.styl","hash":"4c89a6ae29de67c0700585af82a60607e85df928","modified":1624084345737},{"_id":"themes/Chic/source/css/_highlight/monokai-sublime.styl","hash":"c385b11345894be7e6ce3c5f08663e199933b8e4","modified":1624084345737},{"_id":"themes/Chic/source/css/_highlight/monokai.styl","hash":"f87be027848ea6bee623a08ad1e17b2f5b7937ee","modified":1624084345737},{"_id":"themes/Chic/source/css/_highlight/obsidian.styl","hash":"199e28326be8590883f0813ebbd54fcfaa4750fd","modified":1624084345737},{"_id":"themes/Chic/source/css/_highlight/paraiso-dark.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1624084345738},{"_id":"themes/Chic/source/css/_highlight/paraiso-light.styl","hash":"d224d1df0eb3395d9eea1344cee945c228af2911","modified":1624084345738},{"_id":"themes/Chic/source/css/_highlight/paraiso.styl","hash":"75f181eece6b71d033ea0c8d6cf00ae7efb9e29b","modified":1624084345738},{"_id":"themes/Chic/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1624084345738},{"_id":"themes/Chic/source/css/_highlight/pojoaque.styl","hash":"2601b4285803a7cea5ccded8d624ca95f80e3d88","modified":1624084345738},{"_id":"themes/Chic/source/css/_highlight/railscasts.styl","hash":"b6674db9210e0c4444e4835fff2d1361f3ebd64c","modified":1624084345739},{"_id":"themes/Chic/source/css/_highlight/rainbow.styl","hash":"c0cf97aae3e10fdcd10414547a711c9effbc39b8","modified":1624084345739},{"_id":"themes/Chic/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1624084345739},{"_id":"themes/Chic/source/css/_highlight/school-book.styl","hash":"beabbbcc7930f8de19159381a01c0ba41dc2291f","modified":1624084345739},{"_id":"themes/Chic/source/css/_highlight/solarized-dark.styl","hash":"90c9da5aa594383697e5b18892a7f95beb053f55","modified":1624084345740},{"_id":"themes/Chic/source/css/_highlight/solarized-light.styl","hash":"aa0dd3fd25c464183b59c5575c9bee8756b397f2","modified":1624084345740},{"_id":"themes/Chic/source/css/_highlight/sunburst.styl","hash":"af3eec0fd56151e55bbd49c31b151f36717611d8","modified":1624084345741},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night-blue.styl","hash":"f24c17d0ab815dcfaab3438cb9fe2ab4839f5e0d","modified":1624084345741},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night-bright.styl","hash":"7674fecb6d27350727dc0d2dc93bc018382ebbd0","modified":1624084345741},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night-eighties.styl","hash":"28d751075ebabf7d0327a36f725076fe82fdf626","modified":1624084345741},{"_id":"themes/Chic/source/css/_highlight/tomorrow-night.styl","hash":"16ba09b2db501e4e3e2e7d62595d9bf935bf27c4","modified":1624084345741},{"_id":"themes/Chic/source/css/_highlight/tomorrow.styl","hash":"15779cf6846725c7c35fc56cac39047d7e0aec1c","modified":1624084345742},{"_id":"themes/Chic/source/css/_highlight/vs.styl","hash":"959a746f4b37aacb5d1d6ff1d57e0c045289d75d","modified":1624084345742},{"_id":"themes/Chic/source/css/_highlight/xcode.styl","hash":"5e8532ae8366dcf6a4ef5e4813dc3d42ab3d0a50","modified":1624084345742},{"_id":"themes/Chic/source/css/_highlight/zenburn.styl","hash":"68ff9332ccc03f9389b15b713415cde016f8088f","modified":1624084345742},{"_id":"themes/Chic/source/css/_page/archive.styl","hash":"71ea842f068b29b4418dd09450db09d27dcf0947","modified":1624084345745},{"_id":"themes/Chic/source/css/_page/category.styl","hash":"cead361269616b7a6ddec3090d9fa34c3c6ac722","modified":1624084345745},{"_id":"themes/Chic/source/css/_page/page.styl","hash":"34e33b52d2e046aa2f5494e81ff4ac2d5ca78058","modified":1624084345745},{"_id":"themes/Chic/source/css/_page/profile.styl","hash":"5ef6d5a06132f26b7aa01b2fbf4bbfb8ee862b7b","modified":1624084345745},{"_id":"themes/Chic/source/css/_page/tag.styl","hash":"55b220cc58011876fb3a470cd1fde8ed87c93079","modified":1624084345746},{"_id":"themes/Chic/source/css/_partial/footer.styl","hash":"4f58e607eaa59cda3b5a9fdb3404ffb75c4d1a03","modified":1624084345746},{"_id":"themes/Chic/source/css/_partial/header.styl","hash":"be70b4ab3bcc977f1055664899742804c716929d","modified":1624084345746},{"_id":"themes/Chic/source/css/_partial/paginator.styl","hash":"b4f4a5180c4cbc70d186792b8a1fd0f5855bd86a","modified":1624084345746},{"_id":"themes/Chic/source/fonts/iconfont/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1624084345749},{"_id":"themes/Chic/source/fonts/iconfont/demo_index.html","hash":"16e01463756a77b4acd15ade4e6b73f0376d75e1","modified":1624084345749},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.css","hash":"1e5540dca41dc53879226750f936e72daf616662","modified":1624084345749},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.eot","hash":"d18736f7885569e497698d17f49b9167add67dc6","modified":1624084345749},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.js","hash":"87bfdaae31251f4d605646c5ae9c67196f6cc4e2","modified":1624084345750},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.json","hash":"eae94b803d34035008842855d0bead92d2035281","modified":1624084345750},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.ttf","hash":"41c4f4dc82e42452dcfd19caed6c7dc333ee769e","modified":1624084345751},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.svg","hash":"5c9c4e44179a7435d0f91df4ce1154dd677ad8c2","modified":1624084345750},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff","hash":"a57593c49b56c16ac1def0e1f3dbca3f658b3579","modified":1624084345751},{"_id":"themes/Chic/source/fonts/iconfont/iconfont.woff2","hash":"39d97a0f72417487f5c1e0a0abf8e27dd6ebda31","modified":1624084345751},{"_id":"themes/Chic/source/css/_page/_post/post_code.styl","hash":"06c3a3524ffd4b27e03e79489001997ea5d727d3","modified":1624084345743},{"_id":"themes/Chic/source/css/_page/_post/post_copyright.styl","hash":"64fd9f07ed45f035057d46740af0db70218714aa","modified":1624084345744},{"_id":"themes/Chic/source/css/_page/_post/post_content.styl","hash":"5e3d63077549d8e2e5ff8c452e809760f5a99c17","modified":1624084345743},{"_id":"themes/Chic/source/css/_page/_post/post_header.styl","hash":"d37b032bc5edca92c84bf62070a28fa40939df55","modified":1624084345744},{"_id":"themes/Chic/source/css/_page/_post/post_tags.styl","hash":"2ff93677aa4d81da83c659b4dd4e3cb482d9ce7d","modified":1624084345744},{"_id":"themes/Chic/source/css/_page/_post/post_nav.styl","hash":"03accaba13c995cbe65a05a88549ff74e992eb3f","modified":1624084345744},{"_id":"themes/Chic/source/css/_page/_post/post_toc.styl","hash":"15e1ec7af93f41184f986aba21991a79923b0a0e","modified":1624084345745},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff2","hash":"5f325fcd2726a5b44e08b7004a5219e14847cbfa","modified":1624084345841},{"_id":"themes/Chic/source/fonts/lanting/lanting.woff","hash":"642ad1f17d27d4b1010d1a0571d1b44cbc823d9d","modified":1624084345838},{"_id":"themes/Chic/source/fonts/lanting/lanting.eot","hash":"3e184614f037939a6f98d607da3ed7dffb350e65","modified":1624084345794},{"_id":"themes/Chic/source/fonts/lanting/lanting.TTF","hash":"97e9a4538cceef4b17d54c7dc589524905d1b685","modified":1624084345775},{"_id":"themes/Chic/source/fonts/lanting/lanting.otf","hash":"4e184da596772d3ef6e5763cdee3e46a1ce2f2dd","modified":1624084345834},{"_id":"public/2020/09/06/2020-09-06-iOS alloc原理/index.html","hash":"702439b82ea041eb84b1a9aa3e404fb243128da5","modified":1624585667140},{"_id":"public/2020/07/21/2020-07-21-Cocoapods安装与更新/index.html","hash":"c342107a2cef301c73f8095a047c4c6cd709c5b0","modified":1624585667140},{"_id":"public/2020/07/17/2020-07-17-OpenGL向量、矩阵相关/index.html","hash":"34d66146290a82be112218e9d2b441528833fe30","modified":1624585667140},{"_id":"public/2020/07/13/2020-07-13-OpenGL颜色混合/index.html","hash":"182edc6ef5ad91c795dd85f1dfca06a1f4145c4d","modified":1624585667140},{"_id":"public/2020/07/07/2020-07-07-OpenGL架构/index.html","hash":"9da9e3eb8d63f5dd54cc5685280ee5786b8f8886","modified":1624585667140},{"_id":"public/2020/07/04/2020-07-04-iOS保持界面流畅/index.html","hash":"34c1ca44e377eb9bc3a3c0b34e996bb5f925019f","modified":1624585667140},{"_id":"public/2020/07/02/2020-07-02-OpenGL常见专业名词/index.html","hash":"e28f2877a735a5936ddf539aa751c27ac475c0ce","modified":1624585667140},{"_id":"public/2020/03/07/2020-03-07-React Native是如何工作的/index.html","hash":"eb0c723034600e706094cdaf536d8693f749fc9f","modified":1624585667140},{"_id":"public/2019/09/02/2019-08-30-react-native-WebView和H5交互/index.html","hash":"37aa4be4f98ea9066cc46e91009595eb03c86504","modified":1624585667140},{"_id":"public/2019/08/16/2019-08-16-hello-Leisure/index.html","hash":"da7089b1baff76abc8082cc98fce50ad167585a9","modified":1624585667140},{"_id":"public/archives/index.html","hash":"43f511e72931b0b0f0ed0d7a30e865f601b3a510","modified":1624585667140},{"_id":"public/archives/page/2/index.html","hash":"23484648969c54733e8bef9b1061aed413b365ad","modified":1624585667140},{"_id":"public/archives/page/3/index.html","hash":"75c26bbb1a16dfca0a28fa376c15364132790250","modified":1624585667140},{"_id":"public/archives/2019/index.html","hash":"f9458d6c57d520639b58ea195e3d56c31bbddd80","modified":1624585667140},{"_id":"public/archives/2019/08/index.html","hash":"20d435fd804531e733120e0dc11ffae614ed231f","modified":1624585667140},{"_id":"public/archives/2019/09/index.html","hash":"203d88d6a8aff725b491453dafd9e9d716960fe1","modified":1624585667140},{"_id":"public/archives/2020/index.html","hash":"d9c357f8e1a477e1c1d1069daab56ced6bfcd88f","modified":1624585667140},{"_id":"public/archives/2020/page/2/index.html","hash":"e9b76b54e03c70da258889dd288fe64c7231a7b8","modified":1624585667140},{"_id":"public/archives/2020/page/3/index.html","hash":"87cfbdd3ed31fb9948e9a9752bfc2b1a42199345","modified":1624585667140},{"_id":"public/archives/2020/07/index.html","hash":"1d1905316be1271feddb500c2790d85514cff671","modified":1624585667140},{"_id":"public/archives/2020/03/index.html","hash":"0572f217bcd33b1dfdb965cefcd3d22e554b9259","modified":1624585667140},{"_id":"public/archives/2020/07/page/2/index.html","hash":"42ab1c7dfa154432f63eb5cd7bad201807b18baa","modified":1624585667140},{"_id":"public/archives/2020/08/index.html","hash":"c27a178715e24a6439bad2e2acac9f6ac34bf94a","modified":1624585667140},{"_id":"public/archives/2020/09/index.html","hash":"754668773e98371a91117b55d4b08bba5b597f1e","modified":1624585667140},{"_id":"public/archives/2020/10/index.html","hash":"323144d1b2669818532e5246fd8781a70d1d55c4","modified":1624585667140},{"_id":"public/categories/生活/index.html","hash":"7543274733633637373bd8cd795a0548b61a3813","modified":1624585667140},{"_id":"public/categories/iOS/index.html","hash":"1190472c42e251c7ddce9570f1517c9a961e7d41","modified":1624585667140},{"_id":"public/categories/WebRTC学习/index.html","hash":"abf8788adae24fa7d4d950f849345f11854b43dd","modified":1624585667140},{"_id":"public/categories/React-Native/index.html","hash":"ccf6996a7c6eb757f6001e2f5fba64a58f5e11c2","modified":1624585667140},{"_id":"public/categories/OpenGL/index.html","hash":"9b65fc9f475dd141fe8747cd7412b4319349b9c5","modified":1624585667140},{"_id":"public/categories/iOS/Cocoapods/index.html","hash":"c8a2f21a4bc16e9e68e7b6b85db39f3a9b3e9cfe","modified":1624585667140},{"_id":"public/categories/OpenGL-ES/index.html","hash":"87cda59c2164aba9b45c2258b706f74241f57c88","modified":1624585667140},{"_id":"public/categories/iOS底层原理/index.html","hash":"5338cfa8ad960adab8d6a175e60f0dc0547106ac","modified":1624585667140},{"_id":"public/categories/OpenGL-ES/GLSL/index.html","hash":"60f911965215c97e73dd4b30888982425234fc36","modified":1624585667140},{"_id":"public/index.html","hash":"8ac8559526c515c9d99aaa5b9fe40c2c53ebc5ca","modified":1624585667140},{"_id":"public/page/2/index.html","hash":"8ac8559526c515c9d99aaa5b9fe40c2c53ebc5ca","modified":1624585667140},{"_id":"public/tags/生活/index.html","hash":"9fcf8ebb6aee872387d4dd32c34ab008769082e0","modified":1624585667140},{"_id":"public/tags/iOS/index.html","hash":"48fe6101e3e78bde01d1a65311993c0e6cb83fa0","modified":1624585667140},{"_id":"public/tags/WebRTC学习/index.html","hash":"59ff3b4c51ff241a62b91eafb60a67482a8a5a29","modified":1624585667140},{"_id":"public/tags/React-Native/index.html","hash":"8c7d8d079f88d328a07f023de8c8bb4c1ef5a084","modified":1624585667140},{"_id":"public/tags/OpenGL/index.html","hash":"aef7a79806add6e6648cffa2a60e6b68c10e5862","modified":1624585667140},{"_id":"public/tags/Cocoapods/index.html","hash":"94a9d50fe7151cd56eb02f89a17d00eafb0e7b67","modified":1624585667140},{"_id":"public/tags/OpenGL-ES/index.html","hash":"472bbfa3697ae8bc9026a15bbf6802e3129de821","modified":1624585667140},{"_id":"public/tags/GLSL/index.html","hash":"c022ce465bc7f5be9533e510acfe6be311e4fb61","modified":1624585667140},{"_id":"public/tags/iOS底层原理/index.html","hash":"3e07d7303e433bc5924ffd281a4086e110b85e81","modified":1624585667140},{"_id":"public/2020/10/15/2020-10-15-iOS APP启动流程/index.html","hash":"b73101fe5afce77b8d28272f7986a5f07032cb59","modified":1624585667140},{"_id":"public/2020/09/24/2020-09-24-objc_msgSend源码解析(三)/index.html","hash":"2407d0bedcc44d08d8adb60d70221ad52ff49716","modified":1624585667140},{"_id":"public/2020/09/20/2020-09-20-objc_msgSend源码解析(一)/index.html","hash":"5bc725f314ebe3a94d738233b840117f277f3f7a","modified":1624585667140},{"_id":"public/2020/09/23/2020-09-23-objc_msgSend源码解析(二)/index.html","hash":"c466b66f736a26bce8183c7d6ed59dc39022579d","modified":1624585667140},{"_id":"public/2020/09/18/2020-09-18-iOS cache_t结构分析/index.html","hash":"ee41c11170125e43d883409cdab95619f062bd02","modified":1624585667140},{"_id":"public/2020/09/15/2020-09-15-iOS 类的结构分析(二)/index.html","hash":"1cab380663ec9088e95ec3ca65f3c761221c33e0","modified":1624585667140},{"_id":"public/2020/09/13/2020-09-13-iOS 类的结构分析/index.html","hash":"5bf1f3d6a361722f968cb53703745f7e64afb8d2","modified":1624585667140},{"_id":"public/2020/09/10/2020-09-10-isa结构解析/index.html","hash":"832d485632fba0fece592830232d4d200091bd06","modified":1624585667140},{"_id":"public/2020/08/02/2020-08-02-OpenGL ES GLSL加载纹理/index.html","hash":"878cbd2db1f119ba2942486be8017af3349a1790","modified":1624585667140},{"_id":"public/2020/08/02/2020-08-02-翻转纹理的5种方式/index.html","hash":"e9c13414eb77172b49ac9122b5efa63c7f1af9ce","modified":1624585667140},{"_id":"public/2020/07/28/2020-07-28-OpenGL ES&GLKit加载纹理/index.html","hash":"ea8b8996dbd2e17aed7fb711d3616d1d2db03972","modified":1624585667140},{"_id":"public/2020/07/22/2020-07-22-OpenGL纹理加载与镜像/index.html","hash":"cdd6e84cfaaa7bb63b3cb8b8ebf66673f1ade38b","modified":1624585667140},{"_id":"public/2020/07/10/2020-07-10-OpenGL正背面剔除和深度测试/index.html","hash":"c8659b1758178c892c66a9d6360c927758b477c8","modified":1624585667140},{"_id":"public/2020/07/07/2020-07-07-iOS离屏渲染解析/index.html","hash":"763bae62973807cdf46762c2f9c429881b46d646","modified":1624585667140},{"_id":"public/2020/07/03/2020-07-03-iOS图片解码/index.html","hash":"1b0bed5baeeb94d3d78c097bb3ffc85f4bf7747f","modified":1624585667140},{"_id":"public/2019/09/05/2019-09-05-webrtc-视频采集/index.html","hash":"c4034143a031b774feb11a152a3dbb10e6dc3a21","modified":1624585667140},{"_id":"public/avatar.jpg","hash":"e8e0dca78d92b9cd0681c1b7390980a8c89ea472","modified":1624090476023},{"_id":"public/favicon.ico","hash":"48678c6e2c4045a5945572d60bf53014a35c8aea","modified":1624090476023},{"_id":"public/fonts/iconfont/iconfont.ttf","hash":"41c4f4dc82e42452dcfd19caed6c7dc333ee769e","modified":1624090476023},{"_id":"public/fonts/iconfont/iconfont.svg","hash":"5c9c4e44179a7435d0f91df4ce1154dd677ad8c2","modified":1624090476023},{"_id":"public/image/avatar.jpeg","hash":"e8e0dca78d92b9cd0681c1b7390980a8c89ea472","modified":1624090476023},{"_id":"public/fonts/iconfont/iconfont.eot","hash":"d18736f7885569e497698d17f49b9167add67dc6","modified":1624090476023},{"_id":"public/fonts/iconfont/iconfont.woff","hash":"a57593c49b56c16ac1def0e1f3dbca3f658b3579","modified":1624090476023},{"_id":"public/fonts/iconfont/iconfont.woff2","hash":"39d97a0f72417487f5c1e0a0abf8e27dd6ebda31","modified":1624090476023},{"_id":"public/icons/icon-512x512.png","hash":"2d05e5b19ec60bde5e8474635a0424f1fa7f1bd9","modified":1624090476023},{"_id":"public/css/base.css","hash":"2fce73a3c2df8f93edeb5e34a53b7d83e5191d85","modified":1624090476023},{"_id":"public/css/custom.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1624090476023},{"_id":"public/css/layout.css","hash":"c81e2e01ff5e95a3e613064b8490045ff936c305","modified":1624090476023},{"_id":"public/css/normalize.css","hash":"2d4b663b6a4c68295b6ba240fa2dd9fb3863093c","modified":1624090476023},{"_id":"public/css/font.css","hash":"87059edd1f2bfc4296f5599e73208893f2b06458","modified":1624090476023},{"_id":"public/css/media.css","hash":"5023ee404900a47d61ca0591b2d4e9eace0fe88e","modified":1624090476023},{"_id":"public/css/variable.css","hash":"cb4180b3bbad471e30cf52ebb40e998d58a30d7d","modified":1624090476023},{"_id":"public/js/script.js","hash":"93694e4e16893f83611daa5ba3723b14ecc80abb","modified":1624090476023},{"_id":"public/js/tocbot.min.js","hash":"bae97e8a24a05a99335f8e725641c8ca9c50502a","modified":1624090476023},{"_id":"public/fonts/iconfont/demo.css","hash":"65c50db528a5abe06426b1a20735feaf1f2a0d9b","modified":1624090476023},{"_id":"public/fonts/iconfont/iconfont.css","hash":"1e5540dca41dc53879226750f936e72daf616662","modified":1624090476023},{"_id":"public/fonts/iconfont/iconfont.json","hash":"3123aa840109e385d58a75d34e88a2d621e1ada8","modified":1624090476023},{"_id":"public/css/style.css","hash":"a348e7b97835a4865d295c4f9c863a55f6f99d72","modified":1624090476023},{"_id":"public/fonts/iconfont/demo_index.html","hash":"16e01463756a77b4acd15ade4e6b73f0376d75e1","modified":1624090476023},{"_id":"public/js/mathjax2.7.5.js","hash":"7ba18c783d543cfb4b45a0118ccb73d3f68cd46e","modified":1624090476023},{"_id":"public/fonts/iconfont/iconfont.js","hash":"87bfdaae31251f4d605646c5ae9c67196f6cc4e2","modified":1624090476023},{"_id":"public/fonts/lanting/lanting.woff2","hash":"5f325fcd2726a5b44e08b7004a5219e14847cbfa","modified":1624090476023},{"_id":"public/fonts/lanting/lanting.woff","hash":"642ad1f17d27d4b1010d1a0571d1b44cbc823d9d","modified":1624090476023},{"_id":"public/fonts/lanting/lanting.eot","hash":"3e184614f037939a6f98d607da3ed7dffb350e65","modified":1624090476023},{"_id":"public/fonts/lanting/lanting.TTF","hash":"97e9a4538cceef4b17d54c7dc589524905d1b685","modified":1624090476023},{"_id":"public/fonts/lanting/lanting.otf","hash":"4e184da596772d3ef6e5763cdee3e46a1ce2f2dd","modified":1624090476023},{"_id":"source/tag/index.md","hash":"762f9b88f6c9f8df20acb74dee6d6ea82c2a6cca","modified":1624091935119},{"_id":"public/tag/index.html","hash":"413f92afd9d5b5d5061324450b8f346e6c45a0c2","modified":1624091941214},{"_id":"source/_posts/2021-06-24-Objective-C Dispatch Direct.md","hash":"2385bbe1091d041d0805daa93a3c67830315ae14","modified":1624585657264},{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1624585577295},{"_id":"public/2021/06/25/2021-06-24-Objective-C Dispatch Direct/index.html","hash":"86ecf7b0efa901f4cb39939e6d3225fc9620df7c","modified":1624585667140},{"_id":"public/archives/2021/index.html","hash":"53d63e734fe746f609b3ec2f5597374341d766fc","modified":1624585667140},{"_id":"public/archives/2021/06/index.html","hash":"b9d0556b7c9a825707b781c761b0d007cf98016f","modified":1624585667140},{"_id":"source/_posts/2021-07-07 HashMap分析.md","hash":"836f32360267aa6af8e0d3f2036f03e4b34e9e06","modified":1625660526178}],"Category":[{"name":"生活","_id":"ckq3hjbp60002bjrjgbpl7yar"},{"name":"iOS","_id":"ckq3hjbpa0007bjrj4bcobo5x"},{"name":"WebRTC学习","_id":"ckq3hjbpd000dbjrjdq4f7yyd"},{"name":"React Native","_id":"ckq3hjbpg000kbjrj0ywpb3sq"},{"name":"OpenGL","_id":"ckq3hjbpj000tbjrja4dt4ow3"},{"name":"Cocoapods","parent":"ckq3hjbpa0007bjrj4bcobo5x","_id":"ckq3hjbpz001rbjrj90pphxbx"},{"name":"OpenGL ES","_id":"ckq3hjbq1001ybjrjejcb2pvs"},{"name":"iOS底层原理","_id":"ckq3hjbq4002bbjrj4kii6hrs"},{"name":"GLSL","parent":"ckq3hjbq1001ybjrjejcb2pvs","_id":"ckq3hjbqb0037bjrj0t0vdlcs"}],"Data":[],"Page":[],"Post":[{"title":"欢迎来到Leisure的博客","date":"2019-08-16T14:00:00.000Z","_content":"\n> “Hey, this is me.”\n\n\n## 正文\n\nLeisure 的 Blog 就这么开通了。\n\n一直想要找个地，记录下自己的学习、生活的轨迹，奈何拖延症严重，行动跟不上思想。不过好在，一切都不晚。\n\n前两天刚做了个测评，给出的关键字是知足常乐、量力而行，还是有点小认同的，但是我也认为自己是思进取，有危机意识的21世纪奶爸，毕竟不能苦了媳妇和孩子嘛。\n\n第一篇肯定是没有技术相关的了，只会啰哩啰嗦的就当给自己开个头，所以对这个不太感兴趣的，我只能说敬请期待咯。\n\n---\n\n### 对工作的愿景\n\n当然希望自己在技术领域能够越来越深入，奔着成为大牛一点点前进，做自己干着开心的工作😄。\n\n### 对家庭的愿景\n\n希望家人都健健康康、开开心心的🥰。","source":"_posts/2019-08-16-hello-Leisure.md","raw":"---\ntitle:      \"欢迎来到Leisure的博客\" \ndate:       2019-08-16 22:00:00\ntags:\n    - 生活\ncategories:\n    - 生活\n---\n\n> “Hey, this is me.”\n\n\n## 正文\n\nLeisure 的 Blog 就这么开通了。\n\n一直想要找个地，记录下自己的学习、生活的轨迹，奈何拖延症严重，行动跟不上思想。不过好在，一切都不晚。\n\n前两天刚做了个测评，给出的关键字是知足常乐、量力而行，还是有点小认同的，但是我也认为自己是思进取，有危机意识的21世纪奶爸，毕竟不能苦了媳妇和孩子嘛。\n\n第一篇肯定是没有技术相关的了，只会啰哩啰嗦的就当给自己开个头，所以对这个不太感兴趣的，我只能说敬请期待咯。\n\n---\n\n### 对工作的愿景\n\n当然希望自己在技术领域能够越来越深入，奔着成为大牛一点点前进，做自己干着开心的工作😄。\n\n### 对家庭的愿景\n\n希望家人都健健康康、开开心心的🥰。","slug":"2019-08-16-hello-Leisure","published":1,"updated":"2021-06-19T03:46:24.082Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjboz0000bjrj4zc53a4m","content":"<blockquote>\n<p>“Hey, this is me.”</p>\n</blockquote>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>Leisure 的 Blog 就这么开通了。</p>\n<p>一直想要找个地，记录下自己的学习、生活的轨迹，奈何拖延症严重，行动跟不上思想。不过好在，一切都不晚。</p>\n<p>前两天刚做了个测评，给出的关键字是知足常乐、量力而行，还是有点小认同的，但是我也认为自己是思进取，有危机意识的21世纪奶爸，毕竟不能苦了媳妇和孩子嘛。</p>\n<p>第一篇肯定是没有技术相关的了，只会啰哩啰嗦的就当给自己开个头，所以对这个不太感兴趣的，我只能说敬请期待咯。</p>\n<hr>\n<h3 id=\"对工作的愿景\"><a href=\"#对工作的愿景\" class=\"headerlink\" title=\"对工作的愿景\"></a>对工作的愿景</h3><p>当然希望自己在技术领域能够越来越深入，奔着成为大牛一点点前进，做自己干着开心的工作😄。</p>\n<h3 id=\"对家庭的愿景\"><a href=\"#对家庭的愿景\" class=\"headerlink\" title=\"对家庭的愿景\"></a>对家庭的愿景</h3><p>希望家人都健健康康、开开心心的🥰。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>“Hey, this is me.”</p>\n</blockquote>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>Leisure 的 Blog 就这么开通了。</p>\n<p>一直想要找个地，记录下自己的学习、生活的轨迹，奈何拖延症严重，行动跟不上思想。不过好在，一切都不晚。</p>\n<p>前两天刚做了个测评，给出的关键字是知足常乐、量力而行，还是有点小认同的，但是我也认为自己是思进取，有危机意识的21世纪奶爸，毕竟不能苦了媳妇和孩子嘛。</p>\n<p>第一篇肯定是没有技术相关的了，只会啰哩啰嗦的就当给自己开个头，所以对这个不太感兴趣的，我只能说敬请期待咯。</p>\n<hr>\n<h3 id=\"对工作的愿景\"><a href=\"#对工作的愿景\" class=\"headerlink\" title=\"对工作的愿景\"></a>对工作的愿景</h3><p>当然希望自己在技术领域能够越来越深入，奔着成为大牛一点点前进，做自己干着开心的工作😄。</p>\n<h3 id=\"对家庭的愿景\"><a href=\"#对家庭的愿景\" class=\"headerlink\" title=\"对家庭的愿景\"></a>对家庭的愿景</h3><p>希望家人都健健康康、开开心心的🥰。</p>\n"},{"title":"RN的WebView、OC的WKWebView和H5交互","date":"2019-09-02T14:00:00.000Z","_content":"\n### OC WKWebView和H5交互\n\n#### H5给OC发消息（H5调用OC的方法）\n\n1、在OC端通过以下方法，注册要被调用的函数名\n\n\t - (void)addScriptMessageHandler:(id<WKScriptMessageHandler>)scriptMessageHandler name:(NSString *)name; \n\n> Adding a script message handler with name name causes the JavaScript function window.webkit.messageHandlers.name.postMessage(messageBody) to be defined in all frames in all web views that use the user content controller.\n\n2、H5通过```window.webkit.messageHandlers.name.postMessage(messageBody)```\n来调用在OC端注册了的函数。\n\n\tname即在OC端注册的函数名。\n\n\tmessageBody可作为参数传递给OC端。\n\n> 当不需要传递参数时，应该```window.webkit.messageHandlers.name.postMessage(null);```,不写null时OC是收不到消息的\n\n\n3、OC通过以下代理监听H5发过来的消息\n\n```\n- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message{\n\t    NSString *messageName = message.name;\n\t    id messageBody = message.body;\n\t    if ([messageName isEqualToString:name]) {\n\t        //doSomething...\n\t    }\n\t}\n```\n\n通过判断messageName和自己注册的是否一直，分别进行操作。\n\nmessageBody可以是字符串，可以是字典格式。\n\n#### OC给H5发消息（OC调用H5的方法或者回调）\n\n```\n- (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^)(id, NSError *error))completionHandler;\n\nNSString *javaScriptString = [NSString stringWithFormat:@\"OCCallJS('%@','%@')\",@\"v1\",@\"v2\"];\n```\n\t\n> 传递参数为字符串时，```OCCallJS('%@','%@')```,```%@```必须被引号引住\n> \n> 在H5端，alert收到的参数是不生效的，不知道为什么😂\n\n### react-native WebView和H5交互\n\nH5给RN发消息 \n\n```\nwindow.postMessage(\"jsCallRN\");\n```\n\nRN获取H5发送的消息\n\n```\nonMessage = (e) => {\n\tlet jsMessage = e.nativeEvent.data;\n\tif (jsMessage && jsMessage == \"jsCallRN\") {\n\t\t//doSomething...\n\t}\n}\n\n```\n\n---\n\nRN给H5发消息\n\n```\nthis.webView.postMessage(\"messageStr\");\n```\n\nH5获取RN发送的消息\n\n```\nwindow.document.addEventListener('message', function (e) {\n    const messageStr = e.data;\n    //doSomething\n});\n```\n\n> 注意\n> 调试时，H5页面报错，可能互相交互传递的消息收不到。","source":"_posts/2019-08-30-react-native-WebView和H5交互.md","raw":"---\ntitle:      \"RN的WebView、OC的WKWebView和H5交互\" \ndate:       2019-09-02 22:00:00\ntags:\n    - iOS\ncategories:\n    - iOS\n---\n\n### OC WKWebView和H5交互\n\n#### H5给OC发消息（H5调用OC的方法）\n\n1、在OC端通过以下方法，注册要被调用的函数名\n\n\t - (void)addScriptMessageHandler:(id<WKScriptMessageHandler>)scriptMessageHandler name:(NSString *)name; \n\n> Adding a script message handler with name name causes the JavaScript function window.webkit.messageHandlers.name.postMessage(messageBody) to be defined in all frames in all web views that use the user content controller.\n\n2、H5通过```window.webkit.messageHandlers.name.postMessage(messageBody)```\n来调用在OC端注册了的函数。\n\n\tname即在OC端注册的函数名。\n\n\tmessageBody可作为参数传递给OC端。\n\n> 当不需要传递参数时，应该```window.webkit.messageHandlers.name.postMessage(null);```,不写null时OC是收不到消息的\n\n\n3、OC通过以下代理监听H5发过来的消息\n\n```\n- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message{\n\t    NSString *messageName = message.name;\n\t    id messageBody = message.body;\n\t    if ([messageName isEqualToString:name]) {\n\t        //doSomething...\n\t    }\n\t}\n```\n\n通过判断messageName和自己注册的是否一直，分别进行操作。\n\nmessageBody可以是字符串，可以是字典格式。\n\n#### OC给H5发消息（OC调用H5的方法或者回调）\n\n```\n- (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^)(id, NSError *error))completionHandler;\n\nNSString *javaScriptString = [NSString stringWithFormat:@\"OCCallJS('%@','%@')\",@\"v1\",@\"v2\"];\n```\n\t\n> 传递参数为字符串时，```OCCallJS('%@','%@')```,```%@```必须被引号引住\n> \n> 在H5端，alert收到的参数是不生效的，不知道为什么😂\n\n### react-native WebView和H5交互\n\nH5给RN发消息 \n\n```\nwindow.postMessage(\"jsCallRN\");\n```\n\nRN获取H5发送的消息\n\n```\nonMessage = (e) => {\n\tlet jsMessage = e.nativeEvent.data;\n\tif (jsMessage && jsMessage == \"jsCallRN\") {\n\t\t//doSomething...\n\t}\n}\n\n```\n\n---\n\nRN给H5发消息\n\n```\nthis.webView.postMessage(\"messageStr\");\n```\n\nH5获取RN发送的消息\n\n```\nwindow.document.addEventListener('message', function (e) {\n    const messageStr = e.data;\n    //doSomething\n});\n```\n\n> 注意\n> 调试时，H5页面报错，可能互相交互传递的消息收不到。","slug":"2019-08-30-react-native-WebView和H5交互","published":1,"updated":"2021-06-19T03:46:24.082Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbp40001bjrjfl1bhipo","content":"<h3 id=\"OC-WKWebView和H5交互\"><a href=\"#OC-WKWebView和H5交互\" class=\"headerlink\" title=\"OC WKWebView和H5交互\"></a>OC WKWebView和H5交互</h3><h4 id=\"H5给OC发消息（H5调用OC的方法）\"><a href=\"#H5给OC发消息（H5调用OC的方法）\" class=\"headerlink\" title=\"H5给OC发消息（H5调用OC的方法）\"></a>H5给OC发消息（H5调用OC的方法）</h4><p>1、在OC端通过以下方法，注册要被调用的函数名</p>\n<pre><code> - (void)addScriptMessageHandler:(id&lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name; \n</code></pre>\n<blockquote>\n<p>Adding a script message handler with name name causes the JavaScript function window.webkit.messageHandlers.name.postMessage(messageBody) to be defined in all frames in all web views that use the user content controller.</p>\n</blockquote>\n<p>2、H5通过<code>window.webkit.messageHandlers.name.postMessage(messageBody)</code><br>来调用在OC端注册了的函数。</p>\n<pre><code>name即在OC端注册的函数名。\n\nmessageBody可作为参数传递给OC端。\n</code></pre>\n<blockquote>\n<p>当不需要传递参数时，应该<code>window.webkit.messageHandlers.name.postMessage(null);</code>,不写null时OC是收不到消息的</p>\n</blockquote>\n<p>3、OC通过以下代理监听H5发过来的消息</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)userContentController:(<span class=\"built_in\">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class=\"built_in\">WKScriptMessage</span> *)message&#123;</span><br><span class=\"line\">\t    <span class=\"built_in\">NSString</span> *messageName = message.name;</span><br><span class=\"line\">\t    <span class=\"keyword\">id</span> messageBody = message.body;</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> ([messageName isEqualToString:name]) &#123;</span><br><span class=\"line\">\t        <span class=\"comment\">//doSomething...</span></span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过判断messageName和自己注册的是否一直，分别进行操作。</p>\n<p>messageBody可以是字符串，可以是字典格式。</p>\n<h4 id=\"OC给H5发消息（OC调用H5的方法或者回调）\"><a href=\"#OC给H5发消息（OC调用H5的方法或者回调）\" class=\"headerlink\" title=\"OC给H5发消息（OC调用H5的方法或者回调）\"></a>OC给H5发消息（OC调用H5的方法或者回调）</h4><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)evaluateJavaScript:(<span class=\"built_in\">NSString</span> *)javaScriptString completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"keyword\">id</span>, <span class=\"built_in\">NSError</span> *error))completionHandler;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *javaScriptString = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@&quot;OCCallJS(&#x27;%@&#x27;,&#x27;%@&#x27;)&quot;</span>,<span class=\"string\">@&quot;v1&quot;</span>,<span class=\"string\">@&quot;v2&quot;</span>];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>传递参数为字符串时，<code>OCCallJS(&#39;%@&#39;,&#39;%@&#39;)</code>,<code>%@</code>必须被引号引住</p>\n<p>在H5端，alert收到的参数是不生效的，不知道为什么😂</p>\n</blockquote>\n<h3 id=\"react-native-WebView和H5交互\"><a href=\"#react-native-WebView和H5交互\" class=\"headerlink\" title=\"react-native WebView和H5交互\"></a>react-native WebView和H5交互</h3><p>H5给RN发消息 </p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.postMessage(<span class=\"string\">&quot;jsCallRN&quot;</span>)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>RN获取H5发送的消息</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onMessage = <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> jsMessage = e.nativeEvent.data;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (jsMessage &amp;&amp; jsMessage == <span class=\"string\">&quot;jsCallRN&quot;</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>RN给H5发消息</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.webView.postMessage(<span class=\"string\">&quot;messageStr&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>H5获取RN发送的消息</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.document.addEventListener(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> messageStr = e.data;</span><br><span class=\"line\">    <span class=\"comment\">//doSomething</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意<br>调试时，H5页面报错，可能互相交互传递的消息收不到。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"OC-WKWebView和H5交互\"><a href=\"#OC-WKWebView和H5交互\" class=\"headerlink\" title=\"OC WKWebView和H5交互\"></a>OC WKWebView和H5交互</h3><h4 id=\"H5给OC发消息（H5调用OC的方法）\"><a href=\"#H5给OC发消息（H5调用OC的方法）\" class=\"headerlink\" title=\"H5给OC发消息（H5调用OC的方法）\"></a>H5给OC发消息（H5调用OC的方法）</h4><p>1、在OC端通过以下方法，注册要被调用的函数名</p>\n<pre><code> - (void)addScriptMessageHandler:(id&lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name; \n</code></pre>\n<blockquote>\n<p>Adding a script message handler with name name causes the JavaScript function window.webkit.messageHandlers.name.postMessage(messageBody) to be defined in all frames in all web views that use the user content controller.</p>\n</blockquote>\n<p>2、H5通过<code>window.webkit.messageHandlers.name.postMessage(messageBody)</code><br>来调用在OC端注册了的函数。</p>\n<pre><code>name即在OC端注册的函数名。\n\nmessageBody可作为参数传递给OC端。\n</code></pre>\n<blockquote>\n<p>当不需要传递参数时，应该<code>window.webkit.messageHandlers.name.postMessage(null);</code>,不写null时OC是收不到消息的</p>\n</blockquote>\n<p>3、OC通过以下代理监听H5发过来的消息</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)userContentController:(<span class=\"built_in\">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class=\"built_in\">WKScriptMessage</span> *)message&#123;</span><br><span class=\"line\">\t    <span class=\"built_in\">NSString</span> *messageName = message.name;</span><br><span class=\"line\">\t    <span class=\"keyword\">id</span> messageBody = message.body;</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> ([messageName isEqualToString:name]) &#123;</span><br><span class=\"line\">\t        <span class=\"comment\">//doSomething...</span></span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过判断messageName和自己注册的是否一直，分别进行操作。</p>\n<p>messageBody可以是字符串，可以是字典格式。</p>\n<h4 id=\"OC给H5发消息（OC调用H5的方法或者回调）\"><a href=\"#OC给H5发消息（OC调用H5的方法或者回调）\" class=\"headerlink\" title=\"OC给H5发消息（OC调用H5的方法或者回调）\"></a>OC给H5发消息（OC调用H5的方法或者回调）</h4><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)evaluateJavaScript:(<span class=\"built_in\">NSString</span> *)javaScriptString completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"keyword\">id</span>, <span class=\"built_in\">NSError</span> *error))completionHandler;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *javaScriptString = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@&quot;OCCallJS(&#x27;%@&#x27;,&#x27;%@&#x27;)&quot;</span>,<span class=\"string\">@&quot;v1&quot;</span>,<span class=\"string\">@&quot;v2&quot;</span>];</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>传递参数为字符串时，<code>OCCallJS(&#39;%@&#39;,&#39;%@&#39;)</code>,<code>%@</code>必须被引号引住</p>\n<p>在H5端，alert收到的参数是不生效的，不知道为什么😂</p>\n</blockquote>\n<h3 id=\"react-native-WebView和H5交互\"><a href=\"#react-native-WebView和H5交互\" class=\"headerlink\" title=\"react-native WebView和H5交互\"></a>react-native WebView和H5交互</h3><p>H5给RN发消息 </p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.postMessage(<span class=\"string\">&quot;jsCallRN&quot;</span>)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>RN获取H5发送的消息</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onMessage = <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> jsMessage = e.nativeEvent.data;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (jsMessage &amp;&amp; jsMessage == <span class=\"string\">&quot;jsCallRN&quot;</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//doSomething...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>RN给H5发消息</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.webView.postMessage(<span class=\"string\">&quot;messageStr&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>H5获取RN发送的消息</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.document.addEventListener(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> messageStr = e.data;</span><br><span class=\"line\">    <span class=\"comment\">//doSomething</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意<br>调试时，H5页面报错，可能互相交互传递的消息收不到。</p>\n</blockquote>\n"},{"title":"WebRTC的视频采集(一)","date":"2019-09-05T14:00:00.000Z","_content":"\n路径`Source/sdk/objc/components/capture`\n\n### RTCCameraVideoCapturer\n\n- [RTCVideoCapturer](#RTCVideoCapturer)\n- [RTCCameraVideoCapturer](#RTCCameraVideoCapturer)\n\n<p id='RTCVideoCapturer'></p>\n### `RTCVideoCapturer`\n\n`RTCVideoCapturer`继承自`NSObject`，主要提供了一个视频采集回调的代理方法。\n\n代理属性\n\n`@property(nonatomic, weak) id<RTCVideoCapturerDelegate> delegate;`\n\n初始化方法\n\n`- (instancetype)initWithDelegate:(id<RTCVideoCapturerDelegate>)delegate;`\n\n`<RTCVideoCapturerDelegate>`代理中有一个必须执行的方法\n\n`- (void)capturer:(RTCVideoCapturer *)capturer didCaptureVideoFrame:(RTCVideoFrame *)frame;`\n\n---\n<p id='RTCCameraVideoCapturer'></p>\n### `RTCCameraVideoCapturer `\n\n`RTCCameraVideoCapturer`继承自[RTCVideoCapturer](#RTCVideoCapturer)，我理解为摄像头视频采集，可能还会有录屏采集、文件采集等其他子类。\n\n只有一个只读属性`AVCaptureSession *captureSession`。\n\n`+ (NSArray<AVCaptureDevice *> *)captureDevices;`类方法，返回可用的设备列表。\n\n`+ (NSArray<AVCaptureDeviceFormat *> *)supportedFormatsForDevice:(AVCaptureDevice *)device;`根据设备返回支持的`AVCaptureDeviceFormat *`类型的列表\n\n`- (FourCharCode)preferredOutputPixelFormat;`返回本采集器最有效支持的输出像素格式。\n\n然后是两个开始采集和停止采集的方法，均为**异步**，稍后详细讨论这几个方法。\n\n>讨论1\n\n`@property`分别对应`@synthesize`和`@dynamic`。默认为`@synthesize`,为属性生成一个`_propertyName`的成员变量，并自动生成setter和getter方法。\n\n`@synthesize`为属性声明一个非`_propertyName`的成员变量，之后使用`_propertyName`会报错。\n\n`protocol`中声明的属性需要使用`@synthesize`，因为协议不会自动为属性声明setter和getter方法\n\n`@dynamic var`用于告诉编译器，我要自己声明setter和getter方法，不需要自动生成。\n\n```\n- (instancetype)initWithDelegate:(__weak id<RTCVideoCapturerDelegate>)delegate\n                  captureSession:(AVCaptureSession *)captureSession\n```\n\n最终的初始化方法，在此方法中添加了一些监听事件。\n\n - `UIDeviceOrientationDidChangeNotification`设备方向发生变化\n\n - `AVCaptureSessionWasInterruptedNotification`音视频采集已经（开始）被打断\n\n - `AVCaptureSessionInterruptionEndedNotification`音视频采集打断结束\n\n - `UIApplicationDidBecomeActiveNotification`应用变为激活状态\n\n - `AVCaptureSessionRuntimeErrorNotification`AVCaptureSession实例正在运行时发生未知错误\n\n - `AVCaptureSessionDidStartRunningNotification`AVCaptureSession实例成功开始运行\n\n - `AVCaptureSessionDidStopRunningNotification`AVCaptureSession实例停止运行\n\n\n```\n- (dispatch_queue_t)frameQueue {\n  if (!_frameQueue) {\n    _frameQueue =\n        dispatch_queue_create(\"org.webrtc.cameravideocapturer.video\", DISPATCH_QUEUE_SERIAL);\n    dispatch_set_target_queue(_frameQueue,\n                              dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0));\n  }\n  return _frameQueue;\n}\n```\n采集队列为串行队列，并且将优先级设置为高。\n\n`<AVCaptureVideoDataOutputSampleBufferDelegate>`代理\n\n\n```\n/**\n* 当AVCaptureVideoDataOutput的实例给出一个新的视频帧时会调用这个方法\n* output：对应的给出视频帧的AVCaptureVideoDataOutput的实例对象\n* sampleBuffer：一个CMSampleBuffer对象，包含视频帧数据和其他信息，比如编码和时间戳\n*/\n- (void)captureOutput:(AVCaptureOutput *)captureOutput\n    didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer\n           fromConnection:(AVCaptureConnection *)connection {\n           \n  //判断当前output是否与预期的_videoDataOutput一致\n  NSParameterAssert(captureOutput == _videoDataOutput);\n\n  //CMSampleBufferGetNumSamples获取媒体样本数，返回0即有错误\n  //CMSampleBufferIsValid判断sbuf是否可用\n  //CMSampleBufferDataIsReady判断sbuf的数据是否准备好\n  if (CMSampleBufferGetNumSamples(sampleBuffer) != 1 || !CMSampleBufferIsValid(sampleBuffer) ||\n      !CMSampleBufferDataIsReady(sampleBuffer)) {\n    return;\n  }\n\n  //将sampleBuffer转为imageBuffer，CVPixelBufferRef为CVImageBufferRef的别名\n  CVPixelBufferRef pixelBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);\n  if (pixelBuffer == nil) {\n    return;\n  }\n\n#if TARGET_OS_IPHONE \n  BOOL usingFrontCamera = NO;\n  // Check the image's EXIF for the camera the image came from as the image could have been\n  // delayed as we set alwaysDiscardsLateVideoFrames to NO.\n  //根据sampleBuffer获取照相机的方向，判断是否使用前置摄像头\n  AVCaptureDevicePosition cameraPosition =\n      [AVCaptureSession devicePositionForSampleBuffer:sampleBuffer];\n  if (cameraPosition != AVCaptureDevicePositionUnspecified) {\n    usingFrontCamera = AVCaptureDevicePositionFront == cameraPosition;\n  } else {\n    AVCaptureDeviceInput *deviceInput =\n        (AVCaptureDeviceInput *)((AVCaptureInputPort *)connection.inputPorts.firstObject).input;\n    usingFrontCamera = AVCaptureDevicePositionFront == deviceInput.device.position;\n  }\n  switch (_orientation) {\n    case UIDeviceOrientationPortrait:\n      _rotation = RTCVideoRotation_90;\n      break;\n    case UIDeviceOrientationPortraitUpsideDown:\n      _rotation = RTCVideoRotation_270;\n      break;\n    case UIDeviceOrientationLandscapeLeft:\n      _rotation = usingFrontCamera ? RTCVideoRotation_180 : RTCVideoRotation_0;\n      break;\n    case UIDeviceOrientationLandscapeRight:\n      _rotation = usingFrontCamera ? RTCVideoRotation_0 : RTCVideoRotation_180;\n      break;\n    case UIDeviceOrientationFaceUp:\n    case UIDeviceOrientationFaceDown:\n    case UIDeviceOrientationUnknown:\n      // Ignore.\n      break;\n  }\n#else\n  // No rotation on Mac.\n  _rotation = RTCVideoRotation_0;\n#endif\n  //将imageBuffer转为RTC的RTCCVPixelBuffer\n  RTCCVPixelBuffer *rtcPixelBuffer = [[RTCCVPixelBuffer alloc] initWithPixelBuffer:pixelBuffer];\n  \n  //获取时间戳\n  int64_t timeStampNs = CMTimeGetSeconds(CMSampleBufferGetPresentationTimeStamp(sampleBuffer)) *\n      kNanosecondsPerSecond;\n  \n  //根据rtcPixelBuffer、方向和时间戳构造RTCVideoFrame 并回调给代理\n  RTCVideoFrame *videoFrame = [[RTCVideoFrame alloc] initWithBuffer:rtcPixelBuffer\n                                                           rotation:_rotation\n                                                        timeStampNs:timeStampNs];\n  [self.delegate capturer:self didCaptureVideoFrame:videoFrame];\n}\n```\n\n```\n/**\n* 当有一帧被丢弃时调用\n* sampleBuffer：被丢弃帧的元数据，比如时常和时间戳，不包含实际的视频数据\n*/\n- (void)captureOutput:(AVCaptureOutput *)output didDropSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection;\n```","source":"_posts/2019-09-05-webrtc-视频采集.md","raw":"---\ntitle:      \"WebRTC的视频采集(一)\" \ndate:       2019-09-05 22:00:00\ntags:\n    - WebRTC学习\ncategories:\n    - WebRTC学习\n---\n\n路径`Source/sdk/objc/components/capture`\n\n### RTCCameraVideoCapturer\n\n- [RTCVideoCapturer](#RTCVideoCapturer)\n- [RTCCameraVideoCapturer](#RTCCameraVideoCapturer)\n\n<p id='RTCVideoCapturer'></p>\n### `RTCVideoCapturer`\n\n`RTCVideoCapturer`继承自`NSObject`，主要提供了一个视频采集回调的代理方法。\n\n代理属性\n\n`@property(nonatomic, weak) id<RTCVideoCapturerDelegate> delegate;`\n\n初始化方法\n\n`- (instancetype)initWithDelegate:(id<RTCVideoCapturerDelegate>)delegate;`\n\n`<RTCVideoCapturerDelegate>`代理中有一个必须执行的方法\n\n`- (void)capturer:(RTCVideoCapturer *)capturer didCaptureVideoFrame:(RTCVideoFrame *)frame;`\n\n---\n<p id='RTCCameraVideoCapturer'></p>\n### `RTCCameraVideoCapturer `\n\n`RTCCameraVideoCapturer`继承自[RTCVideoCapturer](#RTCVideoCapturer)，我理解为摄像头视频采集，可能还会有录屏采集、文件采集等其他子类。\n\n只有一个只读属性`AVCaptureSession *captureSession`。\n\n`+ (NSArray<AVCaptureDevice *> *)captureDevices;`类方法，返回可用的设备列表。\n\n`+ (NSArray<AVCaptureDeviceFormat *> *)supportedFormatsForDevice:(AVCaptureDevice *)device;`根据设备返回支持的`AVCaptureDeviceFormat *`类型的列表\n\n`- (FourCharCode)preferredOutputPixelFormat;`返回本采集器最有效支持的输出像素格式。\n\n然后是两个开始采集和停止采集的方法，均为**异步**，稍后详细讨论这几个方法。\n\n>讨论1\n\n`@property`分别对应`@synthesize`和`@dynamic`。默认为`@synthesize`,为属性生成一个`_propertyName`的成员变量，并自动生成setter和getter方法。\n\n`@synthesize`为属性声明一个非`_propertyName`的成员变量，之后使用`_propertyName`会报错。\n\n`protocol`中声明的属性需要使用`@synthesize`，因为协议不会自动为属性声明setter和getter方法\n\n`@dynamic var`用于告诉编译器，我要自己声明setter和getter方法，不需要自动生成。\n\n```\n- (instancetype)initWithDelegate:(__weak id<RTCVideoCapturerDelegate>)delegate\n                  captureSession:(AVCaptureSession *)captureSession\n```\n\n最终的初始化方法，在此方法中添加了一些监听事件。\n\n - `UIDeviceOrientationDidChangeNotification`设备方向发生变化\n\n - `AVCaptureSessionWasInterruptedNotification`音视频采集已经（开始）被打断\n\n - `AVCaptureSessionInterruptionEndedNotification`音视频采集打断结束\n\n - `UIApplicationDidBecomeActiveNotification`应用变为激活状态\n\n - `AVCaptureSessionRuntimeErrorNotification`AVCaptureSession实例正在运行时发生未知错误\n\n - `AVCaptureSessionDidStartRunningNotification`AVCaptureSession实例成功开始运行\n\n - `AVCaptureSessionDidStopRunningNotification`AVCaptureSession实例停止运行\n\n\n```\n- (dispatch_queue_t)frameQueue {\n  if (!_frameQueue) {\n    _frameQueue =\n        dispatch_queue_create(\"org.webrtc.cameravideocapturer.video\", DISPATCH_QUEUE_SERIAL);\n    dispatch_set_target_queue(_frameQueue,\n                              dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0));\n  }\n  return _frameQueue;\n}\n```\n采集队列为串行队列，并且将优先级设置为高。\n\n`<AVCaptureVideoDataOutputSampleBufferDelegate>`代理\n\n\n```\n/**\n* 当AVCaptureVideoDataOutput的实例给出一个新的视频帧时会调用这个方法\n* output：对应的给出视频帧的AVCaptureVideoDataOutput的实例对象\n* sampleBuffer：一个CMSampleBuffer对象，包含视频帧数据和其他信息，比如编码和时间戳\n*/\n- (void)captureOutput:(AVCaptureOutput *)captureOutput\n    didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer\n           fromConnection:(AVCaptureConnection *)connection {\n           \n  //判断当前output是否与预期的_videoDataOutput一致\n  NSParameterAssert(captureOutput == _videoDataOutput);\n\n  //CMSampleBufferGetNumSamples获取媒体样本数，返回0即有错误\n  //CMSampleBufferIsValid判断sbuf是否可用\n  //CMSampleBufferDataIsReady判断sbuf的数据是否准备好\n  if (CMSampleBufferGetNumSamples(sampleBuffer) != 1 || !CMSampleBufferIsValid(sampleBuffer) ||\n      !CMSampleBufferDataIsReady(sampleBuffer)) {\n    return;\n  }\n\n  //将sampleBuffer转为imageBuffer，CVPixelBufferRef为CVImageBufferRef的别名\n  CVPixelBufferRef pixelBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);\n  if (pixelBuffer == nil) {\n    return;\n  }\n\n#if TARGET_OS_IPHONE \n  BOOL usingFrontCamera = NO;\n  // Check the image's EXIF for the camera the image came from as the image could have been\n  // delayed as we set alwaysDiscardsLateVideoFrames to NO.\n  //根据sampleBuffer获取照相机的方向，判断是否使用前置摄像头\n  AVCaptureDevicePosition cameraPosition =\n      [AVCaptureSession devicePositionForSampleBuffer:sampleBuffer];\n  if (cameraPosition != AVCaptureDevicePositionUnspecified) {\n    usingFrontCamera = AVCaptureDevicePositionFront == cameraPosition;\n  } else {\n    AVCaptureDeviceInput *deviceInput =\n        (AVCaptureDeviceInput *)((AVCaptureInputPort *)connection.inputPorts.firstObject).input;\n    usingFrontCamera = AVCaptureDevicePositionFront == deviceInput.device.position;\n  }\n  switch (_orientation) {\n    case UIDeviceOrientationPortrait:\n      _rotation = RTCVideoRotation_90;\n      break;\n    case UIDeviceOrientationPortraitUpsideDown:\n      _rotation = RTCVideoRotation_270;\n      break;\n    case UIDeviceOrientationLandscapeLeft:\n      _rotation = usingFrontCamera ? RTCVideoRotation_180 : RTCVideoRotation_0;\n      break;\n    case UIDeviceOrientationLandscapeRight:\n      _rotation = usingFrontCamera ? RTCVideoRotation_0 : RTCVideoRotation_180;\n      break;\n    case UIDeviceOrientationFaceUp:\n    case UIDeviceOrientationFaceDown:\n    case UIDeviceOrientationUnknown:\n      // Ignore.\n      break;\n  }\n#else\n  // No rotation on Mac.\n  _rotation = RTCVideoRotation_0;\n#endif\n  //将imageBuffer转为RTC的RTCCVPixelBuffer\n  RTCCVPixelBuffer *rtcPixelBuffer = [[RTCCVPixelBuffer alloc] initWithPixelBuffer:pixelBuffer];\n  \n  //获取时间戳\n  int64_t timeStampNs = CMTimeGetSeconds(CMSampleBufferGetPresentationTimeStamp(sampleBuffer)) *\n      kNanosecondsPerSecond;\n  \n  //根据rtcPixelBuffer、方向和时间戳构造RTCVideoFrame 并回调给代理\n  RTCVideoFrame *videoFrame = [[RTCVideoFrame alloc] initWithBuffer:rtcPixelBuffer\n                                                           rotation:_rotation\n                                                        timeStampNs:timeStampNs];\n  [self.delegate capturer:self didCaptureVideoFrame:videoFrame];\n}\n```\n\n```\n/**\n* 当有一帧被丢弃时调用\n* sampleBuffer：被丢弃帧的元数据，比如时常和时间戳，不包含实际的视频数据\n*/\n- (void)captureOutput:(AVCaptureOutput *)output didDropSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection;\n```","slug":"2019-09-05-webrtc-视频采集","published":1,"updated":"2021-06-19T03:46:24.083Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbp70004bjrj2zdr9bi5","content":"<p>路径<code>Source/sdk/objc/components/capture</code></p>\n<h3 id=\"RTCCameraVideoCapturer\"><a href=\"#RTCCameraVideoCapturer\" class=\"headerlink\" title=\"RTCCameraVideoCapturer\"></a>RTCCameraVideoCapturer</h3><ul>\n<li><a href=\"#RTCVideoCapturer\">RTCVideoCapturer</a></li>\n<li><a href=\"#RTCCameraVideoCapturer\">RTCCameraVideoCapturer</a></li>\n</ul>\n<p id='RTCVideoCapturer'></p>\n### `RTCVideoCapturer`\n\n<p><code>RTCVideoCapturer</code>继承自<code>NSObject</code>，主要提供了一个视频采集回调的代理方法。</p>\n<p>代理属性</p>\n<p><code>@property(nonatomic, weak) id&lt;RTCVideoCapturerDelegate&gt; delegate;</code></p>\n<p>初始化方法</p>\n<p><code>- (instancetype)initWithDelegate:(id&lt;RTCVideoCapturerDelegate&gt;)delegate;</code></p>\n<p><code>&lt;RTCVideoCapturerDelegate&gt;</code>代理中有一个必须执行的方法</p>\n<p><code>- (void)capturer:(RTCVideoCapturer *)capturer didCaptureVideoFrame:(RTCVideoFrame *)frame;</code></p>\n<hr>\n<p id='RTCCameraVideoCapturer'></p>\n### `RTCCameraVideoCapturer `\n\n<p><code>RTCCameraVideoCapturer</code>继承自<a href=\"#RTCVideoCapturer\">RTCVideoCapturer</a>，我理解为摄像头视频采集，可能还会有录屏采集、文件采集等其他子类。</p>\n<p>只有一个只读属性<code>AVCaptureSession *captureSession</code>。</p>\n<p><code>+ (NSArray&lt;AVCaptureDevice *&gt; *)captureDevices;</code>类方法，返回可用的设备列表。</p>\n<p><code>+ (NSArray&lt;AVCaptureDeviceFormat *&gt; *)supportedFormatsForDevice:(AVCaptureDevice *)device;</code>根据设备返回支持的<code>AVCaptureDeviceFormat *</code>类型的列表</p>\n<p><code>- (FourCharCode)preferredOutputPixelFormat;</code>返回本采集器最有效支持的输出像素格式。</p>\n<p>然后是两个开始采集和停止采集的方法，均为<strong>异步</strong>，稍后详细讨论这几个方法。</p>\n<blockquote>\n<p>讨论1</p>\n</blockquote>\n<p><code>@property</code>分别对应<code>@synthesize</code>和<code>@dynamic</code>。默认为<code>@synthesize</code>,为属性生成一个<code>_propertyName</code>的成员变量，并自动生成setter和getter方法。</p>\n<p><code>@synthesize</code>为属性声明一个非<code>_propertyName</code>的成员变量，之后使用<code>_propertyName</code>会报错。</p>\n<p><code>protocol</code>中声明的属性需要使用<code>@synthesize</code>，因为协议不会自动为属性声明setter和getter方法</p>\n<p><code>@dynamic var</code>用于告诉编译器，我要自己声明setter和getter方法，不需要自动生成。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instance<span class=\"keyword\">type</span>)initWithDelegate:(__weak id&lt;<span class=\"type\">RTCVideoCapturerDelegate</span>&gt;)delegate</span><br><span class=\"line\">                  captureSession:(<span class=\"type\">AVCaptureSession</span> *)captureSession</span><br></pre></td></tr></table></figure>\n\n<p>最终的初始化方法，在此方法中添加了一些监听事件。</p>\n<ul>\n<li><p><code>UIDeviceOrientationDidChangeNotification</code>设备方向发生变化</p>\n</li>\n<li><p><code>AVCaptureSessionWasInterruptedNotification</code>音视频采集已经（开始）被打断</p>\n</li>\n<li><p><code>AVCaptureSessionInterruptionEndedNotification</code>音视频采集打断结束</p>\n</li>\n<li><p><code>UIApplicationDidBecomeActiveNotification</code>应用变为激活状态</p>\n</li>\n<li><p><code>AVCaptureSessionRuntimeErrorNotification</code>AVCaptureSession实例正在运行时发生未知错误</p>\n</li>\n<li><p><code>AVCaptureSessionDidStartRunningNotification</code>AVCaptureSession实例成功开始运行</p>\n</li>\n<li><p><code>AVCaptureSessionDidStopRunningNotification</code>AVCaptureSession实例停止运行</p>\n</li>\n</ul>\n<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- <span class=\"params\">(dispatch_queue_t)</span>frameQueue &#123;</span><br><span class=\"line\">  if <span class=\"params\">(!_frameQueue)</span> &#123;</span><br><span class=\"line\">    _frameQueue =</span><br><span class=\"line\">        dispatch_queue_create<span class=\"params\">(<span class=\"string\">&quot;org.webrtc.cameravideocapturer.video&quot;</span>, DISPATCH_QUEUE_SERIAL)</span>;</span><br><span class=\"line\">    dispatch_set_target_queue<span class=\"params\">(_frameQueue,</span></span><br><span class=\"line\"><span class=\"params\">                              dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class=\"number\">0</span>))</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return _frameQueue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>采集队列为串行队列，并且将优先级设置为高。</p>\n<p><code>&lt;AVCaptureVideoDataOutputSampleBufferDelegate&gt;</code>代理</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 当AVCaptureVideoDataOutput的实例给出一个新的视频帧时会调用这个方法</span></span><br><span class=\"line\"><span class=\"comment\">* output：对应的给出视频帧的AVCaptureVideoDataOutput的实例对象</span></span><br><span class=\"line\"><span class=\"comment\">* sampleBuffer：一个CMSampleBuffer对象，包含视频帧数据和其他信息，比如编码和时间戳</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)captureOutput:(<span class=\"built_in\">AVCaptureOutput</span> *)captureOutput</span><br><span class=\"line\">    didOutputSampleBuffer:(<span class=\"built_in\">CMSampleBufferRef</span>)sampleBuffer</span><br><span class=\"line\">           fromConnection:(<span class=\"built_in\">AVCaptureConnection</span> *)connection &#123;</span><br><span class=\"line\">           </span><br><span class=\"line\">  <span class=\"comment\">//判断当前output是否与预期的_videoDataOutput一致</span></span><br><span class=\"line\">  <span class=\"built_in\">NSParameterAssert</span>(captureOutput == _videoDataOutput);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//CMSampleBufferGetNumSamples获取媒体样本数，返回0即有错误</span></span><br><span class=\"line\">  <span class=\"comment\">//CMSampleBufferIsValid判断sbuf是否可用</span></span><br><span class=\"line\">  <span class=\"comment\">//CMSampleBufferDataIsReady判断sbuf的数据是否准备好</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">CMSampleBufferGetNumSamples</span>(sampleBuffer) != <span class=\"number\">1</span> || !<span class=\"built_in\">CMSampleBufferIsValid</span>(sampleBuffer) ||</span><br><span class=\"line\">      !<span class=\"built_in\">CMSampleBufferDataIsReady</span>(sampleBuffer)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//将sampleBuffer转为imageBuffer，CVPixelBufferRef为CVImageBufferRef的别名</span></span><br><span class=\"line\">  CVPixelBufferRef pixelBuffer = <span class=\"built_in\">CMSampleBufferGetImageBuffer</span>(sampleBuffer);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pixelBuffer == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> TARGET_OS_IPHONE </span></span><br><span class=\"line\">  <span class=\"built_in\">BOOL</span> usingFrontCamera = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">  <span class=\"comment\">// Check the image&#x27;s EXIF for the camera the image came from as the image could have been</span></span><br><span class=\"line\">  <span class=\"comment\">// delayed as we set alwaysDiscardsLateVideoFrames to NO.</span></span><br><span class=\"line\">  <span class=\"comment\">//根据sampleBuffer获取照相机的方向，判断是否使用前置摄像头</span></span><br><span class=\"line\">  <span class=\"built_in\">AVCaptureDevicePosition</span> cameraPosition =</span><br><span class=\"line\">      [<span class=\"built_in\">AVCaptureSession</span> devicePositionForSampleBuffer:sampleBuffer];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cameraPosition != <span class=\"built_in\">AVCaptureDevicePositionUnspecified</span>) &#123;</span><br><span class=\"line\">    usingFrontCamera = <span class=\"built_in\">AVCaptureDevicePositionFront</span> == cameraPosition;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">AVCaptureDeviceInput</span> *deviceInput =</span><br><span class=\"line\">        (<span class=\"built_in\">AVCaptureDeviceInput</span> *)((<span class=\"built_in\">AVCaptureInputPort</span> *)connection.inputPorts.firstObject).input;</span><br><span class=\"line\">    usingFrontCamera = <span class=\"built_in\">AVCaptureDevicePositionFront</span> == deviceInput.device.position;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (_orientation) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"built_in\">UIDeviceOrientationPortrait</span>:</span><br><span class=\"line\">      _rotation = RTCVideoRotation_90;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"built_in\">UIDeviceOrientationPortraitUpsideDown</span>:</span><br><span class=\"line\">      _rotation = RTCVideoRotation_270;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"built_in\">UIDeviceOrientationLandscapeLeft</span>:</span><br><span class=\"line\">      _rotation = usingFrontCamera ? RTCVideoRotation_180 : RTCVideoRotation_0;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"built_in\">UIDeviceOrientationLandscapeRight</span>:</span><br><span class=\"line\">      _rotation = usingFrontCamera ? RTCVideoRotation_0 : RTCVideoRotation_180;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"built_in\">UIDeviceOrientationFaceUp</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"built_in\">UIDeviceOrientationFaceDown</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"built_in\">UIDeviceOrientationUnknown</span>:</span><br><span class=\"line\">      <span class=\"comment\">// Ignore.</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">  <span class=\"comment\">// No rotation on Mac.</span></span><br><span class=\"line\">  _rotation = RTCVideoRotation_0;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">  <span class=\"comment\">//将imageBuffer转为RTC的RTCCVPixelBuffer</span></span><br><span class=\"line\">  RTCCVPixelBuffer *rtcPixelBuffer = [[RTCCVPixelBuffer alloc] initWithPixelBuffer:pixelBuffer];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//获取时间戳</span></span><br><span class=\"line\">  int64_t timeStampNs = <span class=\"built_in\">CMTimeGetSeconds</span>(<span class=\"built_in\">CMSampleBufferGetPresentationTimeStamp</span>(sampleBuffer)) *</span><br><span class=\"line\">      kNanosecondsPerSecond;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//根据rtcPixelBuffer、方向和时间戳构造RTCVideoFrame 并回调给代理</span></span><br><span class=\"line\">  RTCVideoFrame *videoFrame = [[RTCVideoFrame alloc] initWithBuffer:rtcPixelBuffer</span><br><span class=\"line\">                                                           rotation:_rotation</span><br><span class=\"line\">                                                        timeStampNs:timeStampNs];</span><br><span class=\"line\">  [<span class=\"keyword\">self</span>.delegate capturer:<span class=\"keyword\">self</span> didCaptureVideoFrame:videoFrame];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 当有一帧被丢弃时调用</span></span><br><span class=\"line\"><span class=\"comment\">* sampleBuffer：被丢弃帧的元数据，比如时常和时间戳，不包含实际的视频数据</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)<span class=\"attr\">captureOutput:</span>(AVCaptureOutput *)output <span class=\"attr\">didDropSampleBuffer:</span>(CMSampleBufferRef)sampleBuffer <span class=\"attr\">fromConnection:</span>(AVCaptureConnection *)connection;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>路径<code>Source/sdk/objc/components/capture</code></p>\n<h3 id=\"RTCCameraVideoCapturer\"><a href=\"#RTCCameraVideoCapturer\" class=\"headerlink\" title=\"RTCCameraVideoCapturer\"></a>RTCCameraVideoCapturer</h3><ul>\n<li><a href=\"#RTCVideoCapturer\">RTCVideoCapturer</a></li>\n<li><a href=\"#RTCCameraVideoCapturer\">RTCCameraVideoCapturer</a></li>\n</ul>\n<p id='RTCVideoCapturer'></p>\n### `RTCVideoCapturer`\n\n<p><code>RTCVideoCapturer</code>继承自<code>NSObject</code>，主要提供了一个视频采集回调的代理方法。</p>\n<p>代理属性</p>\n<p><code>@property(nonatomic, weak) id&lt;RTCVideoCapturerDelegate&gt; delegate;</code></p>\n<p>初始化方法</p>\n<p><code>- (instancetype)initWithDelegate:(id&lt;RTCVideoCapturerDelegate&gt;)delegate;</code></p>\n<p><code>&lt;RTCVideoCapturerDelegate&gt;</code>代理中有一个必须执行的方法</p>\n<p><code>- (void)capturer:(RTCVideoCapturer *)capturer didCaptureVideoFrame:(RTCVideoFrame *)frame;</code></p>\n<hr>\n<p id='RTCCameraVideoCapturer'></p>\n### `RTCCameraVideoCapturer `\n\n<p><code>RTCCameraVideoCapturer</code>继承自<a href=\"#RTCVideoCapturer\">RTCVideoCapturer</a>，我理解为摄像头视频采集，可能还会有录屏采集、文件采集等其他子类。</p>\n<p>只有一个只读属性<code>AVCaptureSession *captureSession</code>。</p>\n<p><code>+ (NSArray&lt;AVCaptureDevice *&gt; *)captureDevices;</code>类方法，返回可用的设备列表。</p>\n<p><code>+ (NSArray&lt;AVCaptureDeviceFormat *&gt; *)supportedFormatsForDevice:(AVCaptureDevice *)device;</code>根据设备返回支持的<code>AVCaptureDeviceFormat *</code>类型的列表</p>\n<p><code>- (FourCharCode)preferredOutputPixelFormat;</code>返回本采集器最有效支持的输出像素格式。</p>\n<p>然后是两个开始采集和停止采集的方法，均为<strong>异步</strong>，稍后详细讨论这几个方法。</p>\n<blockquote>\n<p>讨论1</p>\n</blockquote>\n<p><code>@property</code>分别对应<code>@synthesize</code>和<code>@dynamic</code>。默认为<code>@synthesize</code>,为属性生成一个<code>_propertyName</code>的成员变量，并自动生成setter和getter方法。</p>\n<p><code>@synthesize</code>为属性声明一个非<code>_propertyName</code>的成员变量，之后使用<code>_propertyName</code>会报错。</p>\n<p><code>protocol</code>中声明的属性需要使用<code>@synthesize</code>，因为协议不会自动为属性声明setter和getter方法</p>\n<p><code>@dynamic var</code>用于告诉编译器，我要自己声明setter和getter方法，不需要自动生成。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instance<span class=\"keyword\">type</span>)initWithDelegate:(__weak id&lt;<span class=\"type\">RTCVideoCapturerDelegate</span>&gt;)delegate</span><br><span class=\"line\">                  captureSession:(<span class=\"type\">AVCaptureSession</span> *)captureSession</span><br></pre></td></tr></table></figure>\n\n<p>最终的初始化方法，在此方法中添加了一些监听事件。</p>\n<ul>\n<li><p><code>UIDeviceOrientationDidChangeNotification</code>设备方向发生变化</p>\n</li>\n<li><p><code>AVCaptureSessionWasInterruptedNotification</code>音视频采集已经（开始）被打断</p>\n</li>\n<li><p><code>AVCaptureSessionInterruptionEndedNotification</code>音视频采集打断结束</p>\n</li>\n<li><p><code>UIApplicationDidBecomeActiveNotification</code>应用变为激活状态</p>\n</li>\n<li><p><code>AVCaptureSessionRuntimeErrorNotification</code>AVCaptureSession实例正在运行时发生未知错误</p>\n</li>\n<li><p><code>AVCaptureSessionDidStartRunningNotification</code>AVCaptureSession实例成功开始运行</p>\n</li>\n<li><p><code>AVCaptureSessionDidStopRunningNotification</code>AVCaptureSession实例停止运行</p>\n</li>\n</ul>\n<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- <span class=\"params\">(dispatch_queue_t)</span>frameQueue &#123;</span><br><span class=\"line\">  if <span class=\"params\">(!_frameQueue)</span> &#123;</span><br><span class=\"line\">    _frameQueue =</span><br><span class=\"line\">        dispatch_queue_create<span class=\"params\">(<span class=\"string\">&quot;org.webrtc.cameravideocapturer.video&quot;</span>, DISPATCH_QUEUE_SERIAL)</span>;</span><br><span class=\"line\">    dispatch_set_target_queue<span class=\"params\">(_frameQueue,</span></span><br><span class=\"line\"><span class=\"params\">                              dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class=\"number\">0</span>))</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return _frameQueue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>采集队列为串行队列，并且将优先级设置为高。</p>\n<p><code>&lt;AVCaptureVideoDataOutputSampleBufferDelegate&gt;</code>代理</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 当AVCaptureVideoDataOutput的实例给出一个新的视频帧时会调用这个方法</span></span><br><span class=\"line\"><span class=\"comment\">* output：对应的给出视频帧的AVCaptureVideoDataOutput的实例对象</span></span><br><span class=\"line\"><span class=\"comment\">* sampleBuffer：一个CMSampleBuffer对象，包含视频帧数据和其他信息，比如编码和时间戳</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)captureOutput:(<span class=\"built_in\">AVCaptureOutput</span> *)captureOutput</span><br><span class=\"line\">    didOutputSampleBuffer:(<span class=\"built_in\">CMSampleBufferRef</span>)sampleBuffer</span><br><span class=\"line\">           fromConnection:(<span class=\"built_in\">AVCaptureConnection</span> *)connection &#123;</span><br><span class=\"line\">           </span><br><span class=\"line\">  <span class=\"comment\">//判断当前output是否与预期的_videoDataOutput一致</span></span><br><span class=\"line\">  <span class=\"built_in\">NSParameterAssert</span>(captureOutput == _videoDataOutput);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//CMSampleBufferGetNumSamples获取媒体样本数，返回0即有错误</span></span><br><span class=\"line\">  <span class=\"comment\">//CMSampleBufferIsValid判断sbuf是否可用</span></span><br><span class=\"line\">  <span class=\"comment\">//CMSampleBufferDataIsReady判断sbuf的数据是否准备好</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">CMSampleBufferGetNumSamples</span>(sampleBuffer) != <span class=\"number\">1</span> || !<span class=\"built_in\">CMSampleBufferIsValid</span>(sampleBuffer) ||</span><br><span class=\"line\">      !<span class=\"built_in\">CMSampleBufferDataIsReady</span>(sampleBuffer)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//将sampleBuffer转为imageBuffer，CVPixelBufferRef为CVImageBufferRef的别名</span></span><br><span class=\"line\">  CVPixelBufferRef pixelBuffer = <span class=\"built_in\">CMSampleBufferGetImageBuffer</span>(sampleBuffer);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pixelBuffer == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> TARGET_OS_IPHONE </span></span><br><span class=\"line\">  <span class=\"built_in\">BOOL</span> usingFrontCamera = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">  <span class=\"comment\">// Check the image&#x27;s EXIF for the camera the image came from as the image could have been</span></span><br><span class=\"line\">  <span class=\"comment\">// delayed as we set alwaysDiscardsLateVideoFrames to NO.</span></span><br><span class=\"line\">  <span class=\"comment\">//根据sampleBuffer获取照相机的方向，判断是否使用前置摄像头</span></span><br><span class=\"line\">  <span class=\"built_in\">AVCaptureDevicePosition</span> cameraPosition =</span><br><span class=\"line\">      [<span class=\"built_in\">AVCaptureSession</span> devicePositionForSampleBuffer:sampleBuffer];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cameraPosition != <span class=\"built_in\">AVCaptureDevicePositionUnspecified</span>) &#123;</span><br><span class=\"line\">    usingFrontCamera = <span class=\"built_in\">AVCaptureDevicePositionFront</span> == cameraPosition;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">AVCaptureDeviceInput</span> *deviceInput =</span><br><span class=\"line\">        (<span class=\"built_in\">AVCaptureDeviceInput</span> *)((<span class=\"built_in\">AVCaptureInputPort</span> *)connection.inputPorts.firstObject).input;</span><br><span class=\"line\">    usingFrontCamera = <span class=\"built_in\">AVCaptureDevicePositionFront</span> == deviceInput.device.position;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (_orientation) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"built_in\">UIDeviceOrientationPortrait</span>:</span><br><span class=\"line\">      _rotation = RTCVideoRotation_90;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"built_in\">UIDeviceOrientationPortraitUpsideDown</span>:</span><br><span class=\"line\">      _rotation = RTCVideoRotation_270;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"built_in\">UIDeviceOrientationLandscapeLeft</span>:</span><br><span class=\"line\">      _rotation = usingFrontCamera ? RTCVideoRotation_180 : RTCVideoRotation_0;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"built_in\">UIDeviceOrientationLandscapeRight</span>:</span><br><span class=\"line\">      _rotation = usingFrontCamera ? RTCVideoRotation_0 : RTCVideoRotation_180;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"built_in\">UIDeviceOrientationFaceUp</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"built_in\">UIDeviceOrientationFaceDown</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"built_in\">UIDeviceOrientationUnknown</span>:</span><br><span class=\"line\">      <span class=\"comment\">// Ignore.</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">  <span class=\"comment\">// No rotation on Mac.</span></span><br><span class=\"line\">  _rotation = RTCVideoRotation_0;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">  <span class=\"comment\">//将imageBuffer转为RTC的RTCCVPixelBuffer</span></span><br><span class=\"line\">  RTCCVPixelBuffer *rtcPixelBuffer = [[RTCCVPixelBuffer alloc] initWithPixelBuffer:pixelBuffer];</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//获取时间戳</span></span><br><span class=\"line\">  int64_t timeStampNs = <span class=\"built_in\">CMTimeGetSeconds</span>(<span class=\"built_in\">CMSampleBufferGetPresentationTimeStamp</span>(sampleBuffer)) *</span><br><span class=\"line\">      kNanosecondsPerSecond;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//根据rtcPixelBuffer、方向和时间戳构造RTCVideoFrame 并回调给代理</span></span><br><span class=\"line\">  RTCVideoFrame *videoFrame = [[RTCVideoFrame alloc] initWithBuffer:rtcPixelBuffer</span><br><span class=\"line\">                                                           rotation:_rotation</span><br><span class=\"line\">                                                        timeStampNs:timeStampNs];</span><br><span class=\"line\">  [<span class=\"keyword\">self</span>.delegate capturer:<span class=\"keyword\">self</span> didCaptureVideoFrame:videoFrame];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 当有一帧被丢弃时调用</span></span><br><span class=\"line\"><span class=\"comment\">* sampleBuffer：被丢弃帧的元数据，比如时常和时间戳，不包含实际的视频数据</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)<span class=\"attr\">captureOutput:</span>(AVCaptureOutput *)output <span class=\"attr\">didDropSampleBuffer:</span>(CMSampleBufferRef)sampleBuffer <span class=\"attr\">fromConnection:</span>(AVCaptureConnection *)connection;</span><br></pre></td></tr></table></figure>"},{"title":"React Native是如何工作的","date":"2020-03-07T14:00:00.000Z","_content":"\n## React Native是如何工作的？\n\n### React Native App中的线程\n\n在React Native App中有4个线程：\n\n    1）UI线程：即主线程。它用于Android和iOS原生UI的渲染。比如在安卓上，关于UI的测量/布局/绘制就是在UI线程上。\n\n    2）JS线程：JS线程或JavaScript线程是逻辑将会在其中运行。比如应用程序的JavaScript代码执行、API调用、触摸事件处理都是在这个线程中运行的。当JS线程中的每个事件循环结束时，对于UI的更新将被分批发送到native端进行更新。\n\n    为了拥有更好的性能，JS线程应该能够在下一帧渲染前将更新内容传递给UI线程。比如iOS每秒钟渲染60帧，每一帧间隔为16.67ms。如果在JS线程中的事件循环内做了比较复杂的操作花费大于16.67ms，UI将会卡顿。\n\n    有一个例外是，如果UI本来就在native端发生变化，则不会由于JS端阻塞而卡顿。\n\n    3）Native Modules线程：有时候App需要访问native端的API，则会在Native Module线程中调用。\n\n    4）渲染线程：仅在Android L (5.0)时，渲染线程用于生成OpenGL命令去绘制UI。\n\n### 在程序过程中React Native是如何工作的\n\n    1）在程序启动时，在主线程中开始解析并加载`JS Bundle`\n\n    2) 当JavaScript代码加载成功之后，主线程把JavaScript代码送到另一个JS线程，这样当JS代码在做一些繁重的计算任务导致阻塞一段时间也不会影响UI线程。\n\n    3）当React开始渲染，Reconciler开始计算差异，同时会生成一个新的虚拟DOM(布局)，它把这些DOM上的变化传递给另一个Shadow Thread（为什么叫做“Shadow”，因为他会生成“Shadow Node”）。\n\n    4）Shadow Thread计算布局然后把布局参数或布局对象传递给主线程。\n\n    5）由于只有主线程才能在屏幕上进行渲染，所以Shadow Thread把生成好的布局传递给主线程，然后渲染UI。\n\n### React Native的组成\n\n通常我们把React Native分成3部分：\n\n    1）React Native - 原生端即Native\n\n    2）React Native - JS端\n\n    3）React Native - 桥即bridge\n\n翻译自[How React Native works?](https://www.geeksforgeeks.org/react-native-works/)\n","source":"_posts/2020-03-07-React Native是如何工作的.markdown","raw":"---\ntitle:      \"React Native是如何工作的\" \ndate:       2020-03-07 22:00:00\ntags:\n    - React Native\ncategories:\n    - React Native\n---\n\n## React Native是如何工作的？\n\n### React Native App中的线程\n\n在React Native App中有4个线程：\n\n    1）UI线程：即主线程。它用于Android和iOS原生UI的渲染。比如在安卓上，关于UI的测量/布局/绘制就是在UI线程上。\n\n    2）JS线程：JS线程或JavaScript线程是逻辑将会在其中运行。比如应用程序的JavaScript代码执行、API调用、触摸事件处理都是在这个线程中运行的。当JS线程中的每个事件循环结束时，对于UI的更新将被分批发送到native端进行更新。\n\n    为了拥有更好的性能，JS线程应该能够在下一帧渲染前将更新内容传递给UI线程。比如iOS每秒钟渲染60帧，每一帧间隔为16.67ms。如果在JS线程中的事件循环内做了比较复杂的操作花费大于16.67ms，UI将会卡顿。\n\n    有一个例外是，如果UI本来就在native端发生变化，则不会由于JS端阻塞而卡顿。\n\n    3）Native Modules线程：有时候App需要访问native端的API，则会在Native Module线程中调用。\n\n    4）渲染线程：仅在Android L (5.0)时，渲染线程用于生成OpenGL命令去绘制UI。\n\n### 在程序过程中React Native是如何工作的\n\n    1）在程序启动时，在主线程中开始解析并加载`JS Bundle`\n\n    2) 当JavaScript代码加载成功之后，主线程把JavaScript代码送到另一个JS线程，这样当JS代码在做一些繁重的计算任务导致阻塞一段时间也不会影响UI线程。\n\n    3）当React开始渲染，Reconciler开始计算差异，同时会生成一个新的虚拟DOM(布局)，它把这些DOM上的变化传递给另一个Shadow Thread（为什么叫做“Shadow”，因为他会生成“Shadow Node”）。\n\n    4）Shadow Thread计算布局然后把布局参数或布局对象传递给主线程。\n\n    5）由于只有主线程才能在屏幕上进行渲染，所以Shadow Thread把生成好的布局传递给主线程，然后渲染UI。\n\n### React Native的组成\n\n通常我们把React Native分成3部分：\n\n    1）React Native - 原生端即Native\n\n    2）React Native - JS端\n\n    3）React Native - 桥即bridge\n\n翻译自[How React Native works?](https://www.geeksforgeeks.org/react-native-works/)\n","slug":"2020-03-07-React Native是如何工作的","published":1,"updated":"2021-06-19T03:46:24.083Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbp90005bjrj3cxz3icx","content":"<h2 id=\"React-Native是如何工作的？\"><a href=\"#React-Native是如何工作的？\" class=\"headerlink\" title=\"React Native是如何工作的？\"></a>React Native是如何工作的？</h2><h3 id=\"React-Native-App中的线程\"><a href=\"#React-Native-App中的线程\" class=\"headerlink\" title=\"React Native App中的线程\"></a>React Native App中的线程</h3><p>在React Native App中有4个线程：</p>\n<pre><code>1）UI线程：即主线程。它用于Android和iOS原生UI的渲染。比如在安卓上，关于UI的测量/布局/绘制就是在UI线程上。\n\n2）JS线程：JS线程或JavaScript线程是逻辑将会在其中运行。比如应用程序的JavaScript代码执行、API调用、触摸事件处理都是在这个线程中运行的。当JS线程中的每个事件循环结束时，对于UI的更新将被分批发送到native端进行更新。\n\n为了拥有更好的性能，JS线程应该能够在下一帧渲染前将更新内容传递给UI线程。比如iOS每秒钟渲染60帧，每一帧间隔为16.67ms。如果在JS线程中的事件循环内做了比较复杂的操作花费大于16.67ms，UI将会卡顿。\n\n有一个例外是，如果UI本来就在native端发生变化，则不会由于JS端阻塞而卡顿。\n\n3）Native Modules线程：有时候App需要访问native端的API，则会在Native Module线程中调用。\n\n4）渲染线程：仅在Android L (5.0)时，渲染线程用于生成OpenGL命令去绘制UI。\n</code></pre>\n<h3 id=\"在程序过程中React-Native是如何工作的\"><a href=\"#在程序过程中React-Native是如何工作的\" class=\"headerlink\" title=\"在程序过程中React Native是如何工作的\"></a>在程序过程中React Native是如何工作的</h3><pre><code>1）在程序启动时，在主线程中开始解析并加载`JS Bundle`\n\n2) 当JavaScript代码加载成功之后，主线程把JavaScript代码送到另一个JS线程，这样当JS代码在做一些繁重的计算任务导致阻塞一段时间也不会影响UI线程。\n\n3）当React开始渲染，Reconciler开始计算差异，同时会生成一个新的虚拟DOM(布局)，它把这些DOM上的变化传递给另一个Shadow Thread（为什么叫做“Shadow”，因为他会生成“Shadow Node”）。\n\n4）Shadow Thread计算布局然后把布局参数或布局对象传递给主线程。\n\n5）由于只有主线程才能在屏幕上进行渲染，所以Shadow Thread把生成好的布局传递给主线程，然后渲染UI。\n</code></pre>\n<h3 id=\"React-Native的组成\"><a href=\"#React-Native的组成\" class=\"headerlink\" title=\"React Native的组成\"></a>React Native的组成</h3><p>通常我们把React Native分成3部分：</p>\n<pre><code>1）React Native - 原生端即Native\n\n2）React Native - JS端\n\n3）React Native - 桥即bridge\n</code></pre>\n<p>翻译自<a href=\"https://www.geeksforgeeks.org/react-native-works/\">How React Native works?</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"React-Native是如何工作的？\"><a href=\"#React-Native是如何工作的？\" class=\"headerlink\" title=\"React Native是如何工作的？\"></a>React Native是如何工作的？</h2><h3 id=\"React-Native-App中的线程\"><a href=\"#React-Native-App中的线程\" class=\"headerlink\" title=\"React Native App中的线程\"></a>React Native App中的线程</h3><p>在React Native App中有4个线程：</p>\n<pre><code>1）UI线程：即主线程。它用于Android和iOS原生UI的渲染。比如在安卓上，关于UI的测量/布局/绘制就是在UI线程上。\n\n2）JS线程：JS线程或JavaScript线程是逻辑将会在其中运行。比如应用程序的JavaScript代码执行、API调用、触摸事件处理都是在这个线程中运行的。当JS线程中的每个事件循环结束时，对于UI的更新将被分批发送到native端进行更新。\n\n为了拥有更好的性能，JS线程应该能够在下一帧渲染前将更新内容传递给UI线程。比如iOS每秒钟渲染60帧，每一帧间隔为16.67ms。如果在JS线程中的事件循环内做了比较复杂的操作花费大于16.67ms，UI将会卡顿。\n\n有一个例外是，如果UI本来就在native端发生变化，则不会由于JS端阻塞而卡顿。\n\n3）Native Modules线程：有时候App需要访问native端的API，则会在Native Module线程中调用。\n\n4）渲染线程：仅在Android L (5.0)时，渲染线程用于生成OpenGL命令去绘制UI。\n</code></pre>\n<h3 id=\"在程序过程中React-Native是如何工作的\"><a href=\"#在程序过程中React-Native是如何工作的\" class=\"headerlink\" title=\"在程序过程中React Native是如何工作的\"></a>在程序过程中React Native是如何工作的</h3><pre><code>1）在程序启动时，在主线程中开始解析并加载`JS Bundle`\n\n2) 当JavaScript代码加载成功之后，主线程把JavaScript代码送到另一个JS线程，这样当JS代码在做一些繁重的计算任务导致阻塞一段时间也不会影响UI线程。\n\n3）当React开始渲染，Reconciler开始计算差异，同时会生成一个新的虚拟DOM(布局)，它把这些DOM上的变化传递给另一个Shadow Thread（为什么叫做“Shadow”，因为他会生成“Shadow Node”）。\n\n4）Shadow Thread计算布局然后把布局参数或布局对象传递给主线程。\n\n5）由于只有主线程才能在屏幕上进行渲染，所以Shadow Thread把生成好的布局传递给主线程，然后渲染UI。\n</code></pre>\n<h3 id=\"React-Native的组成\"><a href=\"#React-Native的组成\" class=\"headerlink\" title=\"React Native的组成\"></a>React Native的组成</h3><p>通常我们把React Native分成3部分：</p>\n<pre><code>1）React Native - 原生端即Native\n\n2）React Native - JS端\n\n3）React Native - 桥即bridge\n</code></pre>\n<p>翻译自<a href=\"https://www.geeksforgeeks.org/react-native-works/\">How React Native works?</a></p>\n"},{"title":"OpenGL常见专业名词","date":"2020-07-01T16:00:00.000Z","_content":"\n参考了[维基百科](https://zh.wikipedia.org/wiki)\n\n**OpenGL**：Open Graphis Library，是用于渲染2D、3D矢量图形的跨语言、跨平台的API。\n\n**OpenGL ES**：OpenGL For Embedded Systems，是OpenGL的子集，针对手机、PAD和游戏主机等嵌入式设备而设计。\n\n**DirectX**：由微软公司创建的一系列专为多媒体以及游戏开发的API。\n\n**Metal**：Apple推出的一个兼顾图形与计算功能的，面向低层、低开销的硬件加速API。类似于将OpenGL和OpenCL的功能集成到了同一API上。\n\n**OpenCL**：最初由Apple开发的为异构平台编写程序的框架，OpenCL扩展了GPU图形生成之外的能力。\n\n---\n\n**上下文(context):** 一个非常庞大的状态机，里面是对于OpenGL各种状态的描述与记录。OpenGL指令执行需要有上下文环境，执行指令即修改上下文中各种状态。切换上下文需要消耗比较大的资源。\n\n**渲染**：是将模型数据转换成图像数据的过程，将图形/图像数据转成2D空间图像操作叫做渲染。\n\n**顶点数组**：顶点位置数据存储在内存中即顶点数组。\n\n**顶点缓冲区**：为了更加高效，将顶点数组拷贝到显存中，即顶点缓冲区。\n\n**着色器**：在CPU中执行的代码段可以叫做`函数/方法`，在GPU中执行的代码段可以叫做`着色器(Shader)`。\n\n**管线**：OpenGL在处理渲染图形处理数据时，是严格按照一定顺序进行的，把这一系列处理数据的流程理解为管线。\n\n**固定管线(存储着色器)**：类比苹果提供给开发者已经封装好的API，固定管线(存储着色器)就是由OpenGL封装好的API，开发者只需要传递参数调用即可。\n\n**自定义着色器**：由于部分场景固定管线无法满足，OpenGL开放了部分着色器(一般指下面的`顶点着色器`和`片元着色器`)可以编程,也就是基于`GLSL`语法来编写的代码段。\n\n**GPU渲染流程**\n![image.png](https://upload-images.jianshu.io/upload_images/1395687-26d9d760082af7a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**顶点着色器**：处理顶点相关。\n\n作用有：\n + 确定位置\n + 缩放/平移/旋转的位置换算\n + 3D图形数据转换为2D数据(投影换算)\n\n**片元着色器**：片元即像素点，所以也叫像素着色器，处理一个个像素点，如120*120像素点，片元着色器需要执行14400次。如针对一张图片的饱和度调整，则需要片元着色器对每个像素点进行修改。\n\n**光栅化**：将顶点数据转换为片元的过程。片元中的每一个元素对应帧缓冲区的一个像素。包括2个部分工作，且不可编程，只需要有认知就好。\n + 确定图形在像素范围内。\n + 分配一个颜色值和深度值到片元的每个元素。\n\n**纹理**：即比如png和jpeg解压缩后产生的位图。\n\n**混合**：如多个Layer图层进行叠加，不同颜色值和透明度需要进行颜色的混合计算。\n\n**变换矩阵**：图形发生平移/旋转/缩放需要使用变换矩阵。\n\n**投影矩阵**：3D图形转为2D坐标需要使用投影矩阵。\n\n**投影方式**：有且只有两种，正投影(平行投影)/透视投影。\n\n**坐标系**：\n + 物体坐标系\n + 世界坐标系\n + 观察者坐标系\n + 规范化设备坐标系\n + 屏幕坐标系\n \n---\n","source":"_posts/2020-07-02-OpenGL常见专业名词.markdown","raw":"---\ntitle:      \"OpenGL常见专业名词\" \ndate:       2020-07-02\ntags:\n    - OpenGL\ncategories:\n    - OpenGL\n---\n\n参考了[维基百科](https://zh.wikipedia.org/wiki)\n\n**OpenGL**：Open Graphis Library，是用于渲染2D、3D矢量图形的跨语言、跨平台的API。\n\n**OpenGL ES**：OpenGL For Embedded Systems，是OpenGL的子集，针对手机、PAD和游戏主机等嵌入式设备而设计。\n\n**DirectX**：由微软公司创建的一系列专为多媒体以及游戏开发的API。\n\n**Metal**：Apple推出的一个兼顾图形与计算功能的，面向低层、低开销的硬件加速API。类似于将OpenGL和OpenCL的功能集成到了同一API上。\n\n**OpenCL**：最初由Apple开发的为异构平台编写程序的框架，OpenCL扩展了GPU图形生成之外的能力。\n\n---\n\n**上下文(context):** 一个非常庞大的状态机，里面是对于OpenGL各种状态的描述与记录。OpenGL指令执行需要有上下文环境，执行指令即修改上下文中各种状态。切换上下文需要消耗比较大的资源。\n\n**渲染**：是将模型数据转换成图像数据的过程，将图形/图像数据转成2D空间图像操作叫做渲染。\n\n**顶点数组**：顶点位置数据存储在内存中即顶点数组。\n\n**顶点缓冲区**：为了更加高效，将顶点数组拷贝到显存中，即顶点缓冲区。\n\n**着色器**：在CPU中执行的代码段可以叫做`函数/方法`，在GPU中执行的代码段可以叫做`着色器(Shader)`。\n\n**管线**：OpenGL在处理渲染图形处理数据时，是严格按照一定顺序进行的，把这一系列处理数据的流程理解为管线。\n\n**固定管线(存储着色器)**：类比苹果提供给开发者已经封装好的API，固定管线(存储着色器)就是由OpenGL封装好的API，开发者只需要传递参数调用即可。\n\n**自定义着色器**：由于部分场景固定管线无法满足，OpenGL开放了部分着色器(一般指下面的`顶点着色器`和`片元着色器`)可以编程,也就是基于`GLSL`语法来编写的代码段。\n\n**GPU渲染流程**\n![image.png](https://upload-images.jianshu.io/upload_images/1395687-26d9d760082af7a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**顶点着色器**：处理顶点相关。\n\n作用有：\n + 确定位置\n + 缩放/平移/旋转的位置换算\n + 3D图形数据转换为2D数据(投影换算)\n\n**片元着色器**：片元即像素点，所以也叫像素着色器，处理一个个像素点，如120*120像素点，片元着色器需要执行14400次。如针对一张图片的饱和度调整，则需要片元着色器对每个像素点进行修改。\n\n**光栅化**：将顶点数据转换为片元的过程。片元中的每一个元素对应帧缓冲区的一个像素。包括2个部分工作，且不可编程，只需要有认知就好。\n + 确定图形在像素范围内。\n + 分配一个颜色值和深度值到片元的每个元素。\n\n**纹理**：即比如png和jpeg解压缩后产生的位图。\n\n**混合**：如多个Layer图层进行叠加，不同颜色值和透明度需要进行颜色的混合计算。\n\n**变换矩阵**：图形发生平移/旋转/缩放需要使用变换矩阵。\n\n**投影矩阵**：3D图形转为2D坐标需要使用投影矩阵。\n\n**投影方式**：有且只有两种，正投影(平行投影)/透视投影。\n\n**坐标系**：\n + 物体坐标系\n + 世界坐标系\n + 观察者坐标系\n + 规范化设备坐标系\n + 屏幕坐标系\n \n---\n","slug":"2020-07-02-OpenGL常见专业名词","published":1,"updated":"2021-06-19T03:46:24.083Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbp90006bjrj8ax394lv","content":"<p>参考了<a href=\"https://zh.wikipedia.org/wiki\">维基百科</a></p>\n<p><strong>OpenGL</strong>：Open Graphis Library，是用于渲染2D、3D矢量图形的跨语言、跨平台的API。</p>\n<p><strong>OpenGL ES</strong>：OpenGL For Embedded Systems，是OpenGL的子集，针对手机、PAD和游戏主机等嵌入式设备而设计。</p>\n<p><strong>DirectX</strong>：由微软公司创建的一系列专为多媒体以及游戏开发的API。</p>\n<p><strong>Metal</strong>：Apple推出的一个兼顾图形与计算功能的，面向低层、低开销的硬件加速API。类似于将OpenGL和OpenCL的功能集成到了同一API上。</p>\n<p><strong>OpenCL</strong>：最初由Apple开发的为异构平台编写程序的框架，OpenCL扩展了GPU图形生成之外的能力。</p>\n<hr>\n<p><strong>上下文(context):</strong> 一个非常庞大的状态机，里面是对于OpenGL各种状态的描述与记录。OpenGL指令执行需要有上下文环境，执行指令即修改上下文中各种状态。切换上下文需要消耗比较大的资源。</p>\n<p><strong>渲染</strong>：是将模型数据转换成图像数据的过程，将图形/图像数据转成2D空间图像操作叫做渲染。</p>\n<p><strong>顶点数组</strong>：顶点位置数据存储在内存中即顶点数组。</p>\n<p><strong>顶点缓冲区</strong>：为了更加高效，将顶点数组拷贝到显存中，即顶点缓冲区。</p>\n<p><strong>着色器</strong>：在CPU中执行的代码段可以叫做<code>函数/方法</code>，在GPU中执行的代码段可以叫做<code>着色器(Shader)</code>。</p>\n<p><strong>管线</strong>：OpenGL在处理渲染图形处理数据时，是严格按照一定顺序进行的，把这一系列处理数据的流程理解为管线。</p>\n<p>**固定管线(存储着色器)**：类比苹果提供给开发者已经封装好的API，固定管线(存储着色器)就是由OpenGL封装好的API，开发者只需要传递参数调用即可。</p>\n<p><strong>自定义着色器</strong>：由于部分场景固定管线无法满足，OpenGL开放了部分着色器(一般指下面的<code>顶点着色器</code>和<code>片元着色器</code>)可以编程,也就是基于<code>GLSL</code>语法来编写的代码段。</p>\n<p><strong>GPU渲染流程</strong><br><img src=\"https://upload-images.jianshu.io/upload_images/1395687-26d9d760082af7a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p><strong>顶点着色器</strong>：处理顶点相关。</p>\n<p>作用有：</p>\n<ul>\n<li>确定位置</li>\n<li>缩放/平移/旋转的位置换算</li>\n<li>3D图形数据转换为2D数据(投影换算)</li>\n</ul>\n<p><strong>片元着色器</strong>：片元即像素点，所以也叫像素着色器，处理一个个像素点，如120*120像素点，片元着色器需要执行14400次。如针对一张图片的饱和度调整，则需要片元着色器对每个像素点进行修改。</p>\n<p><strong>光栅化</strong>：将顶点数据转换为片元的过程。片元中的每一个元素对应帧缓冲区的一个像素。包括2个部分工作，且不可编程，只需要有认知就好。</p>\n<ul>\n<li>确定图形在像素范围内。</li>\n<li>分配一个颜色值和深度值到片元的每个元素。</li>\n</ul>\n<p><strong>纹理</strong>：即比如png和jpeg解压缩后产生的位图。</p>\n<p><strong>混合</strong>：如多个Layer图层进行叠加，不同颜色值和透明度需要进行颜色的混合计算。</p>\n<p><strong>变换矩阵</strong>：图形发生平移/旋转/缩放需要使用变换矩阵。</p>\n<p><strong>投影矩阵</strong>：3D图形转为2D坐标需要使用投影矩阵。</p>\n<p><strong>投影方式</strong>：有且只有两种，正投影(平行投影)/透视投影。</p>\n<p><strong>坐标系</strong>：</p>\n<ul>\n<li>物体坐标系</li>\n<li>世界坐标系</li>\n<li>观察者坐标系</li>\n<li>规范化设备坐标系</li>\n<li>屏幕坐标系</li>\n</ul>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<p>参考了<a href=\"https://zh.wikipedia.org/wiki\">维基百科</a></p>\n<p><strong>OpenGL</strong>：Open Graphis Library，是用于渲染2D、3D矢量图形的跨语言、跨平台的API。</p>\n<p><strong>OpenGL ES</strong>：OpenGL For Embedded Systems，是OpenGL的子集，针对手机、PAD和游戏主机等嵌入式设备而设计。</p>\n<p><strong>DirectX</strong>：由微软公司创建的一系列专为多媒体以及游戏开发的API。</p>\n<p><strong>Metal</strong>：Apple推出的一个兼顾图形与计算功能的，面向低层、低开销的硬件加速API。类似于将OpenGL和OpenCL的功能集成到了同一API上。</p>\n<p><strong>OpenCL</strong>：最初由Apple开发的为异构平台编写程序的框架，OpenCL扩展了GPU图形生成之外的能力。</p>\n<hr>\n<p><strong>上下文(context):</strong> 一个非常庞大的状态机，里面是对于OpenGL各种状态的描述与记录。OpenGL指令执行需要有上下文环境，执行指令即修改上下文中各种状态。切换上下文需要消耗比较大的资源。</p>\n<p><strong>渲染</strong>：是将模型数据转换成图像数据的过程，将图形/图像数据转成2D空间图像操作叫做渲染。</p>\n<p><strong>顶点数组</strong>：顶点位置数据存储在内存中即顶点数组。</p>\n<p><strong>顶点缓冲区</strong>：为了更加高效，将顶点数组拷贝到显存中，即顶点缓冲区。</p>\n<p><strong>着色器</strong>：在CPU中执行的代码段可以叫做<code>函数/方法</code>，在GPU中执行的代码段可以叫做<code>着色器(Shader)</code>。</p>\n<p><strong>管线</strong>：OpenGL在处理渲染图形处理数据时，是严格按照一定顺序进行的，把这一系列处理数据的流程理解为管线。</p>\n<p>**固定管线(存储着色器)**：类比苹果提供给开发者已经封装好的API，固定管线(存储着色器)就是由OpenGL封装好的API，开发者只需要传递参数调用即可。</p>\n<p><strong>自定义着色器</strong>：由于部分场景固定管线无法满足，OpenGL开放了部分着色器(一般指下面的<code>顶点着色器</code>和<code>片元着色器</code>)可以编程,也就是基于<code>GLSL</code>语法来编写的代码段。</p>\n<p><strong>GPU渲染流程</strong><br><img src=\"https://upload-images.jianshu.io/upload_images/1395687-26d9d760082af7a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p><strong>顶点着色器</strong>：处理顶点相关。</p>\n<p>作用有：</p>\n<ul>\n<li>确定位置</li>\n<li>缩放/平移/旋转的位置换算</li>\n<li>3D图形数据转换为2D数据(投影换算)</li>\n</ul>\n<p><strong>片元着色器</strong>：片元即像素点，所以也叫像素着色器，处理一个个像素点，如120*120像素点，片元着色器需要执行14400次。如针对一张图片的饱和度调整，则需要片元着色器对每个像素点进行修改。</p>\n<p><strong>光栅化</strong>：将顶点数据转换为片元的过程。片元中的每一个元素对应帧缓冲区的一个像素。包括2个部分工作，且不可编程，只需要有认知就好。</p>\n<ul>\n<li>确定图形在像素范围内。</li>\n<li>分配一个颜色值和深度值到片元的每个元素。</li>\n</ul>\n<p><strong>纹理</strong>：即比如png和jpeg解压缩后产生的位图。</p>\n<p><strong>混合</strong>：如多个Layer图层进行叠加，不同颜色值和透明度需要进行颜色的混合计算。</p>\n<p><strong>变换矩阵</strong>：图形发生平移/旋转/缩放需要使用变换矩阵。</p>\n<p><strong>投影矩阵</strong>：3D图形转为2D坐标需要使用投影矩阵。</p>\n<p><strong>投影方式</strong>：有且只有两种，正投影(平行投影)/透视投影。</p>\n<p><strong>坐标系</strong>：</p>\n<ul>\n<li>物体坐标系</li>\n<li>世界坐标系</li>\n<li>观察者坐标系</li>\n<li>规范化设备坐标系</li>\n<li>屏幕坐标系</li>\n</ul>\n<hr>\n"},{"title":"iOS图片解码","date":"2020-07-02T16:00:00.000Z","_content":"\n参考[iOS图片解码实践]([http://lemon2well.top/2018/09/04/iOS%20%E5%BC%80%E5%8F%91/iOS%E5%9B%BE%E7%89%87%E8%A7%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/](http://lemon2well.top/2018/09/04/iOS%20%E5%BC%80%E5%8F%91/iOS%E5%9B%BE%E7%89%87%E8%A7%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/)\n) / [iOS图像解码和最佳实践]([https://blog.jamchenjun.com/2018/08/22/image-and-graphics-best-practices.html](https://blog.jamchenjun.com/2018/08/22/image-and-graphics-best-practices.html)\n) / [SDWebImage]([https://github.com/SDWebImage/SDWebImage](https://github.com/SDWebImage/SDWebImage)\n) /  [YYImage]([https://github.com/ibireme/YYImage](https://github.com/ibireme/YYImage)\n)\n\n### `imageNamed` 和  `imageWithContentsOfFile`的区别\n\n####  1、```+ (UIImage *)imageNamed:(NSString *)name;```\n\n`name`：图片资源或文件的名称。对于assets中的资源，是指定的图片资源名称，图片资源中可以包含1x、2x、3x图片，系统会自动选择。对于png图像可以省略扩展名，对于其他格式图片需要始终包含文件扩展名。\n\n当在assets目录中查找时，查找`symbol image`优先于同名当`bitmap image`。由于`symbol image`仅支持iOS13及之后版本，所以可能需要在assets中包含两套图片格式，系统会在早期iOS版本自动选择`bitmap image`，不过我觉得一般没人这么干吧~。不能使用这个方法加载系统的`symbol image`,需要使用`systemImageNamed:`方法。\n\n这个方法会根据指定的名称在系统缓存中查找，选择最适合屏幕的image返回。如果系统缓存中没有找到，则从asstes目录或磁盘中找到正确的图片创建一个image返回。系统会随时清空图片缓存，当然仅仅是清空未使用的图片缓存。\n\n这个方法在iOS9之后是线程安全的。\n\nTip:\n> 如果仅加载一次图片或者不想要添加到系统缓存中，可以使用`imageWithContentsOfFile`方法创建image。保证使用次数少的图片不添加到系统缓存中，可以有效提高App内存使用效率。\n\n#### 2、```+ (UIImage *)imageWithContentsOfFile:(NSString *)path;```\n\n这个方法不会缓存image对象。而且只会根据文件名获取，并不会根据2x、3x自动创建。\n\n### 图片解压缩\n\n> 由于png、jpeg等图片格式均是压缩的位图图片，在显示时需要解码成位图。png是无损压缩且支持alpha通道，jpeg是有损压缩。\n\n```\n    UIImageView *imgV = [[UIImageView alloc] initWithFrame:self.view.bounds];\n    UIImage *image = [UIImage imageNamed:@\"test.jpeg\"];\n    [self.view addSubview:imgV];\n```\n上述代码第一次加载时做了如下操作：\n + 从磁盘加载test.jpeg图片到内存中为 `Data Buffer`\n + 当图片真正要被显示在屏幕上时，会触发解码，`Data Buffer` ---> `Image Buffer`\n + 然后`Image Buffer`传递给GPU,GPU经过顶点坐标转换、顶点着色器、光栅化、片元着色器等步骤转化为`Frame Buffer`存在帧缓冲区，等待屏幕刷新显示\n\n下面代码通过`CGBitmapContextCreateImage`从图形上下文中获取到解码到位图。\n\n```\n+ (void)decodeSourceImage:(UIImage *)sourceImage completion:(nonnull void (^)(UIImage * _Nonnull))completion {\n    if (!sourceImage) return;\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        //获取图片宽高\n        CGImageRef cgimage = sourceImage.CGImage;\n        size_t width = CGImageGetWidth(cgimage);\n        size_t height = CGImageGetHeight(cgimage);\n        if (width == 0 || height == 0) return;\n        \n        //判断是否有alpha通道\n        CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(cgimage) & kCGBitmapAlphaInfoMask;\n        BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone ||\n                          alphaInfo == kCGImageAlphaNoneSkipFirst ||\n                          alphaInfo == kCGImageAlphaNoneSkipLast);\n        \n        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;\n        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;\n        \n        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n        //创建图形上下文\n        CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace, bitmapInfo);\n        if (!context) return;\n        //绘制到上下文中解压\n        CGContextDrawImage(context, CGRectMake(0, 0, width, height), cgimage); // decode\n        //从上下文中获取\n        CGImageRef newCgimage = CGBitmapContextCreateImage(context);\n        UIImage *desImage = [UIImage imageWithCGImage:newCgimage];\n        CGContextRelease(context);\n        dispatch_async(dispatch_get_main_queue(), ^{\n            if (completion) {\n                completion(desImage);\n            }\n        });\n    });\n}\n```\n \nYYKit中提供了另一种解码方式如下，在注释中说使用原始数据解码会造成丢失一些精度。\n\n```\n  + (void)decodeSourceImage1:(UIImage *)sourceImage completion:(nonnull void (^)(UIImage * _Nonnull))completion {\n    if (!sourceImage) return;\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        CGImageRef cgimage = sourceImage.CGImage;\n        size_t width = CGImageGetWidth(cgimage);\n        size_t height = CGImageGetHeight(cgimage);\n        if (width == 0 || height == 0) return;\n        \n        CGColorSpaceRef colorSpace = CGImageGetColorSpace(cgimage);\n        size_t bitsPerComponent = CGImageGetBitsPerComponent(cgimage);\n        size_t bitsPerPixel = CGImageGetBitsPerPixel(cgimage);\n        size_t bytesPerRow = CGImageGetBytesPerRow(cgimage);\n        CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(cgimage);\n        if (bytesPerRow == 0 || width == 0 || height == 0) return;\n        \n        CGDataProviderRef provider = CGImageGetDataProvider(cgimage);\n        if (!provider) return;\n        //获取原始数据\n        CFDataRef data = CGDataProviderCopyData(provider);\n        if (!data) return;\n        \n        CGDataProviderRef newProvider = CGDataProviderCreateWithCFData(data);\n        CFRelease(data);\n        if (!newProvider) return;\n        \n        CGImageRef newImageRef = CGImageCreate(width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, colorSpace, bitmapInfo, newProvider, NULL, false, kCGRenderingIntentDefault);\n        UIImage *desImage = [UIImage imageWithCGImage:newImageRef]; \n        dispatch_async(dispatch_get_main_queue(), ^{\n            if (completion) {\n                completion(desImage);\n            }\n        });\n        \n    });\n}\n```\n\n\n\n\n\n\n\n","source":"_posts/2020-07-03-iOS图片解码.markdown","raw":"---\ntitle:      \"iOS图片解码\" \ndate:       2020-07-03\ntags:\n    - iOS \ncategories:\n    - iOS \n---\n\n参考[iOS图片解码实践]([http://lemon2well.top/2018/09/04/iOS%20%E5%BC%80%E5%8F%91/iOS%E5%9B%BE%E7%89%87%E8%A7%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/](http://lemon2well.top/2018/09/04/iOS%20%E5%BC%80%E5%8F%91/iOS%E5%9B%BE%E7%89%87%E8%A7%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/)\n) / [iOS图像解码和最佳实践]([https://blog.jamchenjun.com/2018/08/22/image-and-graphics-best-practices.html](https://blog.jamchenjun.com/2018/08/22/image-and-graphics-best-practices.html)\n) / [SDWebImage]([https://github.com/SDWebImage/SDWebImage](https://github.com/SDWebImage/SDWebImage)\n) /  [YYImage]([https://github.com/ibireme/YYImage](https://github.com/ibireme/YYImage)\n)\n\n### `imageNamed` 和  `imageWithContentsOfFile`的区别\n\n####  1、```+ (UIImage *)imageNamed:(NSString *)name;```\n\n`name`：图片资源或文件的名称。对于assets中的资源，是指定的图片资源名称，图片资源中可以包含1x、2x、3x图片，系统会自动选择。对于png图像可以省略扩展名，对于其他格式图片需要始终包含文件扩展名。\n\n当在assets目录中查找时，查找`symbol image`优先于同名当`bitmap image`。由于`symbol image`仅支持iOS13及之后版本，所以可能需要在assets中包含两套图片格式，系统会在早期iOS版本自动选择`bitmap image`，不过我觉得一般没人这么干吧~。不能使用这个方法加载系统的`symbol image`,需要使用`systemImageNamed:`方法。\n\n这个方法会根据指定的名称在系统缓存中查找，选择最适合屏幕的image返回。如果系统缓存中没有找到，则从asstes目录或磁盘中找到正确的图片创建一个image返回。系统会随时清空图片缓存，当然仅仅是清空未使用的图片缓存。\n\n这个方法在iOS9之后是线程安全的。\n\nTip:\n> 如果仅加载一次图片或者不想要添加到系统缓存中，可以使用`imageWithContentsOfFile`方法创建image。保证使用次数少的图片不添加到系统缓存中，可以有效提高App内存使用效率。\n\n#### 2、```+ (UIImage *)imageWithContentsOfFile:(NSString *)path;```\n\n这个方法不会缓存image对象。而且只会根据文件名获取，并不会根据2x、3x自动创建。\n\n### 图片解压缩\n\n> 由于png、jpeg等图片格式均是压缩的位图图片，在显示时需要解码成位图。png是无损压缩且支持alpha通道，jpeg是有损压缩。\n\n```\n    UIImageView *imgV = [[UIImageView alloc] initWithFrame:self.view.bounds];\n    UIImage *image = [UIImage imageNamed:@\"test.jpeg\"];\n    [self.view addSubview:imgV];\n```\n上述代码第一次加载时做了如下操作：\n + 从磁盘加载test.jpeg图片到内存中为 `Data Buffer`\n + 当图片真正要被显示在屏幕上时，会触发解码，`Data Buffer` ---> `Image Buffer`\n + 然后`Image Buffer`传递给GPU,GPU经过顶点坐标转换、顶点着色器、光栅化、片元着色器等步骤转化为`Frame Buffer`存在帧缓冲区，等待屏幕刷新显示\n\n下面代码通过`CGBitmapContextCreateImage`从图形上下文中获取到解码到位图。\n\n```\n+ (void)decodeSourceImage:(UIImage *)sourceImage completion:(nonnull void (^)(UIImage * _Nonnull))completion {\n    if (!sourceImage) return;\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        //获取图片宽高\n        CGImageRef cgimage = sourceImage.CGImage;\n        size_t width = CGImageGetWidth(cgimage);\n        size_t height = CGImageGetHeight(cgimage);\n        if (width == 0 || height == 0) return;\n        \n        //判断是否有alpha通道\n        CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(cgimage) & kCGBitmapAlphaInfoMask;\n        BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone ||\n                          alphaInfo == kCGImageAlphaNoneSkipFirst ||\n                          alphaInfo == kCGImageAlphaNoneSkipLast);\n        \n        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;\n        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;\n        \n        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n        //创建图形上下文\n        CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, colorSpace, bitmapInfo);\n        if (!context) return;\n        //绘制到上下文中解压\n        CGContextDrawImage(context, CGRectMake(0, 0, width, height), cgimage); // decode\n        //从上下文中获取\n        CGImageRef newCgimage = CGBitmapContextCreateImage(context);\n        UIImage *desImage = [UIImage imageWithCGImage:newCgimage];\n        CGContextRelease(context);\n        dispatch_async(dispatch_get_main_queue(), ^{\n            if (completion) {\n                completion(desImage);\n            }\n        });\n    });\n}\n```\n \nYYKit中提供了另一种解码方式如下，在注释中说使用原始数据解码会造成丢失一些精度。\n\n```\n  + (void)decodeSourceImage1:(UIImage *)sourceImage completion:(nonnull void (^)(UIImage * _Nonnull))completion {\n    if (!sourceImage) return;\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        CGImageRef cgimage = sourceImage.CGImage;\n        size_t width = CGImageGetWidth(cgimage);\n        size_t height = CGImageGetHeight(cgimage);\n        if (width == 0 || height == 0) return;\n        \n        CGColorSpaceRef colorSpace = CGImageGetColorSpace(cgimage);\n        size_t bitsPerComponent = CGImageGetBitsPerComponent(cgimage);\n        size_t bitsPerPixel = CGImageGetBitsPerPixel(cgimage);\n        size_t bytesPerRow = CGImageGetBytesPerRow(cgimage);\n        CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(cgimage);\n        if (bytesPerRow == 0 || width == 0 || height == 0) return;\n        \n        CGDataProviderRef provider = CGImageGetDataProvider(cgimage);\n        if (!provider) return;\n        //获取原始数据\n        CFDataRef data = CGDataProviderCopyData(provider);\n        if (!data) return;\n        \n        CGDataProviderRef newProvider = CGDataProviderCreateWithCFData(data);\n        CFRelease(data);\n        if (!newProvider) return;\n        \n        CGImageRef newImageRef = CGImageCreate(width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, colorSpace, bitmapInfo, newProvider, NULL, false, kCGRenderingIntentDefault);\n        UIImage *desImage = [UIImage imageWithCGImage:newImageRef]; \n        dispatch_async(dispatch_get_main_queue(), ^{\n            if (completion) {\n                completion(desImage);\n            }\n        });\n        \n    });\n}\n```\n\n\n\n\n\n\n\n","slug":"2020-07-03-iOS图片解码","published":1,"updated":"2021-06-19T03:46:24.083Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbpb000abjrj3t6cahtl","content":"<p>参考<a href=\"%5Bhttp://lemon2well.top/2018/09/04/iOS%20%E5%BC%80%E5%8F%91/iOS%E5%9B%BE%E7%89%87%E8%A7%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/%5D(http://lemon2well.top/2018/09/04/iOS%20%E5%BC%80%E5%8F%91/iOS%E5%9B%BE%E7%89%87%E8%A7%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/)\">iOS图片解码实践</a> / <a href=\"%5Bhttps://blog.jamchenjun.com/2018/08/22/image-and-graphics-best-practices.html%5D(https://blog.jamchenjun.com/2018/08/22/image-and-graphics-best-practices.html)\">iOS图像解码和最佳实践</a> / <a href=\"%5Bhttps://github.com/SDWebImage/SDWebImage%5D(https://github.com/SDWebImage/SDWebImage)\">SDWebImage</a> /  <a href=\"%5Bhttps://github.com/ibireme/YYImage%5D(https://github.com/ibireme/YYImage)\">YYImage</a></p>\n<h3 id=\"imageNamed-和-imageWithContentsOfFile的区别\"><a href=\"#imageNamed-和-imageWithContentsOfFile的区别\" class=\"headerlink\" title=\"imageNamed 和  imageWithContentsOfFile的区别\"></a><code>imageNamed</code> 和  <code>imageWithContentsOfFile</code>的区别</h3><h4 id=\"1、-UIImage-imageNamed-NSString-name\"><a href=\"#1、-UIImage-imageNamed-NSString-name\" class=\"headerlink\" title=\"1、+ (UIImage *)imageNamed:(NSString *)name;\"></a>1、<code>+ (UIImage *)imageNamed:(NSString *)name;</code></h4><p><code>name</code>：图片资源或文件的名称。对于assets中的资源，是指定的图片资源名称，图片资源中可以包含1x、2x、3x图片，系统会自动选择。对于png图像可以省略扩展名，对于其他格式图片需要始终包含文件扩展名。</p>\n<p>当在assets目录中查找时，查找<code>symbol image</code>优先于同名当<code>bitmap image</code>。由于<code>symbol image</code>仅支持iOS13及之后版本，所以可能需要在assets中包含两套图片格式，系统会在早期iOS版本自动选择<code>bitmap image</code>，不过我觉得一般没人这么干吧~。不能使用这个方法加载系统的<code>symbol image</code>,需要使用<code>systemImageNamed:</code>方法。</p>\n<p>这个方法会根据指定的名称在系统缓存中查找，选择最适合屏幕的image返回。如果系统缓存中没有找到，则从asstes目录或磁盘中找到正确的图片创建一个image返回。系统会随时清空图片缓存，当然仅仅是清空未使用的图片缓存。</p>\n<p>这个方法在iOS9之后是线程安全的。</p>\n<p>Tip:</p>\n<blockquote>\n<p>如果仅加载一次图片或者不想要添加到系统缓存中，可以使用<code>imageWithContentsOfFile</code>方法创建image。保证使用次数少的图片不添加到系统缓存中，可以有效提高App内存使用效率。</p>\n</blockquote>\n<h4 id=\"2、-UIImage-imageWithContentsOfFile-NSString-path\"><a href=\"#2、-UIImage-imageWithContentsOfFile-NSString-path\" class=\"headerlink\" title=\"2、+ (UIImage *)imageWithContentsOfFile:(NSString *)path;\"></a>2、<code>+ (UIImage *)imageWithContentsOfFile:(NSString *)path;</code></h4><p>这个方法不会缓存image对象。而且只会根据文件名获取，并不会根据2x、3x自动创建。</p>\n<h3 id=\"图片解压缩\"><a href=\"#图片解压缩\" class=\"headerlink\" title=\"图片解压缩\"></a>图片解压缩</h3><blockquote>\n<p>由于png、jpeg等图片格式均是压缩的位图图片，在显示时需要解码成位图。png是无损压缩且支持alpha通道，jpeg是有损压缩。</p>\n</blockquote>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIImageView</span> *imgV = [[<span class=\"built_in\">UIImageView</span> alloc] initWithFrame:<span class=\"keyword\">self</span>.view.bounds];</span><br><span class=\"line\"><span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@&quot;test.jpeg&quot;</span>];</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:imgV];</span><br></pre></td></tr></table></figure>\n<p>上述代码第一次加载时做了如下操作：</p>\n<ul>\n<li>从磁盘加载test.jpeg图片到内存中为 <code>Data Buffer</code></li>\n<li>当图片真正要被显示在屏幕上时，会触发解码，<code>Data Buffer</code> —&gt; <code>Image Buffer</code></li>\n<li>然后<code>Image Buffer</code>传递给GPU,GPU经过顶点坐标转换、顶点着色器、光栅化、片元着色器等步骤转化为<code>Frame Buffer</code>存在帧缓冲区，等待屏幕刷新显示</li>\n</ul>\n<p>下面代码通过<code>CGBitmapContextCreateImage</code>从图形上下文中获取到解码到位图。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">void</span>)decodeSourceImage:(<span class=\"built_in\">UIImage</span> *)sourceImage completion:(<span class=\"keyword\">nonnull</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">UIImage</span> * _Nonnull))completion &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!sourceImage) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取图片宽高</span></span><br><span class=\"line\">        <span class=\"built_in\">CGImageRef</span> cgimage = sourceImage.CGImage;</span><br><span class=\"line\">        size_t width = <span class=\"built_in\">CGImageGetWidth</span>(cgimage);</span><br><span class=\"line\">        size_t height = <span class=\"built_in\">CGImageGetHeight</span>(cgimage);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (width == <span class=\"number\">0</span> || height == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//判断是否有alpha通道</span></span><br><span class=\"line\">        <span class=\"built_in\">CGImageAlphaInfo</span> alphaInfo = <span class=\"built_in\">CGImageGetAlphaInfo</span>(cgimage) &amp; kCGBitmapAlphaInfoMask;</span><br><span class=\"line\">        <span class=\"built_in\">BOOL</span> hasAlpha = !(alphaInfo == kCGImageAlphaNone ||</span><br><span class=\"line\">                          alphaInfo == kCGImageAlphaNoneSkipFirst ||</span><br><span class=\"line\">                          alphaInfo == kCGImageAlphaNoneSkipLast);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">CGBitmapInfo</span> bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class=\"line\">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">CGColorSpaceRef</span> colorSpace = <span class=\"built_in\">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class=\"line\">        <span class=\"comment\">//创建图形上下文</span></span><br><span class=\"line\">        <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">CGBitmapContextCreate</span>(<span class=\"literal\">NULL</span>, width, height, <span class=\"number\">8</span>, <span class=\"number\">0</span>, colorSpace, bitmapInfo);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!context) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"comment\">//绘制到上下文中解压</span></span><br><span class=\"line\">        <span class=\"built_in\">CGContextDrawImage</span>(context, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, width, height), cgimage); <span class=\"comment\">// decode</span></span><br><span class=\"line\">        <span class=\"comment\">//从上下文中获取</span></span><br><span class=\"line\">        <span class=\"built_in\">CGImageRef</span> newCgimage = <span class=\"built_in\">CGBitmapContextCreateImage</span>(context);</span><br><span class=\"line\">        <span class=\"built_in\">UIImage</span> *desImage = [<span class=\"built_in\">UIImage</span> imageWithCGImage:newCgimage];</span><br><span class=\"line\">        <span class=\"built_in\">CGContextRelease</span>(context);</span><br><span class=\"line\">        <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (completion) &#123;</span><br><span class=\"line\">                completion(desImage);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>YYKit中提供了另一种解码方式如下，在注释中说使用原始数据解码会造成丢失一些精度。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  + (void)decodeSourceImage1:(UIImage *)sourceImage completion:(nonnull void (^)(UIImage<span class=\"operator\"> * </span>_Nonnull))completion &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!sourceImage) return;</span><br><span class=\"line\">    dispatch<span class=\"constructor\">_async(<span class=\"params\">dispatch_get_global_queue</span>(0, 0)</span>, ^&#123;</span><br><span class=\"line\">        CGImageRef cgimage = sourceImage.CGImage;</span><br><span class=\"line\">        size_t width = <span class=\"constructor\">CGImageGetWidth(<span class=\"params\">cgimage</span>)</span>;</span><br><span class=\"line\">        size_t height = <span class=\"constructor\">CGImageGetHeight(<span class=\"params\">cgimage</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (width<span class=\"operator\"> == </span><span class=\"number\">0</span><span class=\"operator\"> || </span>height<span class=\"operator\"> == </span><span class=\"number\">0</span>) return;</span><br><span class=\"line\">        </span><br><span class=\"line\">        CGColorSpaceRef colorSpace = <span class=\"constructor\">CGImageGetColorSpace(<span class=\"params\">cgimage</span>)</span>;</span><br><span class=\"line\">        size_t bitsPerComponent = <span class=\"constructor\">CGImageGetBitsPerComponent(<span class=\"params\">cgimage</span>)</span>;</span><br><span class=\"line\">        size_t bitsPerPixel = <span class=\"constructor\">CGImageGetBitsPerPixel(<span class=\"params\">cgimage</span>)</span>;</span><br><span class=\"line\">        size_t bytesPerRow = <span class=\"constructor\">CGImageGetBytesPerRow(<span class=\"params\">cgimage</span>)</span>;</span><br><span class=\"line\">        CGBitmapInfo bitmapInfo = <span class=\"constructor\">CGImageGetBitmapInfo(<span class=\"params\">cgimage</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bytesPerRow<span class=\"operator\"> == </span><span class=\"number\">0</span><span class=\"operator\"> || </span>width<span class=\"operator\"> == </span><span class=\"number\">0</span><span class=\"operator\"> || </span>height<span class=\"operator\"> == </span><span class=\"number\">0</span>) return;</span><br><span class=\"line\">        </span><br><span class=\"line\">        CGDataProviderRef provider = <span class=\"constructor\">CGImageGetDataProvider(<span class=\"params\">cgimage</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!provider) return;</span><br><span class=\"line\">        <span class=\"comment\">//获取原始数据</span></span><br><span class=\"line\">        CFDataRef data = <span class=\"constructor\">CGDataProviderCopyData(<span class=\"params\">provider</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!data) return;</span><br><span class=\"line\">        </span><br><span class=\"line\">        CGDataProviderRef newProvider = <span class=\"constructor\">CGDataProviderCreateWithCFData(<span class=\"params\">data</span>)</span>;</span><br><span class=\"line\">        <span class=\"constructor\">CFRelease(<span class=\"params\">data</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!newProvider) return;</span><br><span class=\"line\">        </span><br><span class=\"line\">        CGImageRef newImageRef = <span class=\"constructor\">CGImageCreate(<span class=\"params\">width</span>, <span class=\"params\">height</span>, <span class=\"params\">bitsPerComponent</span>, <span class=\"params\">bitsPerPixel</span>, <span class=\"params\">bytesPerRow</span>, <span class=\"params\">colorSpace</span>, <span class=\"params\">bitmapInfo</span>, <span class=\"params\">newProvider</span>, NULL, <span class=\"params\">false</span>, <span class=\"params\">kCGRenderingIntentDefault</span>)</span>;</span><br><span class=\"line\">        UIImage *desImage = <span class=\"literal\">[UII<span class=\"identifier\">mage</span> <span class=\"identifier\">imageWithCGImage</span>:<span class=\"identifier\">newImageRef</span>]</span>; </span><br><span class=\"line\">        dispatch<span class=\"constructor\">_async(<span class=\"params\">dispatch_get_main_queue</span>()</span>, ^&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (completion) &#123;</span><br><span class=\"line\">                completion(desImage);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<p>参考<a href=\"%5Bhttp://lemon2well.top/2018/09/04/iOS%20%E5%BC%80%E5%8F%91/iOS%E5%9B%BE%E7%89%87%E8%A7%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/%5D(http://lemon2well.top/2018/09/04/iOS%20%E5%BC%80%E5%8F%91/iOS%E5%9B%BE%E7%89%87%E8%A7%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/)\">iOS图片解码实践</a> / <a href=\"%5Bhttps://blog.jamchenjun.com/2018/08/22/image-and-graphics-best-practices.html%5D(https://blog.jamchenjun.com/2018/08/22/image-and-graphics-best-practices.html)\">iOS图像解码和最佳实践</a> / <a href=\"%5Bhttps://github.com/SDWebImage/SDWebImage%5D(https://github.com/SDWebImage/SDWebImage)\">SDWebImage</a> /  <a href=\"%5Bhttps://github.com/ibireme/YYImage%5D(https://github.com/ibireme/YYImage)\">YYImage</a></p>\n<h3 id=\"imageNamed-和-imageWithContentsOfFile的区别\"><a href=\"#imageNamed-和-imageWithContentsOfFile的区别\" class=\"headerlink\" title=\"imageNamed 和  imageWithContentsOfFile的区别\"></a><code>imageNamed</code> 和  <code>imageWithContentsOfFile</code>的区别</h3><h4 id=\"1、-UIImage-imageNamed-NSString-name\"><a href=\"#1、-UIImage-imageNamed-NSString-name\" class=\"headerlink\" title=\"1、+ (UIImage *)imageNamed:(NSString *)name;\"></a>1、<code>+ (UIImage *)imageNamed:(NSString *)name;</code></h4><p><code>name</code>：图片资源或文件的名称。对于assets中的资源，是指定的图片资源名称，图片资源中可以包含1x、2x、3x图片，系统会自动选择。对于png图像可以省略扩展名，对于其他格式图片需要始终包含文件扩展名。</p>\n<p>当在assets目录中查找时，查找<code>symbol image</code>优先于同名当<code>bitmap image</code>。由于<code>symbol image</code>仅支持iOS13及之后版本，所以可能需要在assets中包含两套图片格式，系统会在早期iOS版本自动选择<code>bitmap image</code>，不过我觉得一般没人这么干吧~。不能使用这个方法加载系统的<code>symbol image</code>,需要使用<code>systemImageNamed:</code>方法。</p>\n<p>这个方法会根据指定的名称在系统缓存中查找，选择最适合屏幕的image返回。如果系统缓存中没有找到，则从asstes目录或磁盘中找到正确的图片创建一个image返回。系统会随时清空图片缓存，当然仅仅是清空未使用的图片缓存。</p>\n<p>这个方法在iOS9之后是线程安全的。</p>\n<p>Tip:</p>\n<blockquote>\n<p>如果仅加载一次图片或者不想要添加到系统缓存中，可以使用<code>imageWithContentsOfFile</code>方法创建image。保证使用次数少的图片不添加到系统缓存中，可以有效提高App内存使用效率。</p>\n</blockquote>\n<h4 id=\"2、-UIImage-imageWithContentsOfFile-NSString-path\"><a href=\"#2、-UIImage-imageWithContentsOfFile-NSString-path\" class=\"headerlink\" title=\"2、+ (UIImage *)imageWithContentsOfFile:(NSString *)path;\"></a>2、<code>+ (UIImage *)imageWithContentsOfFile:(NSString *)path;</code></h4><p>这个方法不会缓存image对象。而且只会根据文件名获取，并不会根据2x、3x自动创建。</p>\n<h3 id=\"图片解压缩\"><a href=\"#图片解压缩\" class=\"headerlink\" title=\"图片解压缩\"></a>图片解压缩</h3><blockquote>\n<p>由于png、jpeg等图片格式均是压缩的位图图片，在显示时需要解码成位图。png是无损压缩且支持alpha通道，jpeg是有损压缩。</p>\n</blockquote>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIImageView</span> *imgV = [[<span class=\"built_in\">UIImageView</span> alloc] initWithFrame:<span class=\"keyword\">self</span>.view.bounds];</span><br><span class=\"line\"><span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@&quot;test.jpeg&quot;</span>];</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:imgV];</span><br></pre></td></tr></table></figure>\n<p>上述代码第一次加载时做了如下操作：</p>\n<ul>\n<li>从磁盘加载test.jpeg图片到内存中为 <code>Data Buffer</code></li>\n<li>当图片真正要被显示在屏幕上时，会触发解码，<code>Data Buffer</code> —&gt; <code>Image Buffer</code></li>\n<li>然后<code>Image Buffer</code>传递给GPU,GPU经过顶点坐标转换、顶点着色器、光栅化、片元着色器等步骤转化为<code>Frame Buffer</code>存在帧缓冲区，等待屏幕刷新显示</li>\n</ul>\n<p>下面代码通过<code>CGBitmapContextCreateImage</code>从图形上下文中获取到解码到位图。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">void</span>)decodeSourceImage:(<span class=\"built_in\">UIImage</span> *)sourceImage completion:(<span class=\"keyword\">nonnull</span> <span class=\"keyword\">void</span> (^)(<span class=\"built_in\">UIImage</span> * _Nonnull))completion &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!sourceImage) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取图片宽高</span></span><br><span class=\"line\">        <span class=\"built_in\">CGImageRef</span> cgimage = sourceImage.CGImage;</span><br><span class=\"line\">        size_t width = <span class=\"built_in\">CGImageGetWidth</span>(cgimage);</span><br><span class=\"line\">        size_t height = <span class=\"built_in\">CGImageGetHeight</span>(cgimage);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (width == <span class=\"number\">0</span> || height == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//判断是否有alpha通道</span></span><br><span class=\"line\">        <span class=\"built_in\">CGImageAlphaInfo</span> alphaInfo = <span class=\"built_in\">CGImageGetAlphaInfo</span>(cgimage) &amp; kCGBitmapAlphaInfoMask;</span><br><span class=\"line\">        <span class=\"built_in\">BOOL</span> hasAlpha = !(alphaInfo == kCGImageAlphaNone ||</span><br><span class=\"line\">                          alphaInfo == kCGImageAlphaNoneSkipFirst ||</span><br><span class=\"line\">                          alphaInfo == kCGImageAlphaNoneSkipLast);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">CGBitmapInfo</span> bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class=\"line\">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">CGColorSpaceRef</span> colorSpace = <span class=\"built_in\">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class=\"line\">        <span class=\"comment\">//创建图形上下文</span></span><br><span class=\"line\">        <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">CGBitmapContextCreate</span>(<span class=\"literal\">NULL</span>, width, height, <span class=\"number\">8</span>, <span class=\"number\">0</span>, colorSpace, bitmapInfo);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!context) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"comment\">//绘制到上下文中解压</span></span><br><span class=\"line\">        <span class=\"built_in\">CGContextDrawImage</span>(context, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, width, height), cgimage); <span class=\"comment\">// decode</span></span><br><span class=\"line\">        <span class=\"comment\">//从上下文中获取</span></span><br><span class=\"line\">        <span class=\"built_in\">CGImageRef</span> newCgimage = <span class=\"built_in\">CGBitmapContextCreateImage</span>(context);</span><br><span class=\"line\">        <span class=\"built_in\">UIImage</span> *desImage = [<span class=\"built_in\">UIImage</span> imageWithCGImage:newCgimage];</span><br><span class=\"line\">        <span class=\"built_in\">CGContextRelease</span>(context);</span><br><span class=\"line\">        <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (completion) &#123;</span><br><span class=\"line\">                completion(desImage);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>YYKit中提供了另一种解码方式如下，在注释中说使用原始数据解码会造成丢失一些精度。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  + (void)decodeSourceImage1:(UIImage *)sourceImage completion:(nonnull void (^)(UIImage<span class=\"operator\"> * </span>_Nonnull))completion &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!sourceImage) return;</span><br><span class=\"line\">    dispatch<span class=\"constructor\">_async(<span class=\"params\">dispatch_get_global_queue</span>(0, 0)</span>, ^&#123;</span><br><span class=\"line\">        CGImageRef cgimage = sourceImage.CGImage;</span><br><span class=\"line\">        size_t width = <span class=\"constructor\">CGImageGetWidth(<span class=\"params\">cgimage</span>)</span>;</span><br><span class=\"line\">        size_t height = <span class=\"constructor\">CGImageGetHeight(<span class=\"params\">cgimage</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (width<span class=\"operator\"> == </span><span class=\"number\">0</span><span class=\"operator\"> || </span>height<span class=\"operator\"> == </span><span class=\"number\">0</span>) return;</span><br><span class=\"line\">        </span><br><span class=\"line\">        CGColorSpaceRef colorSpace = <span class=\"constructor\">CGImageGetColorSpace(<span class=\"params\">cgimage</span>)</span>;</span><br><span class=\"line\">        size_t bitsPerComponent = <span class=\"constructor\">CGImageGetBitsPerComponent(<span class=\"params\">cgimage</span>)</span>;</span><br><span class=\"line\">        size_t bitsPerPixel = <span class=\"constructor\">CGImageGetBitsPerPixel(<span class=\"params\">cgimage</span>)</span>;</span><br><span class=\"line\">        size_t bytesPerRow = <span class=\"constructor\">CGImageGetBytesPerRow(<span class=\"params\">cgimage</span>)</span>;</span><br><span class=\"line\">        CGBitmapInfo bitmapInfo = <span class=\"constructor\">CGImageGetBitmapInfo(<span class=\"params\">cgimage</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bytesPerRow<span class=\"operator\"> == </span><span class=\"number\">0</span><span class=\"operator\"> || </span>width<span class=\"operator\"> == </span><span class=\"number\">0</span><span class=\"operator\"> || </span>height<span class=\"operator\"> == </span><span class=\"number\">0</span>) return;</span><br><span class=\"line\">        </span><br><span class=\"line\">        CGDataProviderRef provider = <span class=\"constructor\">CGImageGetDataProvider(<span class=\"params\">cgimage</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!provider) return;</span><br><span class=\"line\">        <span class=\"comment\">//获取原始数据</span></span><br><span class=\"line\">        CFDataRef data = <span class=\"constructor\">CGDataProviderCopyData(<span class=\"params\">provider</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!data) return;</span><br><span class=\"line\">        </span><br><span class=\"line\">        CGDataProviderRef newProvider = <span class=\"constructor\">CGDataProviderCreateWithCFData(<span class=\"params\">data</span>)</span>;</span><br><span class=\"line\">        <span class=\"constructor\">CFRelease(<span class=\"params\">data</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!newProvider) return;</span><br><span class=\"line\">        </span><br><span class=\"line\">        CGImageRef newImageRef = <span class=\"constructor\">CGImageCreate(<span class=\"params\">width</span>, <span class=\"params\">height</span>, <span class=\"params\">bitsPerComponent</span>, <span class=\"params\">bitsPerPixel</span>, <span class=\"params\">bytesPerRow</span>, <span class=\"params\">colorSpace</span>, <span class=\"params\">bitmapInfo</span>, <span class=\"params\">newProvider</span>, NULL, <span class=\"params\">false</span>, <span class=\"params\">kCGRenderingIntentDefault</span>)</span>;</span><br><span class=\"line\">        UIImage *desImage = <span class=\"literal\">[UII<span class=\"identifier\">mage</span> <span class=\"identifier\">imageWithCGImage</span>:<span class=\"identifier\">newImageRef</span>]</span>; </span><br><span class=\"line\">        dispatch<span class=\"constructor\">_async(<span class=\"params\">dispatch_get_main_queue</span>()</span>, ^&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (completion) &#123;</span><br><span class=\"line\">                completion(desImage);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n"},{"title":"iOS保持界面流畅","date":"2020-07-03T16:00:00.000Z","_content":"\n参考[YYKit作者的博客]([https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/](https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)\n)\n\n### CPU和GPU的区别\n\nCPU(中央处理器 Center Processing Unit)：是计算机的运算、控制、缓存处理核心，常用来处理复杂的逻辑以及数据结构，CPU中的并行其实是通过时间切片完成的。任务之间依赖性高。\n\nGPU(图形处理器 Graphics Processing Unit)：是一种专门处理绘图运算的微型处理器，在OpenGL中使用GLSL语言来驱动，功能单一，由许多计算单元组成，任务之间依赖性低。\n\n---\n\n### UIView和CALayer的联系与区别\n\n#### UIView和CALayer的联系\n\n- UIView的实力对象中默认有一个属性CALayer\n- UIView负责显示内容的管理，CALayer负责具体的显示\n- UIView是对CALayer的封装，并实现了CALayer代理的方法\n\n#### UIView和CALayer的区别\n \n- UIView继承自UIResponder，CALayer继承自NSObject\n- UIView可以响应事件，CALayer不可以\n\n### 图像显示原理\n\nCPU、GPU以及显示器协作完成显示。\n\n1. 早期的显示是**随机扫描显示**,扫描时间和图形复杂度有关。\n\n2. 之后出现了**光栅扫描显示**，图像组成了像素阵列，从上到下逐行扫描，和图形复杂度无关。\n\n- 简单的光栅扫描显示由于CPU和GPU的处理复杂程度，会造成GPU扫描显示时，扫描到一半，CPU的数据刷新GPU的缓冲区，显示造成**撕裂**效果。\n\n- 从而引出了 **垂直同步信号Vsync** 和 **双缓冲区** 机制。\n\n  **Vsync信号**用来解决**撕裂**问题，相当于给帧缓冲区加了锁，必须扫描显示完一帧才会接收下一帧的数据。\n\n  **双缓冲区**用来解决CPU和GPU的处理效率问题。视频控制器读取完缓冲区一帧后，会将指针指向第二个缓冲区。\n\n   当开启Vsync垂直同步后，GPU会等待显示器的Vsync信号，进行新一帧的渲染和缓冲区的更新，从而需要耗费更多的计算资源，同时也有可能造成**掉帧**现象。**掉帧**是指当接收到Vsync信号时，CPU或GPU还没有准备够足后的数据，视频控制器拿不到Frame Buffer，仍然显示上一帧画面。\n\n- **三级缓存** 和 **Vsync垂直同步**：提供多缓冲区，当Vsync信号出现时有足够的数据去显示，降低**掉帧**出现的概率。\n\n### 产生卡顿的原因\n\nCPU负责计算显示的内容，如试图创建、布局计算、图片解码、文本绘制等。CPU计算好之后提交到GPU，由GPU进行一系列处理之后提交到帧缓冲区。当接收到Vsync信号，视频控制器从缓冲区中读取数据。如果在一个Vsync时间内，CPU或GPU没有来得及提交下一帧的数据，视频控制器会显示上一帧的，即界面保持不变，这就是卡顿的原因。\n\n解决卡顿的方案待理解补充，[YYKit作者的博客]([https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/](https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)\n)写的很详细了。\n\n有理解不当之处，欢迎指正。\n ","source":"_posts/2020-07-04-iOS保持界面流畅.markdown","raw":"---\ntitle:      \"iOS保持界面流畅\" \ndate:       2020-07-04\ntags:\n    - iOS \ncategories:\n    - iOS \n---\n\n参考[YYKit作者的博客]([https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/](https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)\n)\n\n### CPU和GPU的区别\n\nCPU(中央处理器 Center Processing Unit)：是计算机的运算、控制、缓存处理核心，常用来处理复杂的逻辑以及数据结构，CPU中的并行其实是通过时间切片完成的。任务之间依赖性高。\n\nGPU(图形处理器 Graphics Processing Unit)：是一种专门处理绘图运算的微型处理器，在OpenGL中使用GLSL语言来驱动，功能单一，由许多计算单元组成，任务之间依赖性低。\n\n---\n\n### UIView和CALayer的联系与区别\n\n#### UIView和CALayer的联系\n\n- UIView的实力对象中默认有一个属性CALayer\n- UIView负责显示内容的管理，CALayer负责具体的显示\n- UIView是对CALayer的封装，并实现了CALayer代理的方法\n\n#### UIView和CALayer的区别\n \n- UIView继承自UIResponder，CALayer继承自NSObject\n- UIView可以响应事件，CALayer不可以\n\n### 图像显示原理\n\nCPU、GPU以及显示器协作完成显示。\n\n1. 早期的显示是**随机扫描显示**,扫描时间和图形复杂度有关。\n\n2. 之后出现了**光栅扫描显示**，图像组成了像素阵列，从上到下逐行扫描，和图形复杂度无关。\n\n- 简单的光栅扫描显示由于CPU和GPU的处理复杂程度，会造成GPU扫描显示时，扫描到一半，CPU的数据刷新GPU的缓冲区，显示造成**撕裂**效果。\n\n- 从而引出了 **垂直同步信号Vsync** 和 **双缓冲区** 机制。\n\n  **Vsync信号**用来解决**撕裂**问题，相当于给帧缓冲区加了锁，必须扫描显示完一帧才会接收下一帧的数据。\n\n  **双缓冲区**用来解决CPU和GPU的处理效率问题。视频控制器读取完缓冲区一帧后，会将指针指向第二个缓冲区。\n\n   当开启Vsync垂直同步后，GPU会等待显示器的Vsync信号，进行新一帧的渲染和缓冲区的更新，从而需要耗费更多的计算资源，同时也有可能造成**掉帧**现象。**掉帧**是指当接收到Vsync信号时，CPU或GPU还没有准备够足后的数据，视频控制器拿不到Frame Buffer，仍然显示上一帧画面。\n\n- **三级缓存** 和 **Vsync垂直同步**：提供多缓冲区，当Vsync信号出现时有足够的数据去显示，降低**掉帧**出现的概率。\n\n### 产生卡顿的原因\n\nCPU负责计算显示的内容，如试图创建、布局计算、图片解码、文本绘制等。CPU计算好之后提交到GPU，由GPU进行一系列处理之后提交到帧缓冲区。当接收到Vsync信号，视频控制器从缓冲区中读取数据。如果在一个Vsync时间内，CPU或GPU没有来得及提交下一帧的数据，视频控制器会显示上一帧的，即界面保持不变，这就是卡顿的原因。\n\n解决卡顿的方案待理解补充，[YYKit作者的博客]([https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/](https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)\n)写的很详细了。\n\n有理解不当之处，欢迎指正。\n ","slug":"2020-07-04-iOS保持界面流畅","published":1,"updated":"2021-06-19T03:46:24.084Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbpc000bbjrjchna0fo9","content":"<p>参考<a href=\"%5Bhttps://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/%5D(https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)\">YYKit作者的博客</a></p>\n<h3 id=\"CPU和GPU的区别\"><a href=\"#CPU和GPU的区别\" class=\"headerlink\" title=\"CPU和GPU的区别\"></a>CPU和GPU的区别</h3><p>CPU(中央处理器 Center Processing Unit)：是计算机的运算、控制、缓存处理核心，常用来处理复杂的逻辑以及数据结构，CPU中的并行其实是通过时间切片完成的。任务之间依赖性高。</p>\n<p>GPU(图形处理器 Graphics Processing Unit)：是一种专门处理绘图运算的微型处理器，在OpenGL中使用GLSL语言来驱动，功能单一，由许多计算单元组成，任务之间依赖性低。</p>\n<hr>\n<h3 id=\"UIView和CALayer的联系与区别\"><a href=\"#UIView和CALayer的联系与区别\" class=\"headerlink\" title=\"UIView和CALayer的联系与区别\"></a>UIView和CALayer的联系与区别</h3><h4 id=\"UIView和CALayer的联系\"><a href=\"#UIView和CALayer的联系\" class=\"headerlink\" title=\"UIView和CALayer的联系\"></a>UIView和CALayer的联系</h4><ul>\n<li>UIView的实力对象中默认有一个属性CALayer</li>\n<li>UIView负责显示内容的管理，CALayer负责具体的显示</li>\n<li>UIView是对CALayer的封装，并实现了CALayer代理的方法</li>\n</ul>\n<h4 id=\"UIView和CALayer的区别\"><a href=\"#UIView和CALayer的区别\" class=\"headerlink\" title=\"UIView和CALayer的区别\"></a>UIView和CALayer的区别</h4><ul>\n<li>UIView继承自UIResponder，CALayer继承自NSObject</li>\n<li>UIView可以响应事件，CALayer不可以</li>\n</ul>\n<h3 id=\"图像显示原理\"><a href=\"#图像显示原理\" class=\"headerlink\" title=\"图像显示原理\"></a>图像显示原理</h3><p>CPU、GPU以及显示器协作完成显示。</p>\n<ol>\n<li><p>早期的显示是<strong>随机扫描显示</strong>,扫描时间和图形复杂度有关。</p>\n</li>\n<li><p>之后出现了<strong>光栅扫描显示</strong>，图像组成了像素阵列，从上到下逐行扫描，和图形复杂度无关。</p>\n</li>\n</ol>\n<ul>\n<li><p>简单的光栅扫描显示由于CPU和GPU的处理复杂程度，会造成GPU扫描显示时，扫描到一半，CPU的数据刷新GPU的缓冲区，显示造成<strong>撕裂</strong>效果。</p>\n</li>\n<li><p>从而引出了 <strong>垂直同步信号Vsync</strong> 和 <strong>双缓冲区</strong> 机制。</p>\n<p><strong>Vsync信号</strong>用来解决<strong>撕裂</strong>问题，相当于给帧缓冲区加了锁，必须扫描显示完一帧才会接收下一帧的数据。</p>\n<p><strong>双缓冲区</strong>用来解决CPU和GPU的处理效率问题。视频控制器读取完缓冲区一帧后，会将指针指向第二个缓冲区。</p>\n<p> 当开启Vsync垂直同步后，GPU会等待显示器的Vsync信号，进行新一帧的渲染和缓冲区的更新，从而需要耗费更多的计算资源，同时也有可能造成<strong>掉帧</strong>现象。<strong>掉帧</strong>是指当接收到Vsync信号时，CPU或GPU还没有准备够足后的数据，视频控制器拿不到Frame Buffer，仍然显示上一帧画面。</p>\n</li>\n<li><p><strong>三级缓存</strong> 和 <strong>Vsync垂直同步</strong>：提供多缓冲区，当Vsync信号出现时有足够的数据去显示，降低<strong>掉帧</strong>出现的概率。</p>\n</li>\n</ul>\n<h3 id=\"产生卡顿的原因\"><a href=\"#产生卡顿的原因\" class=\"headerlink\" title=\"产生卡顿的原因\"></a>产生卡顿的原因</h3><p>CPU负责计算显示的内容，如试图创建、布局计算、图片解码、文本绘制等。CPU计算好之后提交到GPU，由GPU进行一系列处理之后提交到帧缓冲区。当接收到Vsync信号，视频控制器从缓冲区中读取数据。如果在一个Vsync时间内，CPU或GPU没有来得及提交下一帧的数据，视频控制器会显示上一帧的，即界面保持不变，这就是卡顿的原因。</p>\n<p>解决卡顿的方案待理解补充，<a href=\"%5Bhttps://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/%5D(https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)\">YYKit作者的博客</a>写的很详细了。</p>\n<p>有理解不当之处，欢迎指正。\n </p>\n","site":{"data":{}},"excerpt":"","more":"<p>参考<a href=\"%5Bhttps://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/%5D(https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)\">YYKit作者的博客</a></p>\n<h3 id=\"CPU和GPU的区别\"><a href=\"#CPU和GPU的区别\" class=\"headerlink\" title=\"CPU和GPU的区别\"></a>CPU和GPU的区别</h3><p>CPU(中央处理器 Center Processing Unit)：是计算机的运算、控制、缓存处理核心，常用来处理复杂的逻辑以及数据结构，CPU中的并行其实是通过时间切片完成的。任务之间依赖性高。</p>\n<p>GPU(图形处理器 Graphics Processing Unit)：是一种专门处理绘图运算的微型处理器，在OpenGL中使用GLSL语言来驱动，功能单一，由许多计算单元组成，任务之间依赖性低。</p>\n<hr>\n<h3 id=\"UIView和CALayer的联系与区别\"><a href=\"#UIView和CALayer的联系与区别\" class=\"headerlink\" title=\"UIView和CALayer的联系与区别\"></a>UIView和CALayer的联系与区别</h3><h4 id=\"UIView和CALayer的联系\"><a href=\"#UIView和CALayer的联系\" class=\"headerlink\" title=\"UIView和CALayer的联系\"></a>UIView和CALayer的联系</h4><ul>\n<li>UIView的实力对象中默认有一个属性CALayer</li>\n<li>UIView负责显示内容的管理，CALayer负责具体的显示</li>\n<li>UIView是对CALayer的封装，并实现了CALayer代理的方法</li>\n</ul>\n<h4 id=\"UIView和CALayer的区别\"><a href=\"#UIView和CALayer的区别\" class=\"headerlink\" title=\"UIView和CALayer的区别\"></a>UIView和CALayer的区别</h4><ul>\n<li>UIView继承自UIResponder，CALayer继承自NSObject</li>\n<li>UIView可以响应事件，CALayer不可以</li>\n</ul>\n<h3 id=\"图像显示原理\"><a href=\"#图像显示原理\" class=\"headerlink\" title=\"图像显示原理\"></a>图像显示原理</h3><p>CPU、GPU以及显示器协作完成显示。</p>\n<ol>\n<li><p>早期的显示是<strong>随机扫描显示</strong>,扫描时间和图形复杂度有关。</p>\n</li>\n<li><p>之后出现了<strong>光栅扫描显示</strong>，图像组成了像素阵列，从上到下逐行扫描，和图形复杂度无关。</p>\n</li>\n</ol>\n<ul>\n<li><p>简单的光栅扫描显示由于CPU和GPU的处理复杂程度，会造成GPU扫描显示时，扫描到一半，CPU的数据刷新GPU的缓冲区，显示造成<strong>撕裂</strong>效果。</p>\n</li>\n<li><p>从而引出了 <strong>垂直同步信号Vsync</strong> 和 <strong>双缓冲区</strong> 机制。</p>\n<p><strong>Vsync信号</strong>用来解决<strong>撕裂</strong>问题，相当于给帧缓冲区加了锁，必须扫描显示完一帧才会接收下一帧的数据。</p>\n<p><strong>双缓冲区</strong>用来解决CPU和GPU的处理效率问题。视频控制器读取完缓冲区一帧后，会将指针指向第二个缓冲区。</p>\n<p> 当开启Vsync垂直同步后，GPU会等待显示器的Vsync信号，进行新一帧的渲染和缓冲区的更新，从而需要耗费更多的计算资源，同时也有可能造成<strong>掉帧</strong>现象。<strong>掉帧</strong>是指当接收到Vsync信号时，CPU或GPU还没有准备够足后的数据，视频控制器拿不到Frame Buffer，仍然显示上一帧画面。</p>\n</li>\n<li><p><strong>三级缓存</strong> 和 <strong>Vsync垂直同步</strong>：提供多缓冲区，当Vsync信号出现时有足够的数据去显示，降低<strong>掉帧</strong>出现的概率。</p>\n</li>\n</ul>\n<h3 id=\"产生卡顿的原因\"><a href=\"#产生卡顿的原因\" class=\"headerlink\" title=\"产生卡顿的原因\"></a>产生卡顿的原因</h3><p>CPU负责计算显示的内容，如试图创建、布局计算、图片解码、文本绘制等。CPU计算好之后提交到GPU，由GPU进行一系列处理之后提交到帧缓冲区。当接收到Vsync信号，视频控制器从缓冲区中读取数据。如果在一个Vsync时间内，CPU或GPU没有来得及提交下一帧的数据，视频控制器会显示上一帧的，即界面保持不变，这就是卡顿的原因。</p>\n<p>解决卡顿的方案待理解补充，<a href=\"%5Bhttps://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/%5D(https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)\">YYKit作者的博客</a>写的很详细了。</p>\n<p>有理解不当之处，欢迎指正。\n </p>\n"},{"title":"OpenGL渲染架构","date":"2020-07-06T16:00:00.000Z","_content":"\n##### OpenGL的渲染架构图\n![image.png](https://upload-images.jianshu.io/upload_images/1395687-267fdf98b61c2884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n##### OpenGL渲染主架构\n\nOpenGL渲染架构分为**客户端(Client)**和**服务端(Server)**。\n\n**客户端**主要指CPU中运行的代码，包括C/C++代码以及OpenGL的相关代码。\n\n**服务端**指的是调用GPU芯片。\n\n开发过程中就是不断执行CPU中的代码，通过交互通道传递数据给服务端，间接的驱动GPU。\n\n##### 交互通道\n\nOpenGL提供了三个通道向GPU传递数据，分别是`Attributes(属性通道)`、`Uniform(统一变量通道)`、`Texture Data(纹理通道)`。\n\n`Attributes(属性通道)`：只能够向顶点着色器传递数据，不过可以间接的通过属性通道向片元着色器传递数据。主要传递经常变化的数据，如颜色数据，顶点数据，纹理坐标，光照法线等数据。\n\n`Uniform(统一变量通道)`：可以向顶点着色器和片元着色器传递数据。通常用来传递不变的数据，如变换矩阵、模型矩阵、平移/旋转/缩放矩阵等。\n\n`Texture Data(纹理通道)`：虽然可以向顶点着色器和片元着色器传递数据，但传递到顶点着色器是没有意义的，因为纹理处理主要是在片元着色器中。主要用来传递纹理数据。\n\n\n参考[OpenGL初探之了解OpenGL渲染架构]([https://juejin.im/post/5d67e4cef265da03dc0783a1](https://juejin.im/post/5d67e4cef265da03dc0783a1)\n)","source":"_posts/2020-07-07-OpenGL架构.markdown","raw":"---\ntitle:      \"OpenGL渲染架构\" \ndate:       2020-07-07\ntags:\n    - OpenGL \ncategories:\n    - OpenGL \n---\n\n##### OpenGL的渲染架构图\n![image.png](https://upload-images.jianshu.io/upload_images/1395687-267fdf98b61c2884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n##### OpenGL渲染主架构\n\nOpenGL渲染架构分为**客户端(Client)**和**服务端(Server)**。\n\n**客户端**主要指CPU中运行的代码，包括C/C++代码以及OpenGL的相关代码。\n\n**服务端**指的是调用GPU芯片。\n\n开发过程中就是不断执行CPU中的代码，通过交互通道传递数据给服务端，间接的驱动GPU。\n\n##### 交互通道\n\nOpenGL提供了三个通道向GPU传递数据，分别是`Attributes(属性通道)`、`Uniform(统一变量通道)`、`Texture Data(纹理通道)`。\n\n`Attributes(属性通道)`：只能够向顶点着色器传递数据，不过可以间接的通过属性通道向片元着色器传递数据。主要传递经常变化的数据，如颜色数据，顶点数据，纹理坐标，光照法线等数据。\n\n`Uniform(统一变量通道)`：可以向顶点着色器和片元着色器传递数据。通常用来传递不变的数据，如变换矩阵、模型矩阵、平移/旋转/缩放矩阵等。\n\n`Texture Data(纹理通道)`：虽然可以向顶点着色器和片元着色器传递数据，但传递到顶点着色器是没有意义的，因为纹理处理主要是在片元着色器中。主要用来传递纹理数据。\n\n\n参考[OpenGL初探之了解OpenGL渲染架构]([https://juejin.im/post/5d67e4cef265da03dc0783a1](https://juejin.im/post/5d67e4cef265da03dc0783a1)\n)","slug":"2020-07-07-OpenGL架构","published":1,"updated":"2021-06-19T03:46:24.084Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbpe000gbjrjemz5hd90","content":"<h5 id=\"OpenGL的渲染架构图\"><a href=\"#OpenGL的渲染架构图\" class=\"headerlink\" title=\"OpenGL的渲染架构图\"></a>OpenGL的渲染架构图</h5><p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-267fdf98b61c2884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h5 id=\"OpenGL渲染主架构\"><a href=\"#OpenGL渲染主架构\" class=\"headerlink\" title=\"OpenGL渲染主架构\"></a>OpenGL渲染主架构</h5><p>OpenGL渲染架构分为**客户端(Client)<strong>和</strong>服务端(Server)**。</p>\n<p><strong>客户端</strong>主要指CPU中运行的代码，包括C/C++代码以及OpenGL的相关代码。</p>\n<p><strong>服务端</strong>指的是调用GPU芯片。</p>\n<p>开发过程中就是不断执行CPU中的代码，通过交互通道传递数据给服务端，间接的驱动GPU。</p>\n<h5 id=\"交互通道\"><a href=\"#交互通道\" class=\"headerlink\" title=\"交互通道\"></a>交互通道</h5><p>OpenGL提供了三个通道向GPU传递数据，分别是<code>Attributes(属性通道)</code>、<code>Uniform(统一变量通道)</code>、<code>Texture Data(纹理通道)</code>。</p>\n<p><code>Attributes(属性通道)</code>：只能够向顶点着色器传递数据，不过可以间接的通过属性通道向片元着色器传递数据。主要传递经常变化的数据，如颜色数据，顶点数据，纹理坐标，光照法线等数据。</p>\n<p><code>Uniform(统一变量通道)</code>：可以向顶点着色器和片元着色器传递数据。通常用来传递不变的数据，如变换矩阵、模型矩阵、平移/旋转/缩放矩阵等。</p>\n<p><code>Texture Data(纹理通道)</code>：虽然可以向顶点着色器和片元着色器传递数据，但传递到顶点着色器是没有意义的，因为纹理处理主要是在片元着色器中。主要用来传递纹理数据。</p>\n<p>参考<a href=\"%5Bhttps://juejin.im/post/5d67e4cef265da03dc0783a1%5D(https://juejin.im/post/5d67e4cef265da03dc0783a1)\">OpenGL初探之了解OpenGL渲染架构</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"OpenGL的渲染架构图\"><a href=\"#OpenGL的渲染架构图\" class=\"headerlink\" title=\"OpenGL的渲染架构图\"></a>OpenGL的渲染架构图</h5><p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-267fdf98b61c2884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h5 id=\"OpenGL渲染主架构\"><a href=\"#OpenGL渲染主架构\" class=\"headerlink\" title=\"OpenGL渲染主架构\"></a>OpenGL渲染主架构</h5><p>OpenGL渲染架构分为**客户端(Client)<strong>和</strong>服务端(Server)**。</p>\n<p><strong>客户端</strong>主要指CPU中运行的代码，包括C/C++代码以及OpenGL的相关代码。</p>\n<p><strong>服务端</strong>指的是调用GPU芯片。</p>\n<p>开发过程中就是不断执行CPU中的代码，通过交互通道传递数据给服务端，间接的驱动GPU。</p>\n<h5 id=\"交互通道\"><a href=\"#交互通道\" class=\"headerlink\" title=\"交互通道\"></a>交互通道</h5><p>OpenGL提供了三个通道向GPU传递数据，分别是<code>Attributes(属性通道)</code>、<code>Uniform(统一变量通道)</code>、<code>Texture Data(纹理通道)</code>。</p>\n<p><code>Attributes(属性通道)</code>：只能够向顶点着色器传递数据，不过可以间接的通过属性通道向片元着色器传递数据。主要传递经常变化的数据，如颜色数据，顶点数据，纹理坐标，光照法线等数据。</p>\n<p><code>Uniform(统一变量通道)</code>：可以向顶点着色器和片元着色器传递数据。通常用来传递不变的数据，如变换矩阵、模型矩阵、平移/旋转/缩放矩阵等。</p>\n<p><code>Texture Data(纹理通道)</code>：虽然可以向顶点着色器和片元着色器传递数据，但传递到顶点着色器是没有意义的，因为纹理处理主要是在片元着色器中。主要用来传递纹理数据。</p>\n<p>参考<a href=\"%5Bhttps://juejin.im/post/5d67e4cef265da03dc0783a1%5D(https://juejin.im/post/5d67e4cef265da03dc0783a1)\">OpenGL初探之了解OpenGL渲染架构</a></p>\n"},{"title":"iOS离屏渲染解析","date":"2020-07-06T16:00:00.000Z","_content":"\n#### iOS渲染层级\n![image.png](https://upload-images.jianshu.io/upload_images/1395687-fe1ebb709a67ec63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nCoreAnimation核心动画是由Layer Kit演变而来，所以它并不是只能做关于动画方面的，它可以理解为一个复合引擎，目的是更快的组合屏幕上不同的显示内容。\n\n#### 离屏渲染的定义\n\n- 没有离屏渲染时：\n\n![image.png](https://upload-images.jianshu.io/upload_images/1395687-659cbf151a302125.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nApp通过CPU和GPU的配合，将渲染数据放入帧缓冲区，视频控制器不断的从帧缓冲区取出数据显示到显示屏上。\n\n\n- 离屏渲染时：\n\n![image.png](https://upload-images.jianshu.io/upload_images/1395687-d2ac9771c8d44dd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n和未发生离屏渲染时相比，App并不是直接将数据放入帧缓冲区，而是额外先开辟一个离屏缓冲区(Offscreen Buffer)，在离屏缓冲区将渲染内容进行额外渲染和合并之后，再将数据送入帧缓冲区。\n\n> Offscreen Buffer存储最大限制为屏幕像素的2.5倍\n\n#### 理解圆角CornerRadius和离屏渲染的关系\n\n###### 问题：`btn.layer.cornerRadius = 5; btn.layer.maskToBounds = YES;`一定会触发离屏渲染吗？\n\nCornerRadius的官方文档解释：只对layer的background和border起作用，并不会作用于contents。但是设置`masksToBounds `对应UIView的`clipsToBounds `则会对内容进行裁剪。\n\n```\nSetting the radius to a value greater than 0.0 causes the layer to begin drawing           \nrounded corners on its background. By default, the corner radius does not apply \nto the image in the layer’s contents property; it applies only to the background \ncolor and border of the layer. However, setting the masksToBounds property to \nYES causes the content to be clipped to the rounded corners.\n```\n\n案例1:按钮设置图片 即在按钮上添加一个ImageView，则有两个图层，做圆角需要对两个图层进行裁剪，则会触发离屏渲染。\n\n```\n    UIButton *btn1 = [UIButton buttonWithType:UIButtonTypeCustom];\n    btn1.frame = CGRectMake(100, 30, 100, 100);\n    btn1.layer.cornerRadius = 50;\n    [self.view addSubview:btn1];\n    \n    [btn1 setImage:[UIImage imageNamed:@\"btn.png\"] forState:UIControlStateNormal];\n    btn1.clipsToBounds = YES;\n```\n\n案例2:按钮添加背景色、设置border，仍然只有按钮一个图层做圆角，并不会触发离屏渲染。\n\n```\n    UIButton *btn2 = [UIButton buttonWithType:UIButtonTypeCustom];\n    btn2.frame = CGRectMake(100, 180, 100, 100);\n    btn2.layer.cornerRadius = 50;\n    btn2.backgroundColor = [UIColor blueColor];\n    [self.view addSubview:btn2];\n    btn2.clipsToBounds = YES;\n```\n\n案例3:ImageView设置图片和背景色，两个图层做圆角，则会触发离屏渲染。\n\n```\n    UIImageView *img1 = [[UIImageView alloc]init];\n    img1.frame = CGRectMake(100, 320, 100, 100);\n    img1.backgroundColor = [UIColor blueColor];\n    [self.view addSubview:img1];\n    img1.layer.cornerRadius = 50;\n    img1.layer.masksToBounds = YES;\n    img1.image = [UIImage imageNamed:@\"btn.png\"];\n```\n\n案例4:ImageView只设置图片，只有一个图层做圆角则不会触发离屏渲染。\n\n```\n    UIImageView *img2 = [[UIImageView alloc]init];\n    img2.frame = CGRectMake(100, 480, 100, 100);\n    [self.view addSubview:img2];\n    img2.layer.cornerRadius = 50;\n    img2.layer.masksToBounds = YES;\n    img2.image = [UIImage imageNamed:@\"btn.png\"];\n```\n\n常见对触发离屏渲染的几种情况：\n \n - 使用了mask的layer (layer.mast)\n\n - 需要进行裁剪的layer (layer.mastToBounds / view.clipToBounds)\n\n - 设置了组透明度为YES，并且透明度不为1的layer (layer.allowsGroupOpacity / layer.opacity)\n\n - 添加了阴影的layer (layer.shadow)\n\n - 采用了光栅化的layer (layer.shouldRasterize)\n\n - 绘制了文字的layer (UILabel, CATextLayer, Core Text 等)\n\n总结：离屏渲染出现原因是由于多个图层需要进行裁剪/混合等处理，需要放入offscreen buffer所造成的。我理解的这里的一个图层并不等于一个CALayer，一个CALayer可以包含多个图层。\n\n#### 离屏渲染产生的问题\n\n - APP需要额外的开辟Offscreen Buffer空间，大量的离屏渲染可能造成内存的压力。\n - 需要在Offscreen Buffer和Frame Buffer之前进行频繁切换，需要长时间的处理\n\n对应的造成**性能问题**以及**掉帧**。\n\n#### 需要使用离屏渲染的场景\n\n - 特殊效果：需要使用offscreen Buffer保存中间状态，不得不使用离屏渲染，此时由系统自动触发，如圆角、阴影、组透明度等。\n\n- 提升效率：重复的、静态的资源打开光栅化(shouldRasterize)可以节约之后渲染的时间。打开光栅化需要注意以下几点：\n \n   + 如果layer不能复用，则没有必要打开光栅化。\n\n   + 如果layer不是静态的，需要被频繁修改。比如动画，打开光栅化反而影响效率。\n\n    + 离屏渲染缓存内容有时间限制，如果超过100ms没有被使用，则被丢弃，无法复用。\n\n    + 离屏渲染缓存空间最大为屏幕像素的2.5倍，超过则则会失效，无法复用。\n","source":"_posts/2020-07-07-iOS离屏渲染解析.markdown","raw":"---\ntitle:      \"iOS离屏渲染解析\" \ndate:       2020-07-07\ntags:\n    - iOS \ncategories:\n    - iOS \n---\n\n#### iOS渲染层级\n![image.png](https://upload-images.jianshu.io/upload_images/1395687-fe1ebb709a67ec63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nCoreAnimation核心动画是由Layer Kit演变而来，所以它并不是只能做关于动画方面的，它可以理解为一个复合引擎，目的是更快的组合屏幕上不同的显示内容。\n\n#### 离屏渲染的定义\n\n- 没有离屏渲染时：\n\n![image.png](https://upload-images.jianshu.io/upload_images/1395687-659cbf151a302125.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nApp通过CPU和GPU的配合，将渲染数据放入帧缓冲区，视频控制器不断的从帧缓冲区取出数据显示到显示屏上。\n\n\n- 离屏渲染时：\n\n![image.png](https://upload-images.jianshu.io/upload_images/1395687-d2ac9771c8d44dd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n和未发生离屏渲染时相比，App并不是直接将数据放入帧缓冲区，而是额外先开辟一个离屏缓冲区(Offscreen Buffer)，在离屏缓冲区将渲染内容进行额外渲染和合并之后，再将数据送入帧缓冲区。\n\n> Offscreen Buffer存储最大限制为屏幕像素的2.5倍\n\n#### 理解圆角CornerRadius和离屏渲染的关系\n\n###### 问题：`btn.layer.cornerRadius = 5; btn.layer.maskToBounds = YES;`一定会触发离屏渲染吗？\n\nCornerRadius的官方文档解释：只对layer的background和border起作用，并不会作用于contents。但是设置`masksToBounds `对应UIView的`clipsToBounds `则会对内容进行裁剪。\n\n```\nSetting the radius to a value greater than 0.0 causes the layer to begin drawing           \nrounded corners on its background. By default, the corner radius does not apply \nto the image in the layer’s contents property; it applies only to the background \ncolor and border of the layer. However, setting the masksToBounds property to \nYES causes the content to be clipped to the rounded corners.\n```\n\n案例1:按钮设置图片 即在按钮上添加一个ImageView，则有两个图层，做圆角需要对两个图层进行裁剪，则会触发离屏渲染。\n\n```\n    UIButton *btn1 = [UIButton buttonWithType:UIButtonTypeCustom];\n    btn1.frame = CGRectMake(100, 30, 100, 100);\n    btn1.layer.cornerRadius = 50;\n    [self.view addSubview:btn1];\n    \n    [btn1 setImage:[UIImage imageNamed:@\"btn.png\"] forState:UIControlStateNormal];\n    btn1.clipsToBounds = YES;\n```\n\n案例2:按钮添加背景色、设置border，仍然只有按钮一个图层做圆角，并不会触发离屏渲染。\n\n```\n    UIButton *btn2 = [UIButton buttonWithType:UIButtonTypeCustom];\n    btn2.frame = CGRectMake(100, 180, 100, 100);\n    btn2.layer.cornerRadius = 50;\n    btn2.backgroundColor = [UIColor blueColor];\n    [self.view addSubview:btn2];\n    btn2.clipsToBounds = YES;\n```\n\n案例3:ImageView设置图片和背景色，两个图层做圆角，则会触发离屏渲染。\n\n```\n    UIImageView *img1 = [[UIImageView alloc]init];\n    img1.frame = CGRectMake(100, 320, 100, 100);\n    img1.backgroundColor = [UIColor blueColor];\n    [self.view addSubview:img1];\n    img1.layer.cornerRadius = 50;\n    img1.layer.masksToBounds = YES;\n    img1.image = [UIImage imageNamed:@\"btn.png\"];\n```\n\n案例4:ImageView只设置图片，只有一个图层做圆角则不会触发离屏渲染。\n\n```\n    UIImageView *img2 = [[UIImageView alloc]init];\n    img2.frame = CGRectMake(100, 480, 100, 100);\n    [self.view addSubview:img2];\n    img2.layer.cornerRadius = 50;\n    img2.layer.masksToBounds = YES;\n    img2.image = [UIImage imageNamed:@\"btn.png\"];\n```\n\n常见对触发离屏渲染的几种情况：\n \n - 使用了mask的layer (layer.mast)\n\n - 需要进行裁剪的layer (layer.mastToBounds / view.clipToBounds)\n\n - 设置了组透明度为YES，并且透明度不为1的layer (layer.allowsGroupOpacity / layer.opacity)\n\n - 添加了阴影的layer (layer.shadow)\n\n - 采用了光栅化的layer (layer.shouldRasterize)\n\n - 绘制了文字的layer (UILabel, CATextLayer, Core Text 等)\n\n总结：离屏渲染出现原因是由于多个图层需要进行裁剪/混合等处理，需要放入offscreen buffer所造成的。我理解的这里的一个图层并不等于一个CALayer，一个CALayer可以包含多个图层。\n\n#### 离屏渲染产生的问题\n\n - APP需要额外的开辟Offscreen Buffer空间，大量的离屏渲染可能造成内存的压力。\n - 需要在Offscreen Buffer和Frame Buffer之前进行频繁切换，需要长时间的处理\n\n对应的造成**性能问题**以及**掉帧**。\n\n#### 需要使用离屏渲染的场景\n\n - 特殊效果：需要使用offscreen Buffer保存中间状态，不得不使用离屏渲染，此时由系统自动触发，如圆角、阴影、组透明度等。\n\n- 提升效率：重复的、静态的资源打开光栅化(shouldRasterize)可以节约之后渲染的时间。打开光栅化需要注意以下几点：\n \n   + 如果layer不能复用，则没有必要打开光栅化。\n\n   + 如果layer不是静态的，需要被频繁修改。比如动画，打开光栅化反而影响效率。\n\n    + 离屏渲染缓存内容有时间限制，如果超过100ms没有被使用，则被丢弃，无法复用。\n\n    + 离屏渲染缓存空间最大为屏幕像素的2.5倍，超过则则会失效，无法复用。\n","slug":"2020-07-07-iOS离屏渲染解析","published":1,"updated":"2021-06-19T03:46:24.084Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbpf000ibjrj2e6g7m7w","content":"<h4 id=\"iOS渲染层级\"><a href=\"#iOS渲染层级\" class=\"headerlink\" title=\"iOS渲染层级\"></a>iOS渲染层级</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-fe1ebb709a67ec63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>CoreAnimation核心动画是由Layer Kit演变而来，所以它并不是只能做关于动画方面的，它可以理解为一个复合引擎，目的是更快的组合屏幕上不同的显示内容。</p>\n<h4 id=\"离屏渲染的定义\"><a href=\"#离屏渲染的定义\" class=\"headerlink\" title=\"离屏渲染的定义\"></a>离屏渲染的定义</h4><ul>\n<li>没有离屏渲染时：</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-659cbf151a302125.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>App通过CPU和GPU的配合，将渲染数据放入帧缓冲区，视频控制器不断的从帧缓冲区取出数据显示到显示屏上。</p>\n<ul>\n<li>离屏渲染时：</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-d2ac9771c8d44dd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>和未发生离屏渲染时相比，App并不是直接将数据放入帧缓冲区，而是额外先开辟一个离屏缓冲区(Offscreen Buffer)，在离屏缓冲区将渲染内容进行额外渲染和合并之后，再将数据送入帧缓冲区。</p>\n<blockquote>\n<p>Offscreen Buffer存储最大限制为屏幕像素的2.5倍</p>\n</blockquote>\n<h4 id=\"理解圆角CornerRadius和离屏渲染的关系\"><a href=\"#理解圆角CornerRadius和离屏渲染的关系\" class=\"headerlink\" title=\"理解圆角CornerRadius和离屏渲染的关系\"></a>理解圆角CornerRadius和离屏渲染的关系</h4><h6 id=\"问题：btn-layer-cornerRadius-5-btn-layer-maskToBounds-YES-一定会触发离屏渲染吗？\"><a href=\"#问题：btn-layer-cornerRadius-5-btn-layer-maskToBounds-YES-一定会触发离屏渲染吗？\" class=\"headerlink\" title=\"问题：btn.layer.cornerRadius = 5; btn.layer.maskToBounds = YES;一定会触发离屏渲染吗？\"></a>问题：<code>btn.layer.cornerRadius = 5; btn.layer.maskToBounds = YES;</code>一定会触发离屏渲染吗？</h6><p>CornerRadius的官方文档解释：只对layer的background和border起作用，并不会作用于contents。但是设置<code>masksToBounds </code>对应UIView的<code>clipsToBounds </code>则会对内容进行裁剪。</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Setting <span class=\"keyword\">the</span> radius <span class=\"built_in\">to</span> <span class=\"keyword\">a</span> <span class=\"built_in\">value</span> greater than <span class=\"number\">0.0</span> causes <span class=\"keyword\">the</span> layer <span class=\"built_in\">to</span> begin drawing           </span><br><span class=\"line\">rounded corners <span class=\"keyword\">on</span> <span class=\"title\">its</span> <span class=\"title\">background</span>. <span class=\"title\">By</span> <span class=\"title\">default</span>, <span class=\"title\">the</span> <span class=\"title\">corner</span> <span class=\"title\">radius</span> <span class=\"title\">does</span> <span class=\"title\">not</span> <span class=\"title\">apply</span> </span><br><span class=\"line\"><span class=\"built_in\">to</span> <span class=\"keyword\">the</span> image <span class=\"keyword\">in</span> <span class=\"keyword\">the</span> layer’s contents property; <span class=\"keyword\">it</span> applies only <span class=\"built_in\">to</span> <span class=\"keyword\">the</span> background </span><br><span class=\"line\">color <span class=\"keyword\">and</span> border <span class=\"keyword\">of</span> <span class=\"keyword\">the</span> layer. However, setting <span class=\"keyword\">the</span> masksToBounds property <span class=\"built_in\">to</span> </span><br><span class=\"line\">YES causes <span class=\"keyword\">the</span> content <span class=\"built_in\">to</span> be clipped <span class=\"built_in\">to</span> <span class=\"keyword\">the</span> rounded corners.</span><br></pre></td></tr></table></figure>\n\n<p>案例1:按钮设置图片 即在按钮上添加一个ImageView，则有两个图层，做圆角需要对两个图层进行裁剪，则会触发离屏渲染。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIButton</span> *btn1 = [<span class=\"built_in\">UIButton</span> buttonWithType:<span class=\"built_in\">UIButtonTypeCustom</span>];</span><br><span class=\"line\">btn1.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">100</span>, <span class=\"number\">30</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">btn1.layer.cornerRadius = <span class=\"number\">50</span>;</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:btn1];</span><br><span class=\"line\"></span><br><span class=\"line\">[btn1 setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@&quot;btn.png&quot;</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">btn1.clipsToBounds = <span class=\"literal\">YES</span>;</span><br></pre></td></tr></table></figure>\n\n<p>案例2:按钮添加背景色、设置border，仍然只有按钮一个图层做圆角，并不会触发离屏渲染。</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIButton *<span class=\"keyword\">btn2 </span>= [UIButton <span class=\"keyword\">buttonWithType:UIButtonTypeCustom];</span></span><br><span class=\"line\"><span class=\"keyword\">btn2.frame </span>= CGRectMake(<span class=\"number\">100</span>, <span class=\"number\">180</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"keyword\">btn2.layer.cornerRadius </span>= <span class=\"number\">50</span>;</span><br><span class=\"line\"><span class=\"keyword\">btn2.backgroundColor </span>= [UIColor <span class=\"keyword\">blueColor];</span></span><br><span class=\"line\"><span class=\"keyword\">[self.view </span><span class=\"keyword\">addSubview:btn2];</span></span><br><span class=\"line\"><span class=\"keyword\">btn2.clipsToBounds </span>= YES;</span><br></pre></td></tr></table></figure>\n\n<p>案例3:ImageView设置图片和背景色，两个图层做圆角，则会触发离屏渲染。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIImageView</span> *img1 = [[<span class=\"built_in\">UIImageView</span> alloc]init];</span><br><span class=\"line\">img1.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">100</span>, <span class=\"number\">320</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">img1.backgroundColor = [<span class=\"built_in\">UIColor</span> blueColor];</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:img1];</span><br><span class=\"line\">img1.layer.cornerRadius = <span class=\"number\">50</span>;</span><br><span class=\"line\">img1.layer.masksToBounds = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">img1.image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@&quot;btn.png&quot;</span>];</span><br></pre></td></tr></table></figure>\n\n<p>案例4:ImageView只设置图片，只有一个图层做圆角则不会触发离屏渲染。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIImageView</span> *img2 = [[<span class=\"built_in\">UIImageView</span> alloc]init];</span><br><span class=\"line\">img2.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">100</span>, <span class=\"number\">480</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:img2];</span><br><span class=\"line\">img2.layer.cornerRadius = <span class=\"number\">50</span>;</span><br><span class=\"line\">img2.layer.masksToBounds = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">img2.image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@&quot;btn.png&quot;</span>];</span><br></pre></td></tr></table></figure>\n\n<p>常见对触发离屏渲染的几种情况：</p>\n<ul>\n<li><p>使用了mask的layer (layer.mast)</p>\n</li>\n<li><p>需要进行裁剪的layer (layer.mastToBounds / view.clipToBounds)</p>\n</li>\n<li><p>设置了组透明度为YES，并且透明度不为1的layer (layer.allowsGroupOpacity / layer.opacity)</p>\n</li>\n<li><p>添加了阴影的layer (layer.shadow)</p>\n</li>\n<li><p>采用了光栅化的layer (layer.shouldRasterize)</p>\n</li>\n<li><p>绘制了文字的layer (UILabel, CATextLayer, Core Text 等)</p>\n</li>\n</ul>\n<p>总结：离屏渲染出现原因是由于多个图层需要进行裁剪/混合等处理，需要放入offscreen buffer所造成的。我理解的这里的一个图层并不等于一个CALayer，一个CALayer可以包含多个图层。</p>\n<h4 id=\"离屏渲染产生的问题\"><a href=\"#离屏渲染产生的问题\" class=\"headerlink\" title=\"离屏渲染产生的问题\"></a>离屏渲染产生的问题</h4><ul>\n<li>APP需要额外的开辟Offscreen Buffer空间，大量的离屏渲染可能造成内存的压力。</li>\n<li>需要在Offscreen Buffer和Frame Buffer之前进行频繁切换，需要长时间的处理</li>\n</ul>\n<p>对应的造成<strong>性能问题</strong>以及<strong>掉帧</strong>。</p>\n<h4 id=\"需要使用离屏渲染的场景\"><a href=\"#需要使用离屏渲染的场景\" class=\"headerlink\" title=\"需要使用离屏渲染的场景\"></a>需要使用离屏渲染的场景</h4><ul>\n<li><p>特殊效果：需要使用offscreen Buffer保存中间状态，不得不使用离屏渲染，此时由系统自动触发，如圆角、阴影、组透明度等。</p>\n</li>\n<li><p>提升效率：重复的、静态的资源打开光栅化(shouldRasterize)可以节约之后渲染的时间。打开光栅化需要注意以下几点：</p>\n<ul>\n<li><p>如果layer不能复用，则没有必要打开光栅化。</p>\n</li>\n<li><p>如果layer不是静态的，需要被频繁修改。比如动画，打开光栅化反而影响效率。</p>\n</li>\n<li><p>离屏渲染缓存内容有时间限制，如果超过100ms没有被使用，则被丢弃，无法复用。</p>\n</li>\n<li><p>离屏渲染缓存空间最大为屏幕像素的2.5倍，超过则则会失效，无法复用。</p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"iOS渲染层级\"><a href=\"#iOS渲染层级\" class=\"headerlink\" title=\"iOS渲染层级\"></a>iOS渲染层级</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-fe1ebb709a67ec63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>CoreAnimation核心动画是由Layer Kit演变而来，所以它并不是只能做关于动画方面的，它可以理解为一个复合引擎，目的是更快的组合屏幕上不同的显示内容。</p>\n<h4 id=\"离屏渲染的定义\"><a href=\"#离屏渲染的定义\" class=\"headerlink\" title=\"离屏渲染的定义\"></a>离屏渲染的定义</h4><ul>\n<li>没有离屏渲染时：</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-659cbf151a302125.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>App通过CPU和GPU的配合，将渲染数据放入帧缓冲区，视频控制器不断的从帧缓冲区取出数据显示到显示屏上。</p>\n<ul>\n<li>离屏渲染时：</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-d2ac9771c8d44dd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>和未发生离屏渲染时相比，App并不是直接将数据放入帧缓冲区，而是额外先开辟一个离屏缓冲区(Offscreen Buffer)，在离屏缓冲区将渲染内容进行额外渲染和合并之后，再将数据送入帧缓冲区。</p>\n<blockquote>\n<p>Offscreen Buffer存储最大限制为屏幕像素的2.5倍</p>\n</blockquote>\n<h4 id=\"理解圆角CornerRadius和离屏渲染的关系\"><a href=\"#理解圆角CornerRadius和离屏渲染的关系\" class=\"headerlink\" title=\"理解圆角CornerRadius和离屏渲染的关系\"></a>理解圆角CornerRadius和离屏渲染的关系</h4><h6 id=\"问题：btn-layer-cornerRadius-5-btn-layer-maskToBounds-YES-一定会触发离屏渲染吗？\"><a href=\"#问题：btn-layer-cornerRadius-5-btn-layer-maskToBounds-YES-一定会触发离屏渲染吗？\" class=\"headerlink\" title=\"问题：btn.layer.cornerRadius = 5; btn.layer.maskToBounds = YES;一定会触发离屏渲染吗？\"></a>问题：<code>btn.layer.cornerRadius = 5; btn.layer.maskToBounds = YES;</code>一定会触发离屏渲染吗？</h6><p>CornerRadius的官方文档解释：只对layer的background和border起作用，并不会作用于contents。但是设置<code>masksToBounds </code>对应UIView的<code>clipsToBounds </code>则会对内容进行裁剪。</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Setting <span class=\"keyword\">the</span> radius <span class=\"built_in\">to</span> <span class=\"keyword\">a</span> <span class=\"built_in\">value</span> greater than <span class=\"number\">0.0</span> causes <span class=\"keyword\">the</span> layer <span class=\"built_in\">to</span> begin drawing           </span><br><span class=\"line\">rounded corners <span class=\"keyword\">on</span> <span class=\"title\">its</span> <span class=\"title\">background</span>. <span class=\"title\">By</span> <span class=\"title\">default</span>, <span class=\"title\">the</span> <span class=\"title\">corner</span> <span class=\"title\">radius</span> <span class=\"title\">does</span> <span class=\"title\">not</span> <span class=\"title\">apply</span> </span><br><span class=\"line\"><span class=\"built_in\">to</span> <span class=\"keyword\">the</span> image <span class=\"keyword\">in</span> <span class=\"keyword\">the</span> layer’s contents property; <span class=\"keyword\">it</span> applies only <span class=\"built_in\">to</span> <span class=\"keyword\">the</span> background </span><br><span class=\"line\">color <span class=\"keyword\">and</span> border <span class=\"keyword\">of</span> <span class=\"keyword\">the</span> layer. However, setting <span class=\"keyword\">the</span> masksToBounds property <span class=\"built_in\">to</span> </span><br><span class=\"line\">YES causes <span class=\"keyword\">the</span> content <span class=\"built_in\">to</span> be clipped <span class=\"built_in\">to</span> <span class=\"keyword\">the</span> rounded corners.</span><br></pre></td></tr></table></figure>\n\n<p>案例1:按钮设置图片 即在按钮上添加一个ImageView，则有两个图层，做圆角需要对两个图层进行裁剪，则会触发离屏渲染。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIButton</span> *btn1 = [<span class=\"built_in\">UIButton</span> buttonWithType:<span class=\"built_in\">UIButtonTypeCustom</span>];</span><br><span class=\"line\">btn1.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">100</span>, <span class=\"number\">30</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">btn1.layer.cornerRadius = <span class=\"number\">50</span>;</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:btn1];</span><br><span class=\"line\"></span><br><span class=\"line\">[btn1 setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@&quot;btn.png&quot;</span>] forState:<span class=\"built_in\">UIControlStateNormal</span>];</span><br><span class=\"line\">btn1.clipsToBounds = <span class=\"literal\">YES</span>;</span><br></pre></td></tr></table></figure>\n\n<p>案例2:按钮添加背景色、设置border，仍然只有按钮一个图层做圆角，并不会触发离屏渲染。</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIButton *<span class=\"keyword\">btn2 </span>= [UIButton <span class=\"keyword\">buttonWithType:UIButtonTypeCustom];</span></span><br><span class=\"line\"><span class=\"keyword\">btn2.frame </span>= CGRectMake(<span class=\"number\">100</span>, <span class=\"number\">180</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"keyword\">btn2.layer.cornerRadius </span>= <span class=\"number\">50</span>;</span><br><span class=\"line\"><span class=\"keyword\">btn2.backgroundColor </span>= [UIColor <span class=\"keyword\">blueColor];</span></span><br><span class=\"line\"><span class=\"keyword\">[self.view </span><span class=\"keyword\">addSubview:btn2];</span></span><br><span class=\"line\"><span class=\"keyword\">btn2.clipsToBounds </span>= YES;</span><br></pre></td></tr></table></figure>\n\n<p>案例3:ImageView设置图片和背景色，两个图层做圆角，则会触发离屏渲染。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIImageView</span> *img1 = [[<span class=\"built_in\">UIImageView</span> alloc]init];</span><br><span class=\"line\">img1.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">100</span>, <span class=\"number\">320</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">img1.backgroundColor = [<span class=\"built_in\">UIColor</span> blueColor];</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:img1];</span><br><span class=\"line\">img1.layer.cornerRadius = <span class=\"number\">50</span>;</span><br><span class=\"line\">img1.layer.masksToBounds = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">img1.image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@&quot;btn.png&quot;</span>];</span><br></pre></td></tr></table></figure>\n\n<p>案例4:ImageView只设置图片，只有一个图层做圆角则不会触发离屏渲染。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UIImageView</span> *img2 = [[<span class=\"built_in\">UIImageView</span> alloc]init];</span><br><span class=\"line\">img2.frame = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">100</span>, <span class=\"number\">480</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">[<span class=\"keyword\">self</span>.view addSubview:img2];</span><br><span class=\"line\">img2.layer.cornerRadius = <span class=\"number\">50</span>;</span><br><span class=\"line\">img2.layer.masksToBounds = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">img2.image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@&quot;btn.png&quot;</span>];</span><br></pre></td></tr></table></figure>\n\n<p>常见对触发离屏渲染的几种情况：</p>\n<ul>\n<li><p>使用了mask的layer (layer.mast)</p>\n</li>\n<li><p>需要进行裁剪的layer (layer.mastToBounds / view.clipToBounds)</p>\n</li>\n<li><p>设置了组透明度为YES，并且透明度不为1的layer (layer.allowsGroupOpacity / layer.opacity)</p>\n</li>\n<li><p>添加了阴影的layer (layer.shadow)</p>\n</li>\n<li><p>采用了光栅化的layer (layer.shouldRasterize)</p>\n</li>\n<li><p>绘制了文字的layer (UILabel, CATextLayer, Core Text 等)</p>\n</li>\n</ul>\n<p>总结：离屏渲染出现原因是由于多个图层需要进行裁剪/混合等处理，需要放入offscreen buffer所造成的。我理解的这里的一个图层并不等于一个CALayer，一个CALayer可以包含多个图层。</p>\n<h4 id=\"离屏渲染产生的问题\"><a href=\"#离屏渲染产生的问题\" class=\"headerlink\" title=\"离屏渲染产生的问题\"></a>离屏渲染产生的问题</h4><ul>\n<li>APP需要额外的开辟Offscreen Buffer空间，大量的离屏渲染可能造成内存的压力。</li>\n<li>需要在Offscreen Buffer和Frame Buffer之前进行频繁切换，需要长时间的处理</li>\n</ul>\n<p>对应的造成<strong>性能问题</strong>以及<strong>掉帧</strong>。</p>\n<h4 id=\"需要使用离屏渲染的场景\"><a href=\"#需要使用离屏渲染的场景\" class=\"headerlink\" title=\"需要使用离屏渲染的场景\"></a>需要使用离屏渲染的场景</h4><ul>\n<li><p>特殊效果：需要使用offscreen Buffer保存中间状态，不得不使用离屏渲染，此时由系统自动触发，如圆角、阴影、组透明度等。</p>\n</li>\n<li><p>提升效率：重复的、静态的资源打开光栅化(shouldRasterize)可以节约之后渲染的时间。打开光栅化需要注意以下几点：</p>\n<ul>\n<li><p>如果layer不能复用，则没有必要打开光栅化。</p>\n</li>\n<li><p>如果layer不是静态的，需要被频繁修改。比如动画，打开光栅化反而影响效率。</p>\n</li>\n<li><p>离屏渲染缓存内容有时间限制，如果超过100ms没有被使用，则被丢弃，无法复用。</p>\n</li>\n<li><p>离屏渲染缓存空间最大为屏幕像素的2.5倍，超过则则会失效，无法复用。</p>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"OpenGL正背面剔除和深度测试","date":"2020-07-09T16:00:00.000Z","_content":"\n在绘制3D图形时，应该判断哪些面对于观察者可见，哪些面对于观察者不可见。不可见部分应该及时丢弃，以提高渲染效率。\n专业术语叫做“消除隐藏面”……\n\n**正面**：按逆时针顶点连接顺序绘制的三角形。\n**背面**：按顺时针顶点连接顺序绘制的三角形。\n\n> Note：由于观察者角度不同，正面和背面可能不同。\n\n#### 1、油画算法\n\n![油画算法](https://upload-images.jianshu.io/upload_images/1395687-6787b795eed70506.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n先绘制离观察者比较远的三角形，再在它们上方绘制距离比较近的三角形。\n\n油画算法只能解决排序好的三角形渲染，且重叠部分渲染性能较差，而且也不能区分未排序的叠加三角形。\n\n####正背面剔除\n\n对正面和背面三角形进行区分的原因之一就是为了剔除。\n\n背面剔除能够极大的提高性能。剔除即在图元装配阶段就整体抛弃了一些三角形，并且没有执行任何不恰当的光栅化操作。\n\n正面剔除也很有用，如在需要显示某些图形内部渲染的时候。渲染透明对象时，会对对象进行两次渲染，第一次开启透明并剔除正面，第二次剔除背面。\n\n**设置剔除正面还是剔除背面函数**\n\n```\nvoid glCullFace(GLenum mode);\n```\nmode参数可用值：`GL_FRONT`/`GL_BACK`/`GL_FRONT_AND_BACK`\n\n\n**开启和关闭剔除**\n\n```\nglEnable(GL_CULL_FACE);\nglDisable(GL_CULL_FACE);\n```\n\n所以消除不透明物体内部几何图形只需要如下代码：\n```\nglCullFace(GL_BACK);\nglEnable(GL_CULL_FACE);\n```\n\n#### 深度测试\n\n**深度缓冲区**：指的是一块存储像素深度(z值)的内存区域。深度值范围[0, 1]之间，根据观察者的位置，如果观察者在z轴正值方向，则深度值越大，离观察者越近；相反如果观察者在z轴负值方向，则深度值越大，离观察者越远。\n\n**深度测试**：OpenGL执行深度测试时，如果深度测试通过，则使用新的像素深度值覆盖深度缓冲区中的值，如果测试未通过，则丢弃该像素。\n\n开启/关闭深度测试：\n```\nglEnable(GL_DEPTH_TEST);\nglDisable(GL_DEPTH_TEST);\n```\n\n清除颜色缓冲区和深度缓冲区，深度缓冲区默认值为1\n```\nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n````\n\n深度缓冲区写入开关\n```\n//value: GL_TURE,开启深度缓冲区写入; GL_FALSE,关闭深度缓冲区写⼊\nvoid glDepthMask(GLBool value);\n```\n\n深度测试函数：定义深度测试通过的规则\n```\nglDepthFunc(GL_LESS);\n```\n\n|  运算符   | 描述  |\n|  ----  | ----  |\n| GL_ALWAYS  | 永远通过测试 |\n| GL_NEVER | 永远不通过测试 |\n| GL_LESS  | 在片段深度值小于缓冲区的深度时通过测试  |\n| GL_EQUAL  | 在片段深度值等于缓冲区的深度时通过测试  |\n| GL_LEQUAL  | 在片段深度值小于等于缓冲区的深度时通过测试  |\n| GL_GREATER  | 在片段深度值大于缓冲区的深度时通过测试  |\n| GL_NOTEQUAL  | 在片段深度值不等于缓冲区的深度时通过测试  |\n| GL_GEQUAL  | 在片段深度值大于等于缓冲区的深度时通过测试  | \n\n默认是`GL_LESS`,即丢弃深度值大于或等于当前缓冲区深度的像素。\n\n###### 深度测试引起的`Z-Fighting`(`Z冲突/闪烁`)问题\n\n**原因**：深度缓冲区精度有限制，深度差别非常小的情况下，OpenGL分不清前后造成的。\n\n**解决办法**：\n\n**多边形偏移 Polygon Offset**:在两个图层之间添加一个偏移，但是手动添加比较复杂且不精准，所以需要用到多边形偏移。\n\n开启多边形偏移\n```\nglEnable(GL_POLYGON_OFFSET_FILL)\n```\n\n指定偏移量\n```\nglPolygonOffset(GLFloat factor, GLFloat units);\n```\n\nfactor和units一般是-1和-1.\n\n**预防**：\n\n    1. 不要将两个物体靠太近，避免渲染时三角形叠在一起。\n\n    2. 尽可能将近裁剪面设置的离观察者远一点。\n\n    3. 使用高位数的深度缓冲区，精度更高。","source":"_posts/2020-07-10-OpenGL正背面剔除和深度测试.markdown","raw":"---\ntitle:      \"OpenGL正背面剔除和深度测试\" \ndate:       2020-07-10\ntags:\n    - OpenGL \ncategories:\n    - OpenGL \n---\n\n在绘制3D图形时，应该判断哪些面对于观察者可见，哪些面对于观察者不可见。不可见部分应该及时丢弃，以提高渲染效率。\n专业术语叫做“消除隐藏面”……\n\n**正面**：按逆时针顶点连接顺序绘制的三角形。\n**背面**：按顺时针顶点连接顺序绘制的三角形。\n\n> Note：由于观察者角度不同，正面和背面可能不同。\n\n#### 1、油画算法\n\n![油画算法](https://upload-images.jianshu.io/upload_images/1395687-6787b795eed70506.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n先绘制离观察者比较远的三角形，再在它们上方绘制距离比较近的三角形。\n\n油画算法只能解决排序好的三角形渲染，且重叠部分渲染性能较差，而且也不能区分未排序的叠加三角形。\n\n####正背面剔除\n\n对正面和背面三角形进行区分的原因之一就是为了剔除。\n\n背面剔除能够极大的提高性能。剔除即在图元装配阶段就整体抛弃了一些三角形，并且没有执行任何不恰当的光栅化操作。\n\n正面剔除也很有用，如在需要显示某些图形内部渲染的时候。渲染透明对象时，会对对象进行两次渲染，第一次开启透明并剔除正面，第二次剔除背面。\n\n**设置剔除正面还是剔除背面函数**\n\n```\nvoid glCullFace(GLenum mode);\n```\nmode参数可用值：`GL_FRONT`/`GL_BACK`/`GL_FRONT_AND_BACK`\n\n\n**开启和关闭剔除**\n\n```\nglEnable(GL_CULL_FACE);\nglDisable(GL_CULL_FACE);\n```\n\n所以消除不透明物体内部几何图形只需要如下代码：\n```\nglCullFace(GL_BACK);\nglEnable(GL_CULL_FACE);\n```\n\n#### 深度测试\n\n**深度缓冲区**：指的是一块存储像素深度(z值)的内存区域。深度值范围[0, 1]之间，根据观察者的位置，如果观察者在z轴正值方向，则深度值越大，离观察者越近；相反如果观察者在z轴负值方向，则深度值越大，离观察者越远。\n\n**深度测试**：OpenGL执行深度测试时，如果深度测试通过，则使用新的像素深度值覆盖深度缓冲区中的值，如果测试未通过，则丢弃该像素。\n\n开启/关闭深度测试：\n```\nglEnable(GL_DEPTH_TEST);\nglDisable(GL_DEPTH_TEST);\n```\n\n清除颜色缓冲区和深度缓冲区，深度缓冲区默认值为1\n```\nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n````\n\n深度缓冲区写入开关\n```\n//value: GL_TURE,开启深度缓冲区写入; GL_FALSE,关闭深度缓冲区写⼊\nvoid glDepthMask(GLBool value);\n```\n\n深度测试函数：定义深度测试通过的规则\n```\nglDepthFunc(GL_LESS);\n```\n\n|  运算符   | 描述  |\n|  ----  | ----  |\n| GL_ALWAYS  | 永远通过测试 |\n| GL_NEVER | 永远不通过测试 |\n| GL_LESS  | 在片段深度值小于缓冲区的深度时通过测试  |\n| GL_EQUAL  | 在片段深度值等于缓冲区的深度时通过测试  |\n| GL_LEQUAL  | 在片段深度值小于等于缓冲区的深度时通过测试  |\n| GL_GREATER  | 在片段深度值大于缓冲区的深度时通过测试  |\n| GL_NOTEQUAL  | 在片段深度值不等于缓冲区的深度时通过测试  |\n| GL_GEQUAL  | 在片段深度值大于等于缓冲区的深度时通过测试  | \n\n默认是`GL_LESS`,即丢弃深度值大于或等于当前缓冲区深度的像素。\n\n###### 深度测试引起的`Z-Fighting`(`Z冲突/闪烁`)问题\n\n**原因**：深度缓冲区精度有限制，深度差别非常小的情况下，OpenGL分不清前后造成的。\n\n**解决办法**：\n\n**多边形偏移 Polygon Offset**:在两个图层之间添加一个偏移，但是手动添加比较复杂且不精准，所以需要用到多边形偏移。\n\n开启多边形偏移\n```\nglEnable(GL_POLYGON_OFFSET_FILL)\n```\n\n指定偏移量\n```\nglPolygonOffset(GLFloat factor, GLFloat units);\n```\n\nfactor和units一般是-1和-1.\n\n**预防**：\n\n    1. 不要将两个物体靠太近，避免渲染时三角形叠在一起。\n\n    2. 尽可能将近裁剪面设置的离观察者远一点。\n\n    3. 使用高位数的深度缓冲区，精度更高。","slug":"2020-07-10-OpenGL正背面剔除和深度测试","published":1,"updated":"2021-06-19T03:46:24.084Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbph000nbjrjh0k310wf","content":"<p>在绘制3D图形时，应该判断哪些面对于观察者可见，哪些面对于观察者不可见。不可见部分应该及时丢弃，以提高渲染效率。<br>专业术语叫做“消除隐藏面”……</p>\n<p><strong>正面</strong>：按逆时针顶点连接顺序绘制的三角形。<br><strong>背面</strong>：按顺时针顶点连接顺序绘制的三角形。</p>\n<blockquote>\n<p>Note：由于观察者角度不同，正面和背面可能不同。</p>\n</blockquote>\n<h4 id=\"1、油画算法\"><a href=\"#1、油画算法\" class=\"headerlink\" title=\"1、油画算法\"></a>1、油画算法</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-6787b795eed70506.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"油画算法\"></p>\n<p>先绘制离观察者比较远的三角形，再在它们上方绘制距离比较近的三角形。</p>\n<p>油画算法只能解决排序好的三角形渲染，且重叠部分渲染性能较差，而且也不能区分未排序的叠加三角形。</p>\n<p>####正背面剔除</p>\n<p>对正面和背面三角形进行区分的原因之一就是为了剔除。</p>\n<p>背面剔除能够极大的提高性能。剔除即在图元装配阶段就整体抛弃了一些三角形，并且没有执行任何不恰当的光栅化操作。</p>\n<p>正面剔除也很有用，如在需要显示某些图形内部渲染的时候。渲染透明对象时，会对对象进行两次渲染，第一次开启透明并剔除正面，第二次剔除背面。</p>\n<p><strong>设置剔除正面还是剔除背面函数</strong></p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">glCullFace</span><span class=\"params\">(GLenum mode)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>mode参数可用值：<code>GL_FRONT</code>/<code>GL_BACK</code>/<code>GL_FRONT_AND_BACK</code></p>\n<p><strong>开启和关闭剔除</strong></p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glEnable(GL_CULL_FACE)<span class=\"comment\">;</span></span><br><span class=\"line\">glDisable(GL_CULL_FACE)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>所以消除不透明物体内部几何图形只需要如下代码：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glCullFace(GL_BACK)<span class=\"comment\">;</span></span><br><span class=\"line\">glEnable(GL_CULL_FACE)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"深度测试\"><a href=\"#深度测试\" class=\"headerlink\" title=\"深度测试\"></a>深度测试</h4><p><strong>深度缓冲区</strong>：指的是一块存储像素深度(z值)的内存区域。深度值范围[0, 1]之间，根据观察者的位置，如果观察者在z轴正值方向，则深度值越大，离观察者越近；相反如果观察者在z轴负值方向，则深度值越大，离观察者越远。</p>\n<p><strong>深度测试</strong>：OpenGL执行深度测试时，如果深度测试通过，则使用新的像素深度值覆盖深度缓冲区中的值，如果测试未通过，则丢弃该像素。</p>\n<p>开启/关闭深度测试：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glEnable(GL_DEPTH_TEST)<span class=\"comment\">;</span></span><br><span class=\"line\">glDisable(GL_DEPTH_TEST)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>清除颜色缓冲区和深度缓冲区，深度缓冲区默认值为1</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">``</span></span><br><span class=\"line\"></span><br><span class=\"line\">深度缓冲区写入开关</span><br></pre></td></tr></table></figure>\n<p>//value: GL_TURE,开启深度缓冲区写入; GL_FALSE,关闭深度缓冲区写⼊<br>void glDepthMask(GLBool value);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">深度测试函数：定义深度测试通过的规则</span><br></pre></td></tr></table></figure>\n<p>glDepthFunc(GL_LESS);</p>\n<figure class=\"highlight gherkin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">|<span class=\"string\">  运算符   </span>|<span class=\"string\"> 描述  </span>|</span><br><span class=\"line\">|<span class=\"string\">  ----  </span>|<span class=\"string\"> ----  </span>|</span><br><span class=\"line\">|<span class=\"string\"> GL_ALWAYS  </span>|<span class=\"string\"> 永远通过测试 </span>|</span><br><span class=\"line\">|<span class=\"string\"> GL_NEVER </span>|<span class=\"string\"> 永远不通过测试 </span>|</span><br><span class=\"line\">|<span class=\"string\"> GL_LESS  </span>|<span class=\"string\"> 在片段深度值小于缓冲区的深度时通过测试  </span>|</span><br><span class=\"line\">|<span class=\"string\"> GL_EQUAL  </span>|<span class=\"string\"> 在片段深度值等于缓冲区的深度时通过测试  </span>|</span><br><span class=\"line\">|<span class=\"string\"> GL_LEQUAL  </span>|<span class=\"string\"> 在片段深度值小于等于缓冲区的深度时通过测试  </span>|</span><br><span class=\"line\">|<span class=\"string\"> GL_GREATER  </span>|<span class=\"string\"> 在片段深度值大于缓冲区的深度时通过测试  </span>|</span><br><span class=\"line\">|<span class=\"string\"> GL_NOTEQUAL  </span>|<span class=\"string\"> 在片段深度值不等于缓冲区的深度时通过测试  </span>|</span><br><span class=\"line\">|<span class=\"string\"> GL_GEQUAL  </span>|<span class=\"string\"> 在片段深度值大于等于缓冲区的深度时通过测试  </span>|<span class=\"string\"> </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">默认是`GL_LESS`,即丢弃深度值大于或等于当前缓冲区深度的像素。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">###### 深度测试引起的`Z-Fighting`(`Z冲突/闪烁`)问题</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">**原因**：深度缓冲区精度有限制，深度差别非常小的情况下，OpenGL分不清前后造成的。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">**解决办法**：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">**多边形偏移 Polygon Offset**:在两个图层之间添加一个偏移，但是手动添加比较复杂且不精准，所以需要用到多边形偏移。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">开启多边形偏移</span></span><br></pre></td></tr></table></figure>\n<p>glEnable(GL_POLYGON_OFFSET_FILL)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">指定偏移量</span><br></pre></td></tr></table></figure>\n<p>glPolygonOffset(GLFloat factor, GLFloat units);</p>\n<p>```</p>\n<p>factor和units一般是-1和-1.</p>\n<p><strong>预防</strong>：</p>\n<pre><code>1. 不要将两个物体靠太近，避免渲染时三角形叠在一起。\n\n2. 尽可能将近裁剪面设置的离观察者远一点。\n\n3. 使用高位数的深度缓冲区，精度更高。\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>在绘制3D图形时，应该判断哪些面对于观察者可见，哪些面对于观察者不可见。不可见部分应该及时丢弃，以提高渲染效率。<br>专业术语叫做“消除隐藏面”……</p>\n<p><strong>正面</strong>：按逆时针顶点连接顺序绘制的三角形。<br><strong>背面</strong>：按顺时针顶点连接顺序绘制的三角形。</p>\n<blockquote>\n<p>Note：由于观察者角度不同，正面和背面可能不同。</p>\n</blockquote>\n<h4 id=\"1、油画算法\"><a href=\"#1、油画算法\" class=\"headerlink\" title=\"1、油画算法\"></a>1、油画算法</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-6787b795eed70506.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"油画算法\"></p>\n<p>先绘制离观察者比较远的三角形，再在它们上方绘制距离比较近的三角形。</p>\n<p>油画算法只能解决排序好的三角形渲染，且重叠部分渲染性能较差，而且也不能区分未排序的叠加三角形。</p>\n<p>####正背面剔除</p>\n<p>对正面和背面三角形进行区分的原因之一就是为了剔除。</p>\n<p>背面剔除能够极大的提高性能。剔除即在图元装配阶段就整体抛弃了一些三角形，并且没有执行任何不恰当的光栅化操作。</p>\n<p>正面剔除也很有用，如在需要显示某些图形内部渲染的时候。渲染透明对象时，会对对象进行两次渲染，第一次开启透明并剔除正面，第二次剔除背面。</p>\n<p><strong>设置剔除正面还是剔除背面函数</strong></p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">glCullFace</span><span class=\"params\">(GLenum mode)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>mode参数可用值：<code>GL_FRONT</code>/<code>GL_BACK</code>/<code>GL_FRONT_AND_BACK</code></p>\n<p><strong>开启和关闭剔除</strong></p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glEnable(GL_CULL_FACE)<span class=\"comment\">;</span></span><br><span class=\"line\">glDisable(GL_CULL_FACE)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>所以消除不透明物体内部几何图形只需要如下代码：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glCullFace(GL_BACK)<span class=\"comment\">;</span></span><br><span class=\"line\">glEnable(GL_CULL_FACE)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"深度测试\"><a href=\"#深度测试\" class=\"headerlink\" title=\"深度测试\"></a>深度测试</h4><p><strong>深度缓冲区</strong>：指的是一块存储像素深度(z值)的内存区域。深度值范围[0, 1]之间，根据观察者的位置，如果观察者在z轴正值方向，则深度值越大，离观察者越近；相反如果观察者在z轴负值方向，则深度值越大，离观察者越远。</p>\n<p><strong>深度测试</strong>：OpenGL执行深度测试时，如果深度测试通过，则使用新的像素深度值覆盖深度缓冲区中的值，如果测试未通过，则丢弃该像素。</p>\n<p>开启/关闭深度测试：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glEnable(GL_DEPTH_TEST)<span class=\"comment\">;</span></span><br><span class=\"line\">glDisable(GL_DEPTH_TEST)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>清除颜色缓冲区和深度缓冲区，深度缓冲区默认值为1</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">``</span></span><br><span class=\"line\"></span><br><span class=\"line\">深度缓冲区写入开关</span><br></pre></td></tr></table></figure>\n<p>//value: GL_TURE,开启深度缓冲区写入; GL_FALSE,关闭深度缓冲区写⼊<br>void glDepthMask(GLBool value);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">深度测试函数：定义深度测试通过的规则</span><br></pre></td></tr></table></figure>\n<p>glDepthFunc(GL_LESS);</p>\n<figure class=\"highlight gherkin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">|<span class=\"string\">  运算符   </span>|<span class=\"string\"> 描述  </span>|</span><br><span class=\"line\">|<span class=\"string\">  ----  </span>|<span class=\"string\"> ----  </span>|</span><br><span class=\"line\">|<span class=\"string\"> GL_ALWAYS  </span>|<span class=\"string\"> 永远通过测试 </span>|</span><br><span class=\"line\">|<span class=\"string\"> GL_NEVER </span>|<span class=\"string\"> 永远不通过测试 </span>|</span><br><span class=\"line\">|<span class=\"string\"> GL_LESS  </span>|<span class=\"string\"> 在片段深度值小于缓冲区的深度时通过测试  </span>|</span><br><span class=\"line\">|<span class=\"string\"> GL_EQUAL  </span>|<span class=\"string\"> 在片段深度值等于缓冲区的深度时通过测试  </span>|</span><br><span class=\"line\">|<span class=\"string\"> GL_LEQUAL  </span>|<span class=\"string\"> 在片段深度值小于等于缓冲区的深度时通过测试  </span>|</span><br><span class=\"line\">|<span class=\"string\"> GL_GREATER  </span>|<span class=\"string\"> 在片段深度值大于缓冲区的深度时通过测试  </span>|</span><br><span class=\"line\">|<span class=\"string\"> GL_NOTEQUAL  </span>|<span class=\"string\"> 在片段深度值不等于缓冲区的深度时通过测试  </span>|</span><br><span class=\"line\">|<span class=\"string\"> GL_GEQUAL  </span>|<span class=\"string\"> 在片段深度值大于等于缓冲区的深度时通过测试  </span>|<span class=\"string\"> </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">默认是`GL_LESS`,即丢弃深度值大于或等于当前缓冲区深度的像素。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">###### 深度测试引起的`Z-Fighting`(`Z冲突/闪烁`)问题</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">**原因**：深度缓冲区精度有限制，深度差别非常小的情况下，OpenGL分不清前后造成的。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">**解决办法**：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">**多边形偏移 Polygon Offset**:在两个图层之间添加一个偏移，但是手动添加比较复杂且不精准，所以需要用到多边形偏移。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">开启多边形偏移</span></span><br></pre></td></tr></table></figure>\n<p>glEnable(GL_POLYGON_OFFSET_FILL)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">指定偏移量</span><br></pre></td></tr></table></figure>\n<p>glPolygonOffset(GLFloat factor, GLFloat units);</p>\n<p>```</p>\n<p>factor和units一般是-1和-1.</p>\n<p><strong>预防</strong>：</p>\n<pre><code>1. 不要将两个物体靠太近，避免渲染时三角形叠在一起。\n\n2. 尽可能将近裁剪面设置的离观察者远一点。\n\n3. 使用高位数的深度缓冲区，精度更高。\n</code></pre>\n"},{"title":"OpenGL颜色混合","date":"2020-07-12T16:00:00.000Z","_content":"\n#### 颜色混合\n\n当深度测试关闭时，新的颜色值简单当覆盖颜色缓冲区中已经存在当其他值。当深度测试打开时，新的颜色片段只有当它们比原来的值更接近裁剪平面时才会替换原来的颜色片段。\n\n如果打开颜色混合，下层的颜色值就不会被清除。\n\n开启/关闭颜色混合\n```\nglEnable(GL_BLEND);\nglDisable(GL_BLEND);\n```\n\n目标颜色：已经存在于颜色缓冲区的值。\n\n源颜色：准备进入颜色缓冲区的值。\n\n目标颜色和源颜色的组合方式由混合方程式控制。默认情况下混合方程式为：\n\n```\nCf=(Cs * S) + (Cd * D)\n```\n\n`Cf`:最终计算产生的颜色\n\n`Cs`:源颜色\n\n`Cd`:目标颜色\n\n`S和D`分别为源颜色和目标颜色的混合因子\n\n混合因子使用如下函数进行设置\n```\nglBlendFunc(GLenum S, GLenum D);\n```\n\n常用的混合组合为：\n```\nglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n```","source":"_posts/2020-07-13-OpenGL颜色混合.markdown","raw":"---\ntitle:      \"OpenGL颜色混合\" \ndate:       2020-07-13\ntags:\n    - OpenGL \ncategories:\n    - OpenGL \n---\n\n#### 颜色混合\n\n当深度测试关闭时，新的颜色值简单当覆盖颜色缓冲区中已经存在当其他值。当深度测试打开时，新的颜色片段只有当它们比原来的值更接近裁剪平面时才会替换原来的颜色片段。\n\n如果打开颜色混合，下层的颜色值就不会被清除。\n\n开启/关闭颜色混合\n```\nglEnable(GL_BLEND);\nglDisable(GL_BLEND);\n```\n\n目标颜色：已经存在于颜色缓冲区的值。\n\n源颜色：准备进入颜色缓冲区的值。\n\n目标颜色和源颜色的组合方式由混合方程式控制。默认情况下混合方程式为：\n\n```\nCf=(Cs * S) + (Cd * D)\n```\n\n`Cf`:最终计算产生的颜色\n\n`Cs`:源颜色\n\n`Cd`:目标颜色\n\n`S和D`分别为源颜色和目标颜色的混合因子\n\n混合因子使用如下函数进行设置\n```\nglBlendFunc(GLenum S, GLenum D);\n```\n\n常用的混合组合为：\n```\nglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n```","slug":"2020-07-13-OpenGL颜色混合","published":1,"updated":"2021-06-19T03:46:24.084Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbpi000qbjrj00ove4hs","content":"<h4 id=\"颜色混合\"><a href=\"#颜色混合\" class=\"headerlink\" title=\"颜色混合\"></a>颜色混合</h4><p>当深度测试关闭时，新的颜色值简单当覆盖颜色缓冲区中已经存在当其他值。当深度测试打开时，新的颜色片段只有当它们比原来的值更接近裁剪平面时才会替换原来的颜色片段。</p>\n<p>如果打开颜色混合，下层的颜色值就不会被清除。</p>\n<p>开启/关闭颜色混合</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glEnable(GL_BLEND)<span class=\"comment\">;</span></span><br><span class=\"line\">glDisable(GL_BLEND)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>目标颜色：已经存在于颜色缓冲区的值。</p>\n<p>源颜色：准备进入颜色缓冲区的值。</p>\n<p>目标颜色和源颜色的组合方式由混合方程式控制。默认情况下混合方程式为：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Cf</span>=(<span class=\"keyword\">Cs</span> * S) + (<span class=\"keyword\">Cd</span> * <span class=\"keyword\">D</span>)</span><br></pre></td></tr></table></figure>\n\n<p><code>Cf</code>:最终计算产生的颜色</p>\n<p><code>Cs</code>:源颜色</p>\n<p><code>Cd</code>:目标颜色</p>\n<p><code>S和D</code>分别为源颜色和目标颜色的混合因子</p>\n<p>混合因子使用如下函数进行设置</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">glBlendFunc</span>(GLenum S, GLenum D);</span><br></pre></td></tr></table></figure>\n\n<p>常用的混合组合为：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"颜色混合\"><a href=\"#颜色混合\" class=\"headerlink\" title=\"颜色混合\"></a>颜色混合</h4><p>当深度测试关闭时，新的颜色值简单当覆盖颜色缓冲区中已经存在当其他值。当深度测试打开时，新的颜色片段只有当它们比原来的值更接近裁剪平面时才会替换原来的颜色片段。</p>\n<p>如果打开颜色混合，下层的颜色值就不会被清除。</p>\n<p>开启/关闭颜色混合</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glEnable(GL_BLEND)<span class=\"comment\">;</span></span><br><span class=\"line\">glDisable(GL_BLEND)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>目标颜色：已经存在于颜色缓冲区的值。</p>\n<p>源颜色：准备进入颜色缓冲区的值。</p>\n<p>目标颜色和源颜色的组合方式由混合方程式控制。默认情况下混合方程式为：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Cf</span>=(<span class=\"keyword\">Cs</span> * S) + (<span class=\"keyword\">Cd</span> * <span class=\"keyword\">D</span>)</span><br></pre></td></tr></table></figure>\n\n<p><code>Cf</code>:最终计算产生的颜色</p>\n<p><code>Cs</code>:源颜色</p>\n<p><code>Cd</code>:目标颜色</p>\n<p><code>S和D</code>分别为源颜色和目标颜色的混合因子</p>\n<p>混合因子使用如下函数进行设置</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">glBlendFunc</span>(GLenum S, GLenum D);</span><br></pre></td></tr></table></figure>\n\n<p>常用的混合组合为：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br></pre></td></tr></table></figure>"},{"title":"OpenGL向量、矩阵相关","date":"2020-07-16T16:00:00.000Z","_content":"\n#### 向量\n\n定义：既有大小，又有方向的一个几何对象。\n\n单位向量：不论方向，大小为1的向量\n\n向量大小(长度/模)的计算公式\n![向量大小计算公式](https://upload-images.jianshu.io/upload_images/1395687-58864705b05b176a.gif?imageMogr2/auto-orient/strip)\n\n \n\n非单位向量(x, y, z)转化为单位向量\n![非零单位向量转为单位向量](https://upload-images.jianshu.io/upload_images/1395687-6992aaae1049cda6.gif?imageMogr2/auto-orient/strip)\n\n**向量的点乘**\n\n - 点乘只能发生在两个单位向量之间，如果不是单位向量，需要转化成单位向量才能点乘。\n\n - 点乘的结果是一个标量，在[-1,1]之间，是两个向量夹角的cos值。 \n\n - `math3d.h`中点乘提供了两个函数：\n\n    - `m3dDotProduct3(const float *u, const float *v)`：返回两个向量之间夹角的cos值。\n\n    - `m3dGetAngleBetweenVectors3(const float *u, const float *v)`：返回两个向量之间夹角对应的弧度。\n\n**向量的叉乘**\n\n\n\n两个向量$\\vec{a}$和$\\vec{b}$叉乘得到的结果仍然是一个向量$\\vec{c}$，该向量$\\vec{c}$垂直于两个向量$\\vec{a}$和$\\vec{b}$所构成的平面。\n\n - `math3d.h`中叉乘提供了两个函数：\n\n    - `m3dCrossProduct3(float *result, const float *u, const float *v)`\n\n#### 矩阵(Matrix)\n\n矩阵（Matrix）是一个按照长方阵列排列的复数或实数集合。可以用一维或二维数组表示，在OpenGL中习惯使用一维数组。\n\n**矩阵的运算**\n\n  - 加减法。只要两个矩阵行和列相等，则对应位置的元素进行加减即可。\n\n  - 点乘。两个矩阵行数和列数相等，对应位置的元素相乘即为结果矩阵对应位置的元素。\n\n  - 叉乘。只有第一个矩阵A的列数和第二个矩阵B的行数相等时相乘才有意义。\n\n**单位矩阵**\n\n主对角线值为1，其余值为0的矩阵称为**单元矩阵**。\n\n#### OpenGL矩阵变换\n\n![矩阵变换](https://upload-images.jianshu.io/upload_images/1395687-c270eba5c254b13f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**行矩阵**：逐行读取\n\n![行矩阵](https://upload-images.jianshu.io/upload_images/1395687-a67e37d354785976.gif?imageMogr2/auto-orient/strip)\n\n**列矩阵**：逐列读取\n\n![列矩阵](https://upload-images.jianshu.io/upload_images/1395687-5c33e7a7f7db3bbb.gif?imageMogr2/auto-orient/strip)\n\n\n行矩阵通过矩阵转置后可以得到列矩阵。\n\n在数学中，习惯使用**行矩阵**来进行运算，此时mpv的顺序为`position * m * v * p`。\n\n在OpenGL中，习惯使用**列矩阵**来进行运算，此时mpv相乘的顺序为`p * v * m * position`\n","source":"_posts/2020-07-17-OpenGL向量、矩阵相关.md","raw":"---\ntitle:      \"OpenGL向量、矩阵相关\" \ndate:       2020-07-17\ntags:\n    - OpenGL \ncategories:\n    - OpenGL \n---\n\n#### 向量\n\n定义：既有大小，又有方向的一个几何对象。\n\n单位向量：不论方向，大小为1的向量\n\n向量大小(长度/模)的计算公式\n![向量大小计算公式](https://upload-images.jianshu.io/upload_images/1395687-58864705b05b176a.gif?imageMogr2/auto-orient/strip)\n\n \n\n非单位向量(x, y, z)转化为单位向量\n![非零单位向量转为单位向量](https://upload-images.jianshu.io/upload_images/1395687-6992aaae1049cda6.gif?imageMogr2/auto-orient/strip)\n\n**向量的点乘**\n\n - 点乘只能发生在两个单位向量之间，如果不是单位向量，需要转化成单位向量才能点乘。\n\n - 点乘的结果是一个标量，在[-1,1]之间，是两个向量夹角的cos值。 \n\n - `math3d.h`中点乘提供了两个函数：\n\n    - `m3dDotProduct3(const float *u, const float *v)`：返回两个向量之间夹角的cos值。\n\n    - `m3dGetAngleBetweenVectors3(const float *u, const float *v)`：返回两个向量之间夹角对应的弧度。\n\n**向量的叉乘**\n\n\n\n两个向量$\\vec{a}$和$\\vec{b}$叉乘得到的结果仍然是一个向量$\\vec{c}$，该向量$\\vec{c}$垂直于两个向量$\\vec{a}$和$\\vec{b}$所构成的平面。\n\n - `math3d.h`中叉乘提供了两个函数：\n\n    - `m3dCrossProduct3(float *result, const float *u, const float *v)`\n\n#### 矩阵(Matrix)\n\n矩阵（Matrix）是一个按照长方阵列排列的复数或实数集合。可以用一维或二维数组表示，在OpenGL中习惯使用一维数组。\n\n**矩阵的运算**\n\n  - 加减法。只要两个矩阵行和列相等，则对应位置的元素进行加减即可。\n\n  - 点乘。两个矩阵行数和列数相等，对应位置的元素相乘即为结果矩阵对应位置的元素。\n\n  - 叉乘。只有第一个矩阵A的列数和第二个矩阵B的行数相等时相乘才有意义。\n\n**单位矩阵**\n\n主对角线值为1，其余值为0的矩阵称为**单元矩阵**。\n\n#### OpenGL矩阵变换\n\n![矩阵变换](https://upload-images.jianshu.io/upload_images/1395687-c270eba5c254b13f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**行矩阵**：逐行读取\n\n![行矩阵](https://upload-images.jianshu.io/upload_images/1395687-a67e37d354785976.gif?imageMogr2/auto-orient/strip)\n\n**列矩阵**：逐列读取\n\n![列矩阵](https://upload-images.jianshu.io/upload_images/1395687-5c33e7a7f7db3bbb.gif?imageMogr2/auto-orient/strip)\n\n\n行矩阵通过矩阵转置后可以得到列矩阵。\n\n在数学中，习惯使用**行矩阵**来进行运算，此时mpv的顺序为`position * m * v * p`。\n\n在OpenGL中，习惯使用**列矩阵**来进行运算，此时mpv相乘的顺序为`p * v * m * position`\n","slug":"2020-07-17-OpenGL向量、矩阵相关","published":1,"updated":"2021-06-19T03:46:24.085Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbpk000vbjrjfgy57mmq","content":"<h4 id=\"向量\"><a href=\"#向量\" class=\"headerlink\" title=\"向量\"></a>向量</h4><p>定义：既有大小，又有方向的一个几何对象。</p>\n<p>单位向量：不论方向，大小为1的向量</p>\n<p>向量大小(长度/模)的计算公式<br><img src=\"https://upload-images.jianshu.io/upload_images/1395687-58864705b05b176a.gif?imageMogr2/auto-orient/strip\" alt=\"向量大小计算公式\"></p>\n<p>非单位向量(x, y, z)转化为单位向量<br><img src=\"https://upload-images.jianshu.io/upload_images/1395687-6992aaae1049cda6.gif?imageMogr2/auto-orient/strip\" alt=\"非零单位向量转为单位向量\"></p>\n<p><strong>向量的点乘</strong></p>\n<ul>\n<li><p>点乘只能发生在两个单位向量之间，如果不是单位向量，需要转化成单位向量才能点乘。</p>\n</li>\n<li><p>点乘的结果是一个标量，在[-1,1]之间，是两个向量夹角的cos值。 </p>\n</li>\n<li><p><code>math3d.h</code>中点乘提供了两个函数：</p>\n<ul>\n<li><p><code>m3dDotProduct3(const float *u, const float *v)</code>：返回两个向量之间夹角的cos值。</p>\n</li>\n<li><p><code>m3dGetAngleBetweenVectors3(const float *u, const float *v)</code>：返回两个向量之间夹角对应的弧度。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>向量的叉乘</strong></p>\n<p>两个向量$\\vec{a}$和$\\vec{b}$叉乘得到的结果仍然是一个向量$\\vec{c}$，该向量$\\vec{c}$垂直于两个向量$\\vec{a}$和$\\vec{b}$所构成的平面。</p>\n<ul>\n<li><p><code>math3d.h</code>中叉乘提供了两个函数：</p>\n<ul>\n<li><code>m3dCrossProduct3(float *result, const float *u, const float *v)</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"矩阵-Matrix\"><a href=\"#矩阵-Matrix\" class=\"headerlink\" title=\"矩阵(Matrix)\"></a>矩阵(Matrix)</h4><p>矩阵（Matrix）是一个按照长方阵列排列的复数或实数集合。可以用一维或二维数组表示，在OpenGL中习惯使用一维数组。</p>\n<p><strong>矩阵的运算</strong></p>\n<ul>\n<li><p>加减法。只要两个矩阵行和列相等，则对应位置的元素进行加减即可。</p>\n</li>\n<li><p>点乘。两个矩阵行数和列数相等，对应位置的元素相乘即为结果矩阵对应位置的元素。</p>\n</li>\n<li><p>叉乘。只有第一个矩阵A的列数和第二个矩阵B的行数相等时相乘才有意义。</p>\n</li>\n</ul>\n<p><strong>单位矩阵</strong></p>\n<p>主对角线值为1，其余值为0的矩阵称为<strong>单元矩阵</strong>。</p>\n<h4 id=\"OpenGL矩阵变换\"><a href=\"#OpenGL矩阵变换\" class=\"headerlink\" title=\"OpenGL矩阵变换\"></a>OpenGL矩阵变换</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-c270eba5c254b13f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"矩阵变换\"></p>\n<p><strong>行矩阵</strong>：逐行读取</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-a67e37d354785976.gif?imageMogr2/auto-orient/strip\" alt=\"行矩阵\"></p>\n<p><strong>列矩阵</strong>：逐列读取</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-5c33e7a7f7db3bbb.gif?imageMogr2/auto-orient/strip\" alt=\"列矩阵\"></p>\n<p>行矩阵通过矩阵转置后可以得到列矩阵。</p>\n<p>在数学中，习惯使用<strong>行矩阵</strong>来进行运算，此时mpv的顺序为<code>position * m * v * p</code>。</p>\n<p>在OpenGL中，习惯使用<strong>列矩阵</strong>来进行运算，此时mpv相乘的顺序为<code>p * v * m * position</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"向量\"><a href=\"#向量\" class=\"headerlink\" title=\"向量\"></a>向量</h4><p>定义：既有大小，又有方向的一个几何对象。</p>\n<p>单位向量：不论方向，大小为1的向量</p>\n<p>向量大小(长度/模)的计算公式<br><img src=\"https://upload-images.jianshu.io/upload_images/1395687-58864705b05b176a.gif?imageMogr2/auto-orient/strip\" alt=\"向量大小计算公式\"></p>\n<p>非单位向量(x, y, z)转化为单位向量<br><img src=\"https://upload-images.jianshu.io/upload_images/1395687-6992aaae1049cda6.gif?imageMogr2/auto-orient/strip\" alt=\"非零单位向量转为单位向量\"></p>\n<p><strong>向量的点乘</strong></p>\n<ul>\n<li><p>点乘只能发生在两个单位向量之间，如果不是单位向量，需要转化成单位向量才能点乘。</p>\n</li>\n<li><p>点乘的结果是一个标量，在[-1,1]之间，是两个向量夹角的cos值。 </p>\n</li>\n<li><p><code>math3d.h</code>中点乘提供了两个函数：</p>\n<ul>\n<li><p><code>m3dDotProduct3(const float *u, const float *v)</code>：返回两个向量之间夹角的cos值。</p>\n</li>\n<li><p><code>m3dGetAngleBetweenVectors3(const float *u, const float *v)</code>：返回两个向量之间夹角对应的弧度。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>向量的叉乘</strong></p>\n<p>两个向量$\\vec{a}$和$\\vec{b}$叉乘得到的结果仍然是一个向量$\\vec{c}$，该向量$\\vec{c}$垂直于两个向量$\\vec{a}$和$\\vec{b}$所构成的平面。</p>\n<ul>\n<li><p><code>math3d.h</code>中叉乘提供了两个函数：</p>\n<ul>\n<li><code>m3dCrossProduct3(float *result, const float *u, const float *v)</code></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"矩阵-Matrix\"><a href=\"#矩阵-Matrix\" class=\"headerlink\" title=\"矩阵(Matrix)\"></a>矩阵(Matrix)</h4><p>矩阵（Matrix）是一个按照长方阵列排列的复数或实数集合。可以用一维或二维数组表示，在OpenGL中习惯使用一维数组。</p>\n<p><strong>矩阵的运算</strong></p>\n<ul>\n<li><p>加减法。只要两个矩阵行和列相等，则对应位置的元素进行加减即可。</p>\n</li>\n<li><p>点乘。两个矩阵行数和列数相等，对应位置的元素相乘即为结果矩阵对应位置的元素。</p>\n</li>\n<li><p>叉乘。只有第一个矩阵A的列数和第二个矩阵B的行数相等时相乘才有意义。</p>\n</li>\n</ul>\n<p><strong>单位矩阵</strong></p>\n<p>主对角线值为1，其余值为0的矩阵称为<strong>单元矩阵</strong>。</p>\n<h4 id=\"OpenGL矩阵变换\"><a href=\"#OpenGL矩阵变换\" class=\"headerlink\" title=\"OpenGL矩阵变换\"></a>OpenGL矩阵变换</h4><p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-c270eba5c254b13f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"矩阵变换\"></p>\n<p><strong>行矩阵</strong>：逐行读取</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-a67e37d354785976.gif?imageMogr2/auto-orient/strip\" alt=\"行矩阵\"></p>\n<p><strong>列矩阵</strong>：逐列读取</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-5c33e7a7f7db3bbb.gif?imageMogr2/auto-orient/strip\" alt=\"列矩阵\"></p>\n<p>行矩阵通过矩阵转置后可以得到列矩阵。</p>\n<p>在数学中，习惯使用<strong>行矩阵</strong>来进行运算，此时mpv的顺序为<code>position * m * v * p</code>。</p>\n<p>在OpenGL中，习惯使用<strong>列矩阵</strong>来进行运算，此时mpv相乘的顺序为<code>p * v * m * position</code></p>\n"},{"title":"一、Cocoapods安装与更新","date":"2020-07-20T16:00:00.000Z","_content":"\n1.首先查看 `gem source` 源\n```\ngem sources -l\n```\n\n2.删除源\n```\ngem sources --remove https://rubygems.org/\n```\n\n3.添加新的源\n```\ngem sources --add https://gems.ruby-china.com/\n```\n\n4.升级ruby\n\n查看ruby版本：`ruby -v`\n\n安装homebrew\n```\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"\n```\n\n可以使用`rvm`和`brew`来安装最新的ruby\n\n - rvm:\n\n    `rvm install 2.5.3`\n\n    `rvm use 2.5.3 --default`\n\n - bew:\n\n    `brew install ruby`\n\n5.安装cocoapods\n\n`sudo gem install -n /usr/local/bin cocoapods`\n\n`pod setup`由于网络原因，会执行的很慢\n\n可以使用如下命令\n\n`git clone https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git  ~/.cocoapods/repos/trunk`\n\n","source":"_posts/2020-07-21-Cocoapods安装与更新.md","raw":"---\ntitle:      \"一、Cocoapods安装与更新\" \ndate:       2020-07-21\ntags:\n    - iOS\n    - Cocoapods\ncategories:\n    - iOS\n    - Cocoapods\n---\n\n1.首先查看 `gem source` 源\n```\ngem sources -l\n```\n\n2.删除源\n```\ngem sources --remove https://rubygems.org/\n```\n\n3.添加新的源\n```\ngem sources --add https://gems.ruby-china.com/\n```\n\n4.升级ruby\n\n查看ruby版本：`ruby -v`\n\n安装homebrew\n```\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"\n```\n\n可以使用`rvm`和`brew`来安装最新的ruby\n\n - rvm:\n\n    `rvm install 2.5.3`\n\n    `rvm use 2.5.3 --default`\n\n - bew:\n\n    `brew install ruby`\n\n5.安装cocoapods\n\n`sudo gem install -n /usr/local/bin cocoapods`\n\n`pod setup`由于网络原因，会执行的很慢\n\n可以使用如下命令\n\n`git clone https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git  ~/.cocoapods/repos/trunk`\n\n","slug":"2020-07-21-Cocoapods安装与更新","published":1,"updated":"2021-06-19T03:46:24.085Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbpl000ybjrj1kzq04c2","content":"<p>1.首先查看 <code>gem source</code> 源</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">gem sources -l</span></span><br></pre></td></tr></table></figure>\n\n<p>2.删除源</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem sources --<span class=\"built_in\">remove</span> https:<span class=\"comment\">//rubygems.org/</span></span><br></pre></td></tr></table></figure>\n\n<p>3.添加新的源</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem sources --<span class=\"built_in\">add</span> http<span class=\"variable\">s:</span>//gems.<span class=\"keyword\">ruby</span>-china.<span class=\"keyword\">com</span>/</span><br></pre></td></tr></table></figure>\n\n<p>4.升级ruby</p>\n<p>查看ruby版本：<code>ruby -v</code></p>\n<p>安装homebrew</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">/bin/</span>bash -c <span class=\"string\">&quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以使用<code>rvm</code>和<code>brew</code>来安装最新的ruby</p>\n<ul>\n<li><p>rvm:</p>\n<p> <code>rvm install 2.5.3</code></p>\n<p> <code>rvm use 2.5.3 --default</code></p>\n</li>\n<li><p>bew:</p>\n<p> <code>brew install ruby</code></p>\n</li>\n</ul>\n<p>5.安装cocoapods</p>\n<p><code>sudo gem install -n /usr/local/bin cocoapods</code></p>\n<p><code>pod setup</code>由于网络原因，会执行的很慢</p>\n<p>可以使用如下命令</p>\n<p><code>git clone https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git  ~/.cocoapods/repos/trunk</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.首先查看 <code>gem source</code> 源</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">gem sources -l</span></span><br></pre></td></tr></table></figure>\n\n<p>2.删除源</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem sources --<span class=\"built_in\">remove</span> https:<span class=\"comment\">//rubygems.org/</span></span><br></pre></td></tr></table></figure>\n\n<p>3.添加新的源</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem sources --<span class=\"built_in\">add</span> http<span class=\"variable\">s:</span>//gems.<span class=\"keyword\">ruby</span>-china.<span class=\"keyword\">com</span>/</span><br></pre></td></tr></table></figure>\n\n<p>4.升级ruby</p>\n<p>查看ruby版本：<code>ruby -v</code></p>\n<p>安装homebrew</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">/bin/</span>bash -c <span class=\"string\">&quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以使用<code>rvm</code>和<code>brew</code>来安装最新的ruby</p>\n<ul>\n<li><p>rvm:</p>\n<p> <code>rvm install 2.5.3</code></p>\n<p> <code>rvm use 2.5.3 --default</code></p>\n</li>\n<li><p>bew:</p>\n<p> <code>brew install ruby</code></p>\n</li>\n</ul>\n<p>5.安装cocoapods</p>\n<p><code>sudo gem install -n /usr/local/bin cocoapods</code></p>\n<p><code>pod setup</code>由于网络原因，会执行的很慢</p>\n<p>可以使用如下命令</p>\n<p><code>git clone https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git  ~/.cocoapods/repos/trunk</code></p>\n"},{"title":"OpenGL纹理加载与镜像","date":"2020-07-21T16:00:00.000Z","_content":"\n**OpenGL纹理加载步骤以及相关API**\n\n在准备工作`SetupRC`函数中\n\n```\n//分配纹理ID textureID\nglGenTextures(1, &textureID);\n    \n//将生成的纹理ID绑定到对应的目标纹理上\n//目标纹理只能是 GL_TEXTURE_1D或者GL_TEXTURE_2D\nglBindTexture(GL_TEXTURE_2D, textureID);\n```\n\n在渲染函数中不同的纹理需要一一对应再次绑定。\n\n载入纹理：\n\n```\n//将TGA加载为纹理\n/**\n fileName:纹理文件路径\n minFilter:\n magFilter:\n warpMode:\n */\nbool LoadTGATexture(const char *fileName, GLenum minFilter, GLenum magFilter, GLenum wrapMode) {\n    \n    //指向图像数据的指针\n    GLbyte *pBits;\n    \n    //纹理宽、高、组件\n    int nWidth, nHeight, nComponent;\n    //纹理格式 tga文件打印出来10进制为6407 对应的16进制为0x1907\n    //在glew.h中对应的宏为 #define GL_RGB 0x1907\n    GLenum eFormat;\n    \n    pBits = gltReadTGABits(fileName, &nWidth, &nHeight, &nComponent, &eFormat);\n    if (pBits == NULL) {\n        return false;\n    }\n    \n    //设置纹理参数\n    //wrapMode环绕模式 这里设置为 GL_CLAMP_TO_EDGE\n    //x y z 对应 GL_TEXTURE_WRAP_S GL_TEXTURE_WRAP_T GL_TEXTURE_WRAP_R\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrapMode);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrapMode);\n    \n    //设置过滤方式\n    //GL_TEXTURE_MIN_FILTER 和 GL_TEXTURE_MAG_FILTER 为缩小/放大过滤方式\n    //过滤方式常用：GL_NEAREST GL_LINEAR  临近过滤 和 线性过滤\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter);\n    \n    //载入纹理\n    //参数1:纹理维度\n    //参数2:level mip贴图层次\n    //参数3:纹理内部格式 接受：GL_ALPHA，GL_LUMINANCE，GL_LUMINANCE_ALPHA，GL_RGB，GL_RGBA\n    //参数4:宽度\n    //参数5:高度\n    //参数6:指定边框宽度 必须为0\n    //参数7:格式 接受 GL_ALPHA，GL_RGB，GL_RGBA，GL_LUMINANCE，和GL_LUMINANCE_ALPHA\n    //参数8:纹理数据类型 接受 GL_UNSIGNED_BYTE，GL_UNSIGNED_SHORT_5_6_5，GL_UNSIGNED_SHORT_4_4_4_4，和GL_UNSIGNED_SHORT_5_5_5_1\n    //参数9:指向纹理数据的指针\n    glTexImage2D(GL_TEXTURE_2D, 0, nComponent, nWidth, nHeight, 0, eFormat, GL_UNSIGNED_BYTE, pBits);\n    \n    //释放指针\n    free(pBits);\n    \n    //只有minFilter 等于以下四种模式，才可以生成Mip贴图\n    //GL_NEAREST_MIPMAP_NEAREST具有非常好的性能，并且闪烁现象非常弱\n    //GL_LINEAR_MIPMAP_NEAREST常常用于对游戏进行加速，它使用了高质量的线性过滤器\n    //GL_LINEAR_MIPMAP_LINEAR 和GL_NEAREST_MIPMAP_LINEAR 过滤器在Mip层之间执行了一些额外的插值，以消除他们之间的过滤痕迹。\n    //GL_LINEAR_MIPMAP_LINEAR 三线性Mip贴图。纹理过滤的黄金准则，具有最高的精度。\n    if(minFilter == GL_LINEAR_MIPMAP_LINEAR ||\n       minFilter == GL_LINEAR_MIPMAP_NEAREST ||\n       minFilter == GL_NEAREST_MIPMAP_LINEAR ||\n       minFilter == GL_NEAREST_MIPMAP_NEAREST)\n    //4.纹理生成所有的Mip层\n    //参数：GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D\n    glGenerateMipmap(GL_TEXTURE_2D);\n    \n    return true;\n}\n```\n\n记得在程序退出或者不再使用时，移除纹理ID\n```\nglDeleteTextures(1, &textureID);\n```\n\n**镜像**\n效果\n\n![qiu.gif](https://upload-images.jianshu.io/upload_images/1395687-af3c8a02f8d20ba5.gif?imageMogr2/auto-orient/strip)\n\n\n方案：\n主要是通过模型视图矩阵调用缩放函数，如下是把y坐标镜像，则y为-1，其他为1\n\n```\nmodelViewMatrix.Scale(1.0f, -1.0f, 1.0f);\n```\n\n为了使两个镜像的物体有间隔，沿y轴平移一定距离\n\n```\nmodelViewMatrix.Translate(0.0f, 0.8f, 0.0f);\n```\n\n然后画地板，为了更加生动形象，给地板设置一定透明度并开启混合。\n\n[demo]([https://github.com/ugpass/SphereWorld/tree/master](https://github.com/ugpass/SphereWorld/tree/master)\n) 使用[OpenGL macOS环境搭建(本地Pod引入)](https://www.jianshu.com/p/7f22654ab73c) pod方式导入库\n","source":"_posts/2020-07-22-OpenGL纹理加载与镜像.md","raw":"---\ntitle:      \"OpenGL纹理加载与镜像\" \ndate:       2020-07-22\ntags:\n    - OpenGL \ncategories:\n    - OpenGL \n---\n\n**OpenGL纹理加载步骤以及相关API**\n\n在准备工作`SetupRC`函数中\n\n```\n//分配纹理ID textureID\nglGenTextures(1, &textureID);\n    \n//将生成的纹理ID绑定到对应的目标纹理上\n//目标纹理只能是 GL_TEXTURE_1D或者GL_TEXTURE_2D\nglBindTexture(GL_TEXTURE_2D, textureID);\n```\n\n在渲染函数中不同的纹理需要一一对应再次绑定。\n\n载入纹理：\n\n```\n//将TGA加载为纹理\n/**\n fileName:纹理文件路径\n minFilter:\n magFilter:\n warpMode:\n */\nbool LoadTGATexture(const char *fileName, GLenum minFilter, GLenum magFilter, GLenum wrapMode) {\n    \n    //指向图像数据的指针\n    GLbyte *pBits;\n    \n    //纹理宽、高、组件\n    int nWidth, nHeight, nComponent;\n    //纹理格式 tga文件打印出来10进制为6407 对应的16进制为0x1907\n    //在glew.h中对应的宏为 #define GL_RGB 0x1907\n    GLenum eFormat;\n    \n    pBits = gltReadTGABits(fileName, &nWidth, &nHeight, &nComponent, &eFormat);\n    if (pBits == NULL) {\n        return false;\n    }\n    \n    //设置纹理参数\n    //wrapMode环绕模式 这里设置为 GL_CLAMP_TO_EDGE\n    //x y z 对应 GL_TEXTURE_WRAP_S GL_TEXTURE_WRAP_T GL_TEXTURE_WRAP_R\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrapMode);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrapMode);\n    \n    //设置过滤方式\n    //GL_TEXTURE_MIN_FILTER 和 GL_TEXTURE_MAG_FILTER 为缩小/放大过滤方式\n    //过滤方式常用：GL_NEAREST GL_LINEAR  临近过滤 和 线性过滤\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, minFilter);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, magFilter);\n    \n    //载入纹理\n    //参数1:纹理维度\n    //参数2:level mip贴图层次\n    //参数3:纹理内部格式 接受：GL_ALPHA，GL_LUMINANCE，GL_LUMINANCE_ALPHA，GL_RGB，GL_RGBA\n    //参数4:宽度\n    //参数5:高度\n    //参数6:指定边框宽度 必须为0\n    //参数7:格式 接受 GL_ALPHA，GL_RGB，GL_RGBA，GL_LUMINANCE，和GL_LUMINANCE_ALPHA\n    //参数8:纹理数据类型 接受 GL_UNSIGNED_BYTE，GL_UNSIGNED_SHORT_5_6_5，GL_UNSIGNED_SHORT_4_4_4_4，和GL_UNSIGNED_SHORT_5_5_5_1\n    //参数9:指向纹理数据的指针\n    glTexImage2D(GL_TEXTURE_2D, 0, nComponent, nWidth, nHeight, 0, eFormat, GL_UNSIGNED_BYTE, pBits);\n    \n    //释放指针\n    free(pBits);\n    \n    //只有minFilter 等于以下四种模式，才可以生成Mip贴图\n    //GL_NEAREST_MIPMAP_NEAREST具有非常好的性能，并且闪烁现象非常弱\n    //GL_LINEAR_MIPMAP_NEAREST常常用于对游戏进行加速，它使用了高质量的线性过滤器\n    //GL_LINEAR_MIPMAP_LINEAR 和GL_NEAREST_MIPMAP_LINEAR 过滤器在Mip层之间执行了一些额外的插值，以消除他们之间的过滤痕迹。\n    //GL_LINEAR_MIPMAP_LINEAR 三线性Mip贴图。纹理过滤的黄金准则，具有最高的精度。\n    if(minFilter == GL_LINEAR_MIPMAP_LINEAR ||\n       minFilter == GL_LINEAR_MIPMAP_NEAREST ||\n       minFilter == GL_NEAREST_MIPMAP_LINEAR ||\n       minFilter == GL_NEAREST_MIPMAP_NEAREST)\n    //4.纹理生成所有的Mip层\n    //参数：GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D\n    glGenerateMipmap(GL_TEXTURE_2D);\n    \n    return true;\n}\n```\n\n记得在程序退出或者不再使用时，移除纹理ID\n```\nglDeleteTextures(1, &textureID);\n```\n\n**镜像**\n效果\n\n![qiu.gif](https://upload-images.jianshu.io/upload_images/1395687-af3c8a02f8d20ba5.gif?imageMogr2/auto-orient/strip)\n\n\n方案：\n主要是通过模型视图矩阵调用缩放函数，如下是把y坐标镜像，则y为-1，其他为1\n\n```\nmodelViewMatrix.Scale(1.0f, -1.0f, 1.0f);\n```\n\n为了使两个镜像的物体有间隔，沿y轴平移一定距离\n\n```\nmodelViewMatrix.Translate(0.0f, 0.8f, 0.0f);\n```\n\n然后画地板，为了更加生动形象，给地板设置一定透明度并开启混合。\n\n[demo]([https://github.com/ugpass/SphereWorld/tree/master](https://github.com/ugpass/SphereWorld/tree/master)\n) 使用[OpenGL macOS环境搭建(本地Pod引入)](https://www.jianshu.com/p/7f22654ab73c) pod方式导入库\n","slug":"2020-07-22-OpenGL纹理加载与镜像","published":1,"updated":"2021-06-19T03:46:24.085Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbpm0010bjrj0s3q9bw9","content":"<p><strong>OpenGL纹理加载步骤以及相关API</strong></p>\n<p>在准备工作<code>SetupRC</code>函数中</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//分配纹理ID textureID</span></span><br><span class=\"line\">gl<span class=\"constructor\">GenTextures(1, &amp;<span class=\"params\">textureID</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//将生成的纹理ID绑定到对应的目标纹理上</span></span><br><span class=\"line\"><span class=\"comment\">//目标纹理只能是 GL_TEXTURE_1D或者GL_TEXTURE_2D</span></span><br><span class=\"line\">gl<span class=\"constructor\">BindTexture(GL_TEXTURE_2D, <span class=\"params\">textureID</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在渲染函数中不同的纹理需要一一对应再次绑定。</p>\n<p>载入纹理：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将TGA加载为纹理</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> fileName:纹理文件路径</span></span><br><span class=\"line\"><span class=\"comment\"> minFilter:</span></span><br><span class=\"line\"><span class=\"comment\"> magFilter:</span></span><br><span class=\"line\"><span class=\"comment\"> warpMode:</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"built_in\">bool</span> <span class=\"constructor\">LoadTGATexture(<span class=\"params\">const</span> <span class=\"params\">char</span> <span class=\"operator\">*</span><span class=\"params\">fileName</span>, GLenum <span class=\"params\">minFilter</span>, GLenum <span class=\"params\">magFilter</span>, GLenum <span class=\"params\">wrapMode</span>)</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//指向图像数据的指针</span></span><br><span class=\"line\">    GLbyte *pBits;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//纹理宽、高、组件</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> nWidth, nHeight, nComponent;</span><br><span class=\"line\">    <span class=\"comment\">//纹理格式 tga文件打印出来10进制为6407 对应的16进制为0x1907</span></span><br><span class=\"line\">    <span class=\"comment\">//在glew.h中对应的宏为 #define GL_RGB 0x1907</span></span><br><span class=\"line\">    GLenum eFormat;</span><br><span class=\"line\">    </span><br><span class=\"line\">    pBits = glt<span class=\"constructor\">ReadTGABits(<span class=\"params\">fileName</span>, &amp;<span class=\"params\">nWidth</span>, &amp;<span class=\"params\">nHeight</span>, &amp;<span class=\"params\">nComponent</span>, &amp;<span class=\"params\">eFormat</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pBits<span class=\"operator\"> == </span>NULL) &#123;</span><br><span class=\"line\">        return <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置纹理参数</span></span><br><span class=\"line\">    <span class=\"comment\">//wrapMode环绕模式 这里设置为 GL_CLAMP_TO_EDGE</span></span><br><span class=\"line\">    <span class=\"comment\">//x y z 对应 GL_TEXTURE_WRAP_S GL_TEXTURE_WRAP_T GL_TEXTURE_WRAP_R</span></span><br><span class=\"line\">    gl<span class=\"constructor\">TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, <span class=\"params\">wrapMode</span>)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, <span class=\"params\">wrapMode</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置过滤方式</span></span><br><span class=\"line\">    <span class=\"comment\">//GL_TEXTURE_MIN_FILTER 和 GL_TEXTURE_MAG_FILTER 为缩小/放大过滤方式</span></span><br><span class=\"line\">    <span class=\"comment\">//过滤方式常用：GL_NEAREST GL_LINEAR  临近过滤 和 线性过滤</span></span><br><span class=\"line\">    gl<span class=\"constructor\">TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, <span class=\"params\">minFilter</span>)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, <span class=\"params\">magFilter</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//载入纹理</span></span><br><span class=\"line\">    <span class=\"comment\">//参数1:纹理维度</span></span><br><span class=\"line\">    <span class=\"comment\">//参数2:level mip贴图层次</span></span><br><span class=\"line\">    <span class=\"comment\">//参数3:纹理内部格式 接受：GL_ALPHA，GL_LUMINANCE，GL_LUMINANCE_ALPHA，GL_RGB，GL_RGBA</span></span><br><span class=\"line\">    <span class=\"comment\">//参数4:宽度</span></span><br><span class=\"line\">    <span class=\"comment\">//参数5:高度</span></span><br><span class=\"line\">    <span class=\"comment\">//参数6:指定边框宽度 必须为0</span></span><br><span class=\"line\">    <span class=\"comment\">//参数7:格式 接受 GL_ALPHA，GL_RGB，GL_RGBA，GL_LUMINANCE，和GL_LUMINANCE_ALPHA</span></span><br><span class=\"line\">    <span class=\"comment\">//参数8:纹理数据类型 接受 GL_UNSIGNED_BYTE，GL_UNSIGNED_SHORT_5_6_5，GL_UNSIGNED_SHORT_4_4_4_4，和GL_UNSIGNED_SHORT_5_5_5_1</span></span><br><span class=\"line\">    <span class=\"comment\">//参数9:指向纹理数据的指针</span></span><br><span class=\"line\">    gl<span class=\"constructor\">TexImage2D(GL_TEXTURE_2D, 0, <span class=\"params\">nComponent</span>, <span class=\"params\">nWidth</span>, <span class=\"params\">nHeight</span>, 0, <span class=\"params\">eFormat</span>, GL_UNSIGNED_BYTE, <span class=\"params\">pBits</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//释放指针</span></span><br><span class=\"line\">    free(pBits);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//只有minFilter 等于以下四种模式，才可以生成Mip贴图</span></span><br><span class=\"line\">    <span class=\"comment\">//GL_NEAREST_MIPMAP_NEAREST具有非常好的性能，并且闪烁现象非常弱</span></span><br><span class=\"line\">    <span class=\"comment\">//GL_LINEAR_MIPMAP_NEAREST常常用于对游戏进行加速，它使用了高质量的线性过滤器</span></span><br><span class=\"line\">    <span class=\"comment\">//GL_LINEAR_MIPMAP_LINEAR 和GL_NEAREST_MIPMAP_LINEAR 过滤器在Mip层之间执行了一些额外的插值，以消除他们之间的过滤痕迹。</span></span><br><span class=\"line\">    <span class=\"comment\">//GL_LINEAR_MIPMAP_LINEAR 三线性Mip贴图。纹理过滤的黄金准则，具有最高的精度。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(minFilter<span class=\"operator\"> == </span>GL_LINEAR_MIPMAP_LINEAR <span class=\"pattern-match\"><span class=\"operator\">||</span></span></span><br><span class=\"line\"><span class=\"pattern-match\">       min<span class=\"constructor\">Filter</span> <span class=\"operator\">==</span> <span class=\"constructor\">GL_LINEAR_MIPMAP_NEAREST</span> <span class=\"operator\">||</span></span></span><br><span class=\"line\"><span class=\"pattern-match\">       min<span class=\"constructor\">Filter</span> <span class=\"operator\">==</span> <span class=\"constructor\">GL_NEAREST_MIPMAP_LINEAR</span> <span class=\"operator\">||</span></span></span><br><span class=\"line\"><span class=\"pattern-match\">       min<span class=\"constructor\">Filter</span> <span class=\"operator\">==</span> <span class=\"constructor\">GL_NEAREST_MIPMAP_NEAREST</span>)</span></span><br><span class=\"line\"><span class=\"pattern-match\">    <span class=\"operator\">/</span><span class=\"operator\">/</span>4.纹理生成所有的<span class=\"constructor\">Mip</span>层</span></span><br><span class=\"line\"><span class=\"pattern-match\">    <span class=\"operator\">/</span><span class=\"operator\">/</span>参数：<span class=\"constructor\">GL_TEXTURE_1D</span>、<span class=\"constructor\">GL_TEXTURE_2D</span>、<span class=\"constructor\">GL_TEXTURE_3D</span></span></span><br><span class=\"line\"><span class=\"pattern-match\">    gl<span class=\"constructor\">GenerateMipmap(GL_TEXTURE_2D)</span>;</span></span><br><span class=\"line\"><span class=\"pattern-match\">    </span></span><br><span class=\"line\"><span class=\"pattern-match\">    return <span class=\"literal\">true</span>;</span></span><br><span class=\"line\"><span class=\"pattern-match\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>记得在程序退出或者不再使用时，移除纹理ID</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glDeleteTextures(<span class=\"number\">1</span>, <span class=\"symbol\">&amp;textureID</span>)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>镜像</strong><br>效果</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-af3c8a02f8d20ba5.gif?imageMogr2/auto-orient/strip\" alt=\"qiu.gif\"></p>\n<p>方案：<br>主要是通过模型视图矩阵调用缩放函数，如下是把y坐标镜像，则y为-1，其他为1</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">modelViewMatrix</span>.Scale(<span class=\"number\">1</span>.<span class=\"number\">0</span>f, -<span class=\"number\">1</span>.<span class=\"number\">0</span>f, <span class=\"number\">1</span>.<span class=\"number\">0</span>f);</span><br></pre></td></tr></table></figure>\n\n<p>为了使两个镜像的物体有间隔，沿y轴平移一定距离</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">modelViewMatrix</span>.Translate(<span class=\"number\">0</span>.<span class=\"number\">0</span>f, <span class=\"number\">0</span>.<span class=\"number\">8</span>f, <span class=\"number\">0</span>.<span class=\"number\">0</span>f);</span><br></pre></td></tr></table></figure>\n\n<p>然后画地板，为了更加生动形象，给地板设置一定透明度并开启混合。</p>\n<p><a href=\"%5Bhttps://github.com/ugpass/SphereWorld/tree/master%5D(https://github.com/ugpass/SphereWorld/tree/master)\">demo</a> 使用<a href=\"https://www.jianshu.com/p/7f22654ab73c\">OpenGL macOS环境搭建(本地Pod引入)</a> pod方式导入库</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>OpenGL纹理加载步骤以及相关API</strong></p>\n<p>在准备工作<code>SetupRC</code>函数中</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//分配纹理ID textureID</span></span><br><span class=\"line\">gl<span class=\"constructor\">GenTextures(1, &amp;<span class=\"params\">textureID</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//将生成的纹理ID绑定到对应的目标纹理上</span></span><br><span class=\"line\"><span class=\"comment\">//目标纹理只能是 GL_TEXTURE_1D或者GL_TEXTURE_2D</span></span><br><span class=\"line\">gl<span class=\"constructor\">BindTexture(GL_TEXTURE_2D, <span class=\"params\">textureID</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在渲染函数中不同的纹理需要一一对应再次绑定。</p>\n<p>载入纹理：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将TGA加载为纹理</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> fileName:纹理文件路径</span></span><br><span class=\"line\"><span class=\"comment\"> minFilter:</span></span><br><span class=\"line\"><span class=\"comment\"> magFilter:</span></span><br><span class=\"line\"><span class=\"comment\"> warpMode:</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"built_in\">bool</span> <span class=\"constructor\">LoadTGATexture(<span class=\"params\">const</span> <span class=\"params\">char</span> <span class=\"operator\">*</span><span class=\"params\">fileName</span>, GLenum <span class=\"params\">minFilter</span>, GLenum <span class=\"params\">magFilter</span>, GLenum <span class=\"params\">wrapMode</span>)</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//指向图像数据的指针</span></span><br><span class=\"line\">    GLbyte *pBits;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//纹理宽、高、组件</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> nWidth, nHeight, nComponent;</span><br><span class=\"line\">    <span class=\"comment\">//纹理格式 tga文件打印出来10进制为6407 对应的16进制为0x1907</span></span><br><span class=\"line\">    <span class=\"comment\">//在glew.h中对应的宏为 #define GL_RGB 0x1907</span></span><br><span class=\"line\">    GLenum eFormat;</span><br><span class=\"line\">    </span><br><span class=\"line\">    pBits = glt<span class=\"constructor\">ReadTGABits(<span class=\"params\">fileName</span>, &amp;<span class=\"params\">nWidth</span>, &amp;<span class=\"params\">nHeight</span>, &amp;<span class=\"params\">nComponent</span>, &amp;<span class=\"params\">eFormat</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pBits<span class=\"operator\"> == </span>NULL) &#123;</span><br><span class=\"line\">        return <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置纹理参数</span></span><br><span class=\"line\">    <span class=\"comment\">//wrapMode环绕模式 这里设置为 GL_CLAMP_TO_EDGE</span></span><br><span class=\"line\">    <span class=\"comment\">//x y z 对应 GL_TEXTURE_WRAP_S GL_TEXTURE_WRAP_T GL_TEXTURE_WRAP_R</span></span><br><span class=\"line\">    gl<span class=\"constructor\">TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, <span class=\"params\">wrapMode</span>)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, <span class=\"params\">wrapMode</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置过滤方式</span></span><br><span class=\"line\">    <span class=\"comment\">//GL_TEXTURE_MIN_FILTER 和 GL_TEXTURE_MAG_FILTER 为缩小/放大过滤方式</span></span><br><span class=\"line\">    <span class=\"comment\">//过滤方式常用：GL_NEAREST GL_LINEAR  临近过滤 和 线性过滤</span></span><br><span class=\"line\">    gl<span class=\"constructor\">TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, <span class=\"params\">minFilter</span>)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, <span class=\"params\">magFilter</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//载入纹理</span></span><br><span class=\"line\">    <span class=\"comment\">//参数1:纹理维度</span></span><br><span class=\"line\">    <span class=\"comment\">//参数2:level mip贴图层次</span></span><br><span class=\"line\">    <span class=\"comment\">//参数3:纹理内部格式 接受：GL_ALPHA，GL_LUMINANCE，GL_LUMINANCE_ALPHA，GL_RGB，GL_RGBA</span></span><br><span class=\"line\">    <span class=\"comment\">//参数4:宽度</span></span><br><span class=\"line\">    <span class=\"comment\">//参数5:高度</span></span><br><span class=\"line\">    <span class=\"comment\">//参数6:指定边框宽度 必须为0</span></span><br><span class=\"line\">    <span class=\"comment\">//参数7:格式 接受 GL_ALPHA，GL_RGB，GL_RGBA，GL_LUMINANCE，和GL_LUMINANCE_ALPHA</span></span><br><span class=\"line\">    <span class=\"comment\">//参数8:纹理数据类型 接受 GL_UNSIGNED_BYTE，GL_UNSIGNED_SHORT_5_6_5，GL_UNSIGNED_SHORT_4_4_4_4，和GL_UNSIGNED_SHORT_5_5_5_1</span></span><br><span class=\"line\">    <span class=\"comment\">//参数9:指向纹理数据的指针</span></span><br><span class=\"line\">    gl<span class=\"constructor\">TexImage2D(GL_TEXTURE_2D, 0, <span class=\"params\">nComponent</span>, <span class=\"params\">nWidth</span>, <span class=\"params\">nHeight</span>, 0, <span class=\"params\">eFormat</span>, GL_UNSIGNED_BYTE, <span class=\"params\">pBits</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//释放指针</span></span><br><span class=\"line\">    free(pBits);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//只有minFilter 等于以下四种模式，才可以生成Mip贴图</span></span><br><span class=\"line\">    <span class=\"comment\">//GL_NEAREST_MIPMAP_NEAREST具有非常好的性能，并且闪烁现象非常弱</span></span><br><span class=\"line\">    <span class=\"comment\">//GL_LINEAR_MIPMAP_NEAREST常常用于对游戏进行加速，它使用了高质量的线性过滤器</span></span><br><span class=\"line\">    <span class=\"comment\">//GL_LINEAR_MIPMAP_LINEAR 和GL_NEAREST_MIPMAP_LINEAR 过滤器在Mip层之间执行了一些额外的插值，以消除他们之间的过滤痕迹。</span></span><br><span class=\"line\">    <span class=\"comment\">//GL_LINEAR_MIPMAP_LINEAR 三线性Mip贴图。纹理过滤的黄金准则，具有最高的精度。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(minFilter<span class=\"operator\"> == </span>GL_LINEAR_MIPMAP_LINEAR <span class=\"pattern-match\"><span class=\"operator\">||</span></span></span><br><span class=\"line\"><span class=\"pattern-match\">       min<span class=\"constructor\">Filter</span> <span class=\"operator\">==</span> <span class=\"constructor\">GL_LINEAR_MIPMAP_NEAREST</span> <span class=\"operator\">||</span></span></span><br><span class=\"line\"><span class=\"pattern-match\">       min<span class=\"constructor\">Filter</span> <span class=\"operator\">==</span> <span class=\"constructor\">GL_NEAREST_MIPMAP_LINEAR</span> <span class=\"operator\">||</span></span></span><br><span class=\"line\"><span class=\"pattern-match\">       min<span class=\"constructor\">Filter</span> <span class=\"operator\">==</span> <span class=\"constructor\">GL_NEAREST_MIPMAP_NEAREST</span>)</span></span><br><span class=\"line\"><span class=\"pattern-match\">    <span class=\"operator\">/</span><span class=\"operator\">/</span>4.纹理生成所有的<span class=\"constructor\">Mip</span>层</span></span><br><span class=\"line\"><span class=\"pattern-match\">    <span class=\"operator\">/</span><span class=\"operator\">/</span>参数：<span class=\"constructor\">GL_TEXTURE_1D</span>、<span class=\"constructor\">GL_TEXTURE_2D</span>、<span class=\"constructor\">GL_TEXTURE_3D</span></span></span><br><span class=\"line\"><span class=\"pattern-match\">    gl<span class=\"constructor\">GenerateMipmap(GL_TEXTURE_2D)</span>;</span></span><br><span class=\"line\"><span class=\"pattern-match\">    </span></span><br><span class=\"line\"><span class=\"pattern-match\">    return <span class=\"literal\">true</span>;</span></span><br><span class=\"line\"><span class=\"pattern-match\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>记得在程序退出或者不再使用时，移除纹理ID</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glDeleteTextures(<span class=\"number\">1</span>, <span class=\"symbol\">&amp;textureID</span>)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>镜像</strong><br>效果</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-af3c8a02f8d20ba5.gif?imageMogr2/auto-orient/strip\" alt=\"qiu.gif\"></p>\n<p>方案：<br>主要是通过模型视图矩阵调用缩放函数，如下是把y坐标镜像，则y为-1，其他为1</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">modelViewMatrix</span>.Scale(<span class=\"number\">1</span>.<span class=\"number\">0</span>f, -<span class=\"number\">1</span>.<span class=\"number\">0</span>f, <span class=\"number\">1</span>.<span class=\"number\">0</span>f);</span><br></pre></td></tr></table></figure>\n\n<p>为了使两个镜像的物体有间隔，沿y轴平移一定距离</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">modelViewMatrix</span>.Translate(<span class=\"number\">0</span>.<span class=\"number\">0</span>f, <span class=\"number\">0</span>.<span class=\"number\">8</span>f, <span class=\"number\">0</span>.<span class=\"number\">0</span>f);</span><br></pre></td></tr></table></figure>\n\n<p>然后画地板，为了更加生动形象，给地板设置一定透明度并开启混合。</p>\n<p><a href=\"%5Bhttps://github.com/ugpass/SphereWorld/tree/master%5D(https://github.com/ugpass/SphereWorld/tree/master)\">demo</a> 使用<a href=\"https://www.jianshu.com/p/7f22654ab73c\">OpenGL macOS环境搭建(本地Pod引入)</a> pod方式导入库</p>\n"},{"title":"OpenGL ES&GLKit加载纹理","date":"2020-07-27T16:00:00.000Z","_content":"\n1.需要导入 `GLKit.framework`\n\n2.在`ViewController`中导入\n\n```\n#import <GLKit/GLKit.h>\n\n#import <OpenGLES/ES3/gl.h>\n#import <OpenGLES/ES3/glext.h>\n```\n\n3.如果将`ViewController`的父类改为`GLKViewController`,则同时需要将`Main.storyboard`中的view的类别改为`GLKView`\n![修改view类别.png](https://upload-images.jianshu.io/upload_images/1395687-259961490eb4539a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当然也可以不修改`ViewController`的父类，直接在`ViewController`中自定义`GLKView`\n\n```\n@property (nonatomic, strong) GLKView *glkView;\n```\n\n4.创建EAGLContext，并设置为当前Context\n\n```\n//1.配置初始环境\n- (void)setUpConfig {\n    //创建EAGLContext 并设置为currentContext\n    _context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];\n    if (!_context) {\n        NSLog(@\"_context create failed\");\n    }\n    [EAGLContext setCurrentContext:_context];\n    \n    //配置glkView\n    GLKView *glkView = (GLKView *)self.view;\n    glkView.context = _context;\n    //开启颜色缓冲区\n    glkView.drawableColorFormat = GLKViewDrawableColorFormatRGBA8888;\n    //开启深度测试缓冲区\n    glkView.drawableDepthFormat = GLKViewDrawableDepthFormatNone;\n    \n    //设置glkView的背景颜色\n    glClearColor(1.0, 0.0, 0.0, 1.0);\n}\n```\n\n5.设置顶点数据以及纹理数据 拷贝到顶点缓冲区\n\n```\n//设置顶点数据以及纹理数据 拷贝到顶点缓冲区\n-(void)setUpVertexData\n{\n    //1.设置顶点数组(顶点坐标,纹理坐标)\n    /*\n     纹理坐标系取值范围[0,1];原点是左下角(0,0);\n     故而(0,0)是纹理图像的左下角, 点(1,1)是右上角.\n     */\n    GLfloat vertexData[] = {\n        \n        0.5, -0.5, 0.0f,    1.0f, 0.0f, //右下\n        0.5, 0.5,  0.0f,    1.0f, 1.0f, //右上\n        -0.5, 0.5, 0.0f,    0.0f, 1.0f, //左上\n        \n        0.5, -0.5, 0.0f,    1.0f, 0.0f, //右下\n        -0.5, 0.5, 0.0f,    0.0f, 1.0f, //左上\n        -0.5, -0.5, 0.0f,   0.0f, 0.0f, //左下\n    };\n \n    /*\n     顶点数组: 开发者可以选择设定函数指针，在调用绘制方法的时候，直接由内存传入顶点数据，也就是说这部分数据之前是存储在内存当中的，被称为顶点数组\n     \n     顶点缓存区: 性能更高的做法是，提前分配一块显存，将顶点数据预先传入到显存当中。这部分的显存，就被称为顶点缓冲区\n     */\n    \n    //2.开辟顶点缓存区\n    //(1).创建顶点缓存区标识符ID\n    GLuint bufferID;\n    glGenBuffers(1, &bufferID);\n    //(2).绑定顶点缓存区.(明确作用)\n    glBindBuffer(GL_ARRAY_BUFFER, bufferID);\n    //(3).将顶点数组的数据copy到顶点缓存区中(GPU显存中)\n    glBufferData(GL_ARRAY_BUFFER, sizeof(vertexData), vertexData, GL_STATIC_DRAW);\n    \n    //3.打开读取通道.\n    /*\n     (1)在iOS中, 默认情况下，出于性能考虑，所有顶点着色器的属性（Attribute）变量都是关闭的.\n     意味着,顶点数据在着色器端(服务端)是不可用的. 即使你已经使用glBufferData方法,将顶点数据从内存拷贝到顶点缓存区中(GPU显存中).\n     所以, 必须由glEnableVertexAttribArray 方法打开通道.指定访问属性.才能让顶点着色器能够访问到从CPU复制到GPU的数据.\n     注意: 数据在GPU端是否可见，即，着色器能否读取到数据，由是否启用了对应的属性决定，这就是glEnableVertexAttribArray的功能，允许顶点着色器读取GPU（服务器端）数据。\n   \n    (2)方法简介\n    glVertexAttribPointer (GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* ptr)\n   \n    功能: 上传顶点数据到显存的方法（设置合适的方式从buffer里面读取数据）\n    参数列表:\n        index,指定要修改的顶点属性的索引值,例如\n        size, 每次读取数量。（如position是由3个（x,y,z）组成，而颜色是4个（r,g,b,a）,纹理则是2个.）\n        type,指定数组中每个组件的数据类型。可用的符号常量有GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT,GL_UNSIGNED_SHORT, GL_FIXED, 和 GL_FLOAT，初始值为GL_FLOAT。\n        normalized,指定当被访问时，固定点数据值是否应该被归一化（GL_TRUE）或者直接转换为固定点值（GL_FALSE）\n        stride,指定连续顶点属性之间的偏移量。如果为0，那么顶点属性会被理解为：它们是紧密排列在一起的。初始值为0\n        ptr指定一个指针，指向数组中第一个顶点属性的第一个组件。初始值为0\n     */\n    \n    //顶点坐标数据\n    glEnableVertexAttribArray(GLKVertexAttribPosition);\n    glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 5, (GLfloat *)NULL + 0);\n    \n    \n    //纹理坐标数据\n    glEnableVertexAttribArray(GLKVertexAttribTexCoord0);\n    glVertexAttribPointer(GLKVertexAttribTexCoord0, 2, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 5, (GLfloat *)NULL + 3);\n \n}\n```\n\n6.加载纹理\n\n```\n//加载纹理\n-(void)setUpTexture\n{\n    //1.获取纹理图片路径\n    NSString *filePath = [[NSBundle mainBundle] pathForResource:@\"mew_interlaced\" ofType:@\"png\"];\n    \n    //2.设置纹理参数\n    //纹理坐标原点是左下角,但是图片显示原点应该是左上角.\n    NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys:@(1),GLKTextureLoaderOriginBottomLeft, nil];\n    \n    GLKTextureInfo *textureInfo = [GLKTextureLoader textureWithContentsOfFile:filePath options:options error:nil];\n    \n    //3.使用苹果GLKit 提供GLKBaseEffect 完成着色器工作(顶点/片元)\n    cEffect = [[GLKBaseEffect alloc]init];\n    cEffect.texture2d0.enabled = GL_TRUE;\n    cEffect.texture2d0.name = textureInfo.name;\n}\n```\n\n7.实现GLKView代理  绘制视图，如果是自定义`GLKView`需要设置当前控制器为代理\n\n```\n#pragma mark -- GLKViewDelegate\n//绘制视图的内容\n/*\n GLKView对象使其OpenGL ES上下文成为当前上下文，并将其framebuffer绑定为OpenGL ES呈现命令的目标。然后，委托方法应该绘制视图的内容。\n*/\n- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect\n{\n    //1.清理颜色缓冲区、深度缓冲区、模型缓冲区\n    glClear(GL_COLOR_BUFFER_BIT);\n    \n    //2.准备绘制\n    [cEffect prepareToDraw];\n    \n    //3.开始绘制\n    glDrawArrays(GL_TRIANGLES, 0, 6);\n    \n}\n```","source":"_posts/2020-07-28-OpenGL ES&GLKit加载纹理.md","raw":"---\ntitle:      \"OpenGL ES&GLKit加载纹理\" \ndate:       2020-07-28\ntags:\n    - OpenGL ES \ncategories:\n    - OpenGL ES \n---\n\n1.需要导入 `GLKit.framework`\n\n2.在`ViewController`中导入\n\n```\n#import <GLKit/GLKit.h>\n\n#import <OpenGLES/ES3/gl.h>\n#import <OpenGLES/ES3/glext.h>\n```\n\n3.如果将`ViewController`的父类改为`GLKViewController`,则同时需要将`Main.storyboard`中的view的类别改为`GLKView`\n![修改view类别.png](https://upload-images.jianshu.io/upload_images/1395687-259961490eb4539a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当然也可以不修改`ViewController`的父类，直接在`ViewController`中自定义`GLKView`\n\n```\n@property (nonatomic, strong) GLKView *glkView;\n```\n\n4.创建EAGLContext，并设置为当前Context\n\n```\n//1.配置初始环境\n- (void)setUpConfig {\n    //创建EAGLContext 并设置为currentContext\n    _context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];\n    if (!_context) {\n        NSLog(@\"_context create failed\");\n    }\n    [EAGLContext setCurrentContext:_context];\n    \n    //配置glkView\n    GLKView *glkView = (GLKView *)self.view;\n    glkView.context = _context;\n    //开启颜色缓冲区\n    glkView.drawableColorFormat = GLKViewDrawableColorFormatRGBA8888;\n    //开启深度测试缓冲区\n    glkView.drawableDepthFormat = GLKViewDrawableDepthFormatNone;\n    \n    //设置glkView的背景颜色\n    glClearColor(1.0, 0.0, 0.0, 1.0);\n}\n```\n\n5.设置顶点数据以及纹理数据 拷贝到顶点缓冲区\n\n```\n//设置顶点数据以及纹理数据 拷贝到顶点缓冲区\n-(void)setUpVertexData\n{\n    //1.设置顶点数组(顶点坐标,纹理坐标)\n    /*\n     纹理坐标系取值范围[0,1];原点是左下角(0,0);\n     故而(0,0)是纹理图像的左下角, 点(1,1)是右上角.\n     */\n    GLfloat vertexData[] = {\n        \n        0.5, -0.5, 0.0f,    1.0f, 0.0f, //右下\n        0.5, 0.5,  0.0f,    1.0f, 1.0f, //右上\n        -0.5, 0.5, 0.0f,    0.0f, 1.0f, //左上\n        \n        0.5, -0.5, 0.0f,    1.0f, 0.0f, //右下\n        -0.5, 0.5, 0.0f,    0.0f, 1.0f, //左上\n        -0.5, -0.5, 0.0f,   0.0f, 0.0f, //左下\n    };\n \n    /*\n     顶点数组: 开发者可以选择设定函数指针，在调用绘制方法的时候，直接由内存传入顶点数据，也就是说这部分数据之前是存储在内存当中的，被称为顶点数组\n     \n     顶点缓存区: 性能更高的做法是，提前分配一块显存，将顶点数据预先传入到显存当中。这部分的显存，就被称为顶点缓冲区\n     */\n    \n    //2.开辟顶点缓存区\n    //(1).创建顶点缓存区标识符ID\n    GLuint bufferID;\n    glGenBuffers(1, &bufferID);\n    //(2).绑定顶点缓存区.(明确作用)\n    glBindBuffer(GL_ARRAY_BUFFER, bufferID);\n    //(3).将顶点数组的数据copy到顶点缓存区中(GPU显存中)\n    glBufferData(GL_ARRAY_BUFFER, sizeof(vertexData), vertexData, GL_STATIC_DRAW);\n    \n    //3.打开读取通道.\n    /*\n     (1)在iOS中, 默认情况下，出于性能考虑，所有顶点着色器的属性（Attribute）变量都是关闭的.\n     意味着,顶点数据在着色器端(服务端)是不可用的. 即使你已经使用glBufferData方法,将顶点数据从内存拷贝到顶点缓存区中(GPU显存中).\n     所以, 必须由glEnableVertexAttribArray 方法打开通道.指定访问属性.才能让顶点着色器能够访问到从CPU复制到GPU的数据.\n     注意: 数据在GPU端是否可见，即，着色器能否读取到数据，由是否启用了对应的属性决定，这就是glEnableVertexAttribArray的功能，允许顶点着色器读取GPU（服务器端）数据。\n   \n    (2)方法简介\n    glVertexAttribPointer (GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* ptr)\n   \n    功能: 上传顶点数据到显存的方法（设置合适的方式从buffer里面读取数据）\n    参数列表:\n        index,指定要修改的顶点属性的索引值,例如\n        size, 每次读取数量。（如position是由3个（x,y,z）组成，而颜色是4个（r,g,b,a）,纹理则是2个.）\n        type,指定数组中每个组件的数据类型。可用的符号常量有GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT,GL_UNSIGNED_SHORT, GL_FIXED, 和 GL_FLOAT，初始值为GL_FLOAT。\n        normalized,指定当被访问时，固定点数据值是否应该被归一化（GL_TRUE）或者直接转换为固定点值（GL_FALSE）\n        stride,指定连续顶点属性之间的偏移量。如果为0，那么顶点属性会被理解为：它们是紧密排列在一起的。初始值为0\n        ptr指定一个指针，指向数组中第一个顶点属性的第一个组件。初始值为0\n     */\n    \n    //顶点坐标数据\n    glEnableVertexAttribArray(GLKVertexAttribPosition);\n    glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 5, (GLfloat *)NULL + 0);\n    \n    \n    //纹理坐标数据\n    glEnableVertexAttribArray(GLKVertexAttribTexCoord0);\n    glVertexAttribPointer(GLKVertexAttribTexCoord0, 2, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 5, (GLfloat *)NULL + 3);\n \n}\n```\n\n6.加载纹理\n\n```\n//加载纹理\n-(void)setUpTexture\n{\n    //1.获取纹理图片路径\n    NSString *filePath = [[NSBundle mainBundle] pathForResource:@\"mew_interlaced\" ofType:@\"png\"];\n    \n    //2.设置纹理参数\n    //纹理坐标原点是左下角,但是图片显示原点应该是左上角.\n    NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys:@(1),GLKTextureLoaderOriginBottomLeft, nil];\n    \n    GLKTextureInfo *textureInfo = [GLKTextureLoader textureWithContentsOfFile:filePath options:options error:nil];\n    \n    //3.使用苹果GLKit 提供GLKBaseEffect 完成着色器工作(顶点/片元)\n    cEffect = [[GLKBaseEffect alloc]init];\n    cEffect.texture2d0.enabled = GL_TRUE;\n    cEffect.texture2d0.name = textureInfo.name;\n}\n```\n\n7.实现GLKView代理  绘制视图，如果是自定义`GLKView`需要设置当前控制器为代理\n\n```\n#pragma mark -- GLKViewDelegate\n//绘制视图的内容\n/*\n GLKView对象使其OpenGL ES上下文成为当前上下文，并将其framebuffer绑定为OpenGL ES呈现命令的目标。然后，委托方法应该绘制视图的内容。\n*/\n- (void)glkView:(GLKView *)view drawInRect:(CGRect)rect\n{\n    //1.清理颜色缓冲区、深度缓冲区、模型缓冲区\n    glClear(GL_COLOR_BUFFER_BIT);\n    \n    //2.准备绘制\n    [cEffect prepareToDraw];\n    \n    //3.开始绘制\n    glDrawArrays(GL_TRIANGLES, 0, 6);\n    \n}\n```","slug":"2020-07-28-OpenGL ES&GLKit加载纹理","published":1,"updated":"2021-06-19T03:46:24.085Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbpo0015bjrj2rmj3rcz","content":"<p>1.需要导入 <code>GLKit.framework</code></p>\n<p>2.在<code>ViewController</code>中导入</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"keyword\">import</span> &lt;GLKit/GLKit.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#<span class=\"keyword\">import</span> &lt;OpenGLES<span class=\"regexp\">/ES3/g</span>l.h&gt;</span><br><span class=\"line\">#<span class=\"keyword\">import</span> &lt;OpenGLES<span class=\"regexp\">/ES3/g</span>lext.h&gt;</span><br></pre></td></tr></table></figure>\n\n<p>3.如果将<code>ViewController</code>的父类改为<code>GLKViewController</code>,则同时需要将<code>Main.storyboard</code>中的view的类别改为<code>GLKView</code><br><img src=\"https://upload-images.jianshu.io/upload_images/1395687-259961490eb4539a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"修改view类别.png\"></p>\n<p>当然也可以不修改<code>ViewController</code>的父类，直接在<code>ViewController</code>中自定义<code>GLKView</code></p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">property</span><span class=\"title\"> </span>(nonatomic, strong) GLKView *glkView;</span><br></pre></td></tr></table></figure>\n\n<p>4.创建EAGLContext，并设置为当前Context</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span><span class=\"number\">1</span>.配置初始环境</span><br><span class=\"line\">- (void)setUpConfig &#123;</span><br><span class=\"line\">    <span class=\"regexp\">//</span>创建EAGLContext 并设置为currentContext</span><br><span class=\"line\">    _context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!_context) &#123;</span><br><span class=\"line\">        NSLog(@<span class=\"string\">&quot;_context create failed&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [EAGLContext setCurrentContext:_context];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"regexp\">//</span>配置glkView</span><br><span class=\"line\">    GLKView *glkView = (GLKView *)self.view;</span><br><span class=\"line\">    glkView.context = _context;</span><br><span class=\"line\">    <span class=\"regexp\">//</span>开启颜色缓冲区</span><br><span class=\"line\">    glkView.drawableColorFormat = GLKViewDrawableColorFormatRGBA8888;</span><br><span class=\"line\">    <span class=\"regexp\">//</span>开启深度测试缓冲区</span><br><span class=\"line\">    glkView.drawableDepthFormat = GLKViewDrawableDepthFormatNone;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"regexp\">//</span>设置glkView的背景颜色</span><br><span class=\"line\">    glClearColor(<span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.设置顶点数据以及纹理数据 拷贝到顶点缓冲区</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设置顶点数据以及纹理数据 拷贝到顶点缓冲区</span></span><br><span class=\"line\">-(void)setUpVertexData</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//1.设置顶点数组(顶点坐标,纹理坐标)</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     纹理坐标系取值范围[0,1];原点是左下角(0,0);</span></span><br><span class=\"line\"><span class=\"comment\">     故而(0,0)是纹理图像的左下角, 点(1,1)是右上角.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    GLfloat vertexData<span class=\"literal\">[]</span> = &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"number\">0.5</span>, -<span class=\"number\">0.5</span>, <span class=\"number\">0.0</span>f,    <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"comment\">//右下</span></span><br><span class=\"line\">        <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>,  <span class=\"number\">0.0</span>f,    <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"comment\">//右上</span></span><br><span class=\"line\">        -<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.0</span>f,    <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"comment\">//左上</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"number\">0.5</span>, -<span class=\"number\">0.5</span>, <span class=\"number\">0.0</span>f,    <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"comment\">//右下</span></span><br><span class=\"line\">        -<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.0</span>f,    <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"comment\">//左上</span></span><br><span class=\"line\">        -<span class=\"number\">0.5</span>, -<span class=\"number\">0.5</span>, <span class=\"number\">0.0</span>f,   <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"comment\">//左下</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     顶点数组: 开发者可以选择设定函数指针，在调用绘制方法的时候，直接由内存传入顶点数据，也就是说这部分数据之前是存储在内存当中的，被称为顶点数组</span></span><br><span class=\"line\"><span class=\"comment\">     </span></span><br><span class=\"line\"><span class=\"comment\">     顶点缓存区: 性能更高的做法是，提前分配一块显存，将顶点数据预先传入到显存当中。这部分的显存，就被称为顶点缓冲区</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//2.开辟顶点缓存区</span></span><br><span class=\"line\">    <span class=\"comment\">//(1).创建顶点缓存区标识符ID</span></span><br><span class=\"line\">    GLuint bufferID;</span><br><span class=\"line\">    gl<span class=\"constructor\">GenBuffers(1, &amp;<span class=\"params\">bufferID</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">//(2).绑定顶点缓存区.(明确作用)</span></span><br><span class=\"line\">    gl<span class=\"constructor\">BindBuffer(GL_ARRAY_BUFFER, <span class=\"params\">bufferID</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">//(3).将顶点数组的数据copy到顶点缓存区中(GPU显存中)</span></span><br><span class=\"line\">    gl<span class=\"constructor\">BufferData(GL_ARRAY_BUFFER, <span class=\"params\">sizeof</span>(<span class=\"params\">vertexData</span>)</span>, vertexData, GL_STATIC_DRAW);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//3.打开读取通道.</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     (1)在iOS中, 默认情况下，出于性能考虑，所有顶点着色器的属性（Attribute）变量都是关闭的.</span></span><br><span class=\"line\"><span class=\"comment\">     意味着,顶点数据在着色器端(服务端)是不可用的. 即使你已经使用glBufferData方法,将顶点数据从内存拷贝到顶点缓存区中(GPU显存中).</span></span><br><span class=\"line\"><span class=\"comment\">     所以, 必须由glEnableVertexAttribArray 方法打开通道.指定访问属性.才能让顶点着色器能够访问到从CPU复制到GPU的数据.</span></span><br><span class=\"line\"><span class=\"comment\">     注意: 数据在GPU端是否可见，即，着色器能否读取到数据，由是否启用了对应的属性决定，这就是glEnableVertexAttribArray的功能，允许顶点着色器读取GPU（服务器端）数据。</span></span><br><span class=\"line\"><span class=\"comment\">   </span></span><br><span class=\"line\"><span class=\"comment\">    (2)方法简介</span></span><br><span class=\"line\"><span class=\"comment\">    glVertexAttribPointer (GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* ptr)</span></span><br><span class=\"line\"><span class=\"comment\">   </span></span><br><span class=\"line\"><span class=\"comment\">    功能: 上传顶点数据到显存的方法（设置合适的方式从buffer里面读取数据）</span></span><br><span class=\"line\"><span class=\"comment\">    参数列表:</span></span><br><span class=\"line\"><span class=\"comment\">        index,指定要修改的顶点属性的索引值,例如</span></span><br><span class=\"line\"><span class=\"comment\">        size, 每次读取数量。（如position是由3个（x,y,z）组成，而颜色是4个（r,g,b,a）,纹理则是2个.）</span></span><br><span class=\"line\"><span class=\"comment\">        type,指定数组中每个组件的数据类型。可用的符号常量有GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT,GL_UNSIGNED_SHORT, GL_FIXED, 和 GL_FLOAT，初始值为GL_FLOAT。</span></span><br><span class=\"line\"><span class=\"comment\">        normalized,指定当被访问时，固定点数据值是否应该被归一化（GL_TRUE）或者直接转换为固定点值（GL_FALSE）</span></span><br><span class=\"line\"><span class=\"comment\">        stride,指定连续顶点属性之间的偏移量。如果为0，那么顶点属性会被理解为：它们是紧密排列在一起的。初始值为0</span></span><br><span class=\"line\"><span class=\"comment\">        ptr指定一个指针，指向数组中第一个顶点属性的第一个组件。初始值为0</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//顶点坐标数据</span></span><br><span class=\"line\">    gl<span class=\"constructor\">EnableVertexAttribArray(GLKVertexAttribPosition)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">VertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, <span class=\"params\">sizeof</span>(GLfloat)</span><span class=\"operator\"> * </span><span class=\"number\">5</span>, (GLfloat *)NULL + <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//纹理坐标数据</span></span><br><span class=\"line\">    gl<span class=\"constructor\">EnableVertexAttribArray(GLKVertexAttribTexCoord0)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">VertexAttribPointer(GLKVertexAttribTexCoord0, 2, GL_FLOAT, GL_FALSE, <span class=\"params\">sizeof</span>(GLfloat)</span><span class=\"operator\"> * </span><span class=\"number\">5</span>, (GLfloat *)NULL + <span class=\"number\">3</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>6.加载纹理</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//加载纹理</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)setUpTexture</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//1.获取纹理图片路径</span></span><br><span class=\"line\">    NSString *filePath = [[NSBundle mainBundle] <span class=\"attr\">pathForResource:</span>@<span class=\"string\">&quot;mew_interlaced&quot;</span> <span class=\"attr\">ofType:</span>@<span class=\"string\">&quot;png&quot;</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//2.设置纹理参数</span></span><br><span class=\"line\">    <span class=\"comment\">//纹理坐标原点是左下角,但是图片显示原点应该是左上角.</span></span><br><span class=\"line\">    NSDictionary *options = [NSDictionary <span class=\"attr\">dictionaryWithObjectsAndKeys:</span>@(<span class=\"number\">1</span>),GLKTextureLoaderOriginBottomLeft, nil];</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLKTextureInfo *textureInfo = [GLKTextureLoader <span class=\"attr\">textureWithContentsOfFile:</span>filePath <span class=\"attr\">options:</span>options <span class=\"attr\">error:</span>nil];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//3.使用苹果GLKit 提供GLKBaseEffect 完成着色器工作(顶点/片元)</span></span><br><span class=\"line\">    cEffect = [[GLKBaseEffect alloc]init];</span><br><span class=\"line\">    cEffect.texture2d0.enabled = GL_TRUE;</span><br><span class=\"line\">    cEffect.texture2d0.name = textureInfo.name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>7.实现GLKView代理  绘制视图，如果是自定义<code>GLKView</code>需要设置当前控制器为代理</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#pragma</span> <span class=\"selector-tag\">mark</span> <span class=\"selector-tag\">--</span> <span class=\"selector-tag\">GLKViewDelegate</span></span><br><span class=\"line\"><span class=\"comment\">//绘制视图的内容</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> GLKView对象使其OpenGL ES上下文成为当前上下文，并将其framebuffer绑定为OpenGL ES呈现命令的目标。然后，委托方法应该绘制视图的内容。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">glkView</span><span class=\"selector-pseudo\">:(GLKView</span> *)<span class=\"selector-tag\">view</span> <span class=\"selector-tag\">drawInRect</span><span class=\"selector-pseudo\">:(CGRect)rect</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//1.清理颜色缓冲区、深度缓冲区、模型缓冲区</span></span><br><span class=\"line\">    <span class=\"selector-tag\">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//2.准备绘制</span></span><br><span class=\"line\">    <span class=\"selector-attr\">[cEffect prepareToDraw]</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//3.开始绘制</span></span><br><span class=\"line\">    <span class=\"selector-tag\">glDrawArrays</span>(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>1.需要导入 <code>GLKit.framework</code></p>\n<p>2.在<code>ViewController</code>中导入</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"keyword\">import</span> &lt;GLKit/GLKit.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">#<span class=\"keyword\">import</span> &lt;OpenGLES<span class=\"regexp\">/ES3/g</span>l.h&gt;</span><br><span class=\"line\">#<span class=\"keyword\">import</span> &lt;OpenGLES<span class=\"regexp\">/ES3/g</span>lext.h&gt;</span><br></pre></td></tr></table></figure>\n\n<p>3.如果将<code>ViewController</code>的父类改为<code>GLKViewController</code>,则同时需要将<code>Main.storyboard</code>中的view的类别改为<code>GLKView</code><br><img src=\"https://upload-images.jianshu.io/upload_images/1395687-259961490eb4539a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"修改view类别.png\"></p>\n<p>当然也可以不修改<code>ViewController</code>的父类，直接在<code>ViewController</code>中自定义<code>GLKView</code></p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">property</span><span class=\"title\"> </span>(nonatomic, strong) GLKView *glkView;</span><br></pre></td></tr></table></figure>\n\n<p>4.创建EAGLContext，并设置为当前Context</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span><span class=\"number\">1</span>.配置初始环境</span><br><span class=\"line\">- (void)setUpConfig &#123;</span><br><span class=\"line\">    <span class=\"regexp\">//</span>创建EAGLContext 并设置为currentContext</span><br><span class=\"line\">    _context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES3];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!_context) &#123;</span><br><span class=\"line\">        NSLog(@<span class=\"string\">&quot;_context create failed&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [EAGLContext setCurrentContext:_context];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"regexp\">//</span>配置glkView</span><br><span class=\"line\">    GLKView *glkView = (GLKView *)self.view;</span><br><span class=\"line\">    glkView.context = _context;</span><br><span class=\"line\">    <span class=\"regexp\">//</span>开启颜色缓冲区</span><br><span class=\"line\">    glkView.drawableColorFormat = GLKViewDrawableColorFormatRGBA8888;</span><br><span class=\"line\">    <span class=\"regexp\">//</span>开启深度测试缓冲区</span><br><span class=\"line\">    glkView.drawableDepthFormat = GLKViewDrawableDepthFormatNone;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"regexp\">//</span>设置glkView的背景颜色</span><br><span class=\"line\">    glClearColor(<span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.设置顶点数据以及纹理数据 拷贝到顶点缓冲区</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设置顶点数据以及纹理数据 拷贝到顶点缓冲区</span></span><br><span class=\"line\">-(void)setUpVertexData</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//1.设置顶点数组(顶点坐标,纹理坐标)</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     纹理坐标系取值范围[0,1];原点是左下角(0,0);</span></span><br><span class=\"line\"><span class=\"comment\">     故而(0,0)是纹理图像的左下角, 点(1,1)是右上角.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    GLfloat vertexData<span class=\"literal\">[]</span> = &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"number\">0.5</span>, -<span class=\"number\">0.5</span>, <span class=\"number\">0.0</span>f,    <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"comment\">//右下</span></span><br><span class=\"line\">        <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>,  <span class=\"number\">0.0</span>f,    <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"comment\">//右上</span></span><br><span class=\"line\">        -<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.0</span>f,    <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"comment\">//左上</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"number\">0.5</span>, -<span class=\"number\">0.5</span>, <span class=\"number\">0.0</span>f,    <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"comment\">//右下</span></span><br><span class=\"line\">        -<span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.0</span>f,    <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"comment\">//左上</span></span><br><span class=\"line\">        -<span class=\"number\">0.5</span>, -<span class=\"number\">0.5</span>, <span class=\"number\">0.0</span>f,   <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"comment\">//左下</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     顶点数组: 开发者可以选择设定函数指针，在调用绘制方法的时候，直接由内存传入顶点数据，也就是说这部分数据之前是存储在内存当中的，被称为顶点数组</span></span><br><span class=\"line\"><span class=\"comment\">     </span></span><br><span class=\"line\"><span class=\"comment\">     顶点缓存区: 性能更高的做法是，提前分配一块显存，将顶点数据预先传入到显存当中。这部分的显存，就被称为顶点缓冲区</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//2.开辟顶点缓存区</span></span><br><span class=\"line\">    <span class=\"comment\">//(1).创建顶点缓存区标识符ID</span></span><br><span class=\"line\">    GLuint bufferID;</span><br><span class=\"line\">    gl<span class=\"constructor\">GenBuffers(1, &amp;<span class=\"params\">bufferID</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">//(2).绑定顶点缓存区.(明确作用)</span></span><br><span class=\"line\">    gl<span class=\"constructor\">BindBuffer(GL_ARRAY_BUFFER, <span class=\"params\">bufferID</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">//(3).将顶点数组的数据copy到顶点缓存区中(GPU显存中)</span></span><br><span class=\"line\">    gl<span class=\"constructor\">BufferData(GL_ARRAY_BUFFER, <span class=\"params\">sizeof</span>(<span class=\"params\">vertexData</span>)</span>, vertexData, GL_STATIC_DRAW);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//3.打开读取通道.</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     (1)在iOS中, 默认情况下，出于性能考虑，所有顶点着色器的属性（Attribute）变量都是关闭的.</span></span><br><span class=\"line\"><span class=\"comment\">     意味着,顶点数据在着色器端(服务端)是不可用的. 即使你已经使用glBufferData方法,将顶点数据从内存拷贝到顶点缓存区中(GPU显存中).</span></span><br><span class=\"line\"><span class=\"comment\">     所以, 必须由glEnableVertexAttribArray 方法打开通道.指定访问属性.才能让顶点着色器能够访问到从CPU复制到GPU的数据.</span></span><br><span class=\"line\"><span class=\"comment\">     注意: 数据在GPU端是否可见，即，着色器能否读取到数据，由是否启用了对应的属性决定，这就是glEnableVertexAttribArray的功能，允许顶点着色器读取GPU（服务器端）数据。</span></span><br><span class=\"line\"><span class=\"comment\">   </span></span><br><span class=\"line\"><span class=\"comment\">    (2)方法简介</span></span><br><span class=\"line\"><span class=\"comment\">    glVertexAttribPointer (GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* ptr)</span></span><br><span class=\"line\"><span class=\"comment\">   </span></span><br><span class=\"line\"><span class=\"comment\">    功能: 上传顶点数据到显存的方法（设置合适的方式从buffer里面读取数据）</span></span><br><span class=\"line\"><span class=\"comment\">    参数列表:</span></span><br><span class=\"line\"><span class=\"comment\">        index,指定要修改的顶点属性的索引值,例如</span></span><br><span class=\"line\"><span class=\"comment\">        size, 每次读取数量。（如position是由3个（x,y,z）组成，而颜色是4个（r,g,b,a）,纹理则是2个.）</span></span><br><span class=\"line\"><span class=\"comment\">        type,指定数组中每个组件的数据类型。可用的符号常量有GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT,GL_UNSIGNED_SHORT, GL_FIXED, 和 GL_FLOAT，初始值为GL_FLOAT。</span></span><br><span class=\"line\"><span class=\"comment\">        normalized,指定当被访问时，固定点数据值是否应该被归一化（GL_TRUE）或者直接转换为固定点值（GL_FALSE）</span></span><br><span class=\"line\"><span class=\"comment\">        stride,指定连续顶点属性之间的偏移量。如果为0，那么顶点属性会被理解为：它们是紧密排列在一起的。初始值为0</span></span><br><span class=\"line\"><span class=\"comment\">        ptr指定一个指针，指向数组中第一个顶点属性的第一个组件。初始值为0</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//顶点坐标数据</span></span><br><span class=\"line\">    gl<span class=\"constructor\">EnableVertexAttribArray(GLKVertexAttribPosition)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">VertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, <span class=\"params\">sizeof</span>(GLfloat)</span><span class=\"operator\"> * </span><span class=\"number\">5</span>, (GLfloat *)NULL + <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//纹理坐标数据</span></span><br><span class=\"line\">    gl<span class=\"constructor\">EnableVertexAttribArray(GLKVertexAttribTexCoord0)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">VertexAttribPointer(GLKVertexAttribTexCoord0, 2, GL_FLOAT, GL_FALSE, <span class=\"params\">sizeof</span>(GLfloat)</span><span class=\"operator\"> * </span><span class=\"number\">5</span>, (GLfloat *)NULL + <span class=\"number\">3</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>6.加载纹理</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//加载纹理</span></span><br><span class=\"line\">-(<span class=\"keyword\">void</span>)setUpTexture</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//1.获取纹理图片路径</span></span><br><span class=\"line\">    NSString *filePath = [[NSBundle mainBundle] <span class=\"attr\">pathForResource:</span>@<span class=\"string\">&quot;mew_interlaced&quot;</span> <span class=\"attr\">ofType:</span>@<span class=\"string\">&quot;png&quot;</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//2.设置纹理参数</span></span><br><span class=\"line\">    <span class=\"comment\">//纹理坐标原点是左下角,但是图片显示原点应该是左上角.</span></span><br><span class=\"line\">    NSDictionary *options = [NSDictionary <span class=\"attr\">dictionaryWithObjectsAndKeys:</span>@(<span class=\"number\">1</span>),GLKTextureLoaderOriginBottomLeft, nil];</span><br><span class=\"line\">    </span><br><span class=\"line\">    GLKTextureInfo *textureInfo = [GLKTextureLoader <span class=\"attr\">textureWithContentsOfFile:</span>filePath <span class=\"attr\">options:</span>options <span class=\"attr\">error:</span>nil];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//3.使用苹果GLKit 提供GLKBaseEffect 完成着色器工作(顶点/片元)</span></span><br><span class=\"line\">    cEffect = [[GLKBaseEffect alloc]init];</span><br><span class=\"line\">    cEffect.texture2d0.enabled = GL_TRUE;</span><br><span class=\"line\">    cEffect.texture2d0.name = textureInfo.name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>7.实现GLKView代理  绘制视图，如果是自定义<code>GLKView</code>需要设置当前控制器为代理</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#pragma</span> <span class=\"selector-tag\">mark</span> <span class=\"selector-tag\">--</span> <span class=\"selector-tag\">GLKViewDelegate</span></span><br><span class=\"line\"><span class=\"comment\">//绘制视图的内容</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> GLKView对象使其OpenGL ES上下文成为当前上下文，并将其framebuffer绑定为OpenGL ES呈现命令的目标。然后，委托方法应该绘制视图的内容。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"selector-tag\">-</span> (void)<span class=\"selector-tag\">glkView</span><span class=\"selector-pseudo\">:(GLKView</span> *)<span class=\"selector-tag\">view</span> <span class=\"selector-tag\">drawInRect</span><span class=\"selector-pseudo\">:(CGRect)rect</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//1.清理颜色缓冲区、深度缓冲区、模型缓冲区</span></span><br><span class=\"line\">    <span class=\"selector-tag\">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//2.准备绘制</span></span><br><span class=\"line\">    <span class=\"selector-attr\">[cEffect prepareToDraw]</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//3.开始绘制</span></span><br><span class=\"line\">    <span class=\"selector-tag\">glDrawArrays</span>(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"OpenGL ES GLSL加载纹理","date":"2020-08-01T16:00:00.000Z","_content":"\n使用GLSL语言加载纹理，需要自定义顶点着色器和片源着色器。\n\nGLSL编写的顶点着色器和片元着色器其实是一段代码，也是一段字符串，所以文件名和后缀可以自定义。\n\n通过创建`Empty`文件，修改文件名为`shaderv.vsh` 和  `shaderf.fsh`，分别代表顶点着色器和片元着色器。在GLSL语言编写的文件中，建议不要写中文注释，否则可能发生一些奇怪的错误。\n\n`顶点着色器 shaderv.vsh`代码\n\n```\nattribute vec4 position;\nattribute vec2 textCoordinate;\nvarying lowp vec2 varyTextCoord;\n\nvoid main() {\n    varyTextCoord = textCoordinate;\n    \n    gl_Position = position;\n}\n```\n\n>  解释：\n>  attribute vec4 position; 指的是attribute属性的 4维向量 的顶点坐标。\n>  attribute vec2 textCoordinate; 指的是attribute属性的 2维向量 的纹理坐标。\n>  varying lowp vec2 varyTextCoord; 指的是通过顶点着色器透传到片元着色器中的 低精度 的 2维向量 的纹理坐标。\n>  `varying`修饰符代表可以通过顶点着色器传参到片元着色器，在片元着色器中的接收变量 声明 需要和顶点着色器中 **一模一样**。\n>  每一个着色器文件都有一个`main`函数。\n>   varyTextCoord = textCoordinate; 将纹理坐标通过`varyTextCoord`变量传递到片元着色器。\n>  gl_Position = position; 不对顶点坐标做任何处理，直接传入给OpenGL ES中的内建变量`gl_Position`。\n\n`片元着色器 shaderf.fsh`代码\n\n```\nprecision highp float;\nvarying lowp vec2 varyTextCoord;\nuniform sampler2D colorMap;\n\nvoid main() {\n    lowp vec4 temp = texture2D(colorMap, varyTextCoord);\n    \n    gl_FragColor = temp;\n}\n```\n\n> 解释：\n> precision highp float; 在本文件中使用高精度的 `float`。\n> varying lowp vec2 varyTextCoord; 声明和顶点着色器中一致，用来接收纹理坐标。\n> uniform sampler2D colorMap;  纹理采样器\n> texture2D(colorMap, varyTextCoord); 通过纹理采样器，获取纹理每个像素点对应的颜色值，赋值给OpenGL ES中的内建变量`gl_FragColor`。\n\n\n使用GLSL编写自定义着色器加载纹理需要以下步骤：\n\n  - 创建图层\n  - 创建上下文\n  - 清空缓冲区\n  - 设置renderBuffer\n  - 设置frameBuffer\n  - 开始绘制\n\n> 以下代码在自定义CustomView继承自UIView中编写。\n\n**0.定义属性**\n```\n@interface CustomView()\n\n@property (nonatomic, strong) CAEAGLLayer *eaglLayer;//自定义图层\n\n@property (nonatomic, strong) EAGLContext *context;//上下文\n\n@property (nonatomic, assign) GLuint renderBuffer;//渲染缓冲区ID\n@property (nonatomic, assign) GLuint frameBuffer;//帧缓冲区ID\n\n@property (nonatomic, assign) GLuint program;//程序ID\n\n@end\n```\n\n**1.创建图层**\n```\n//1.设置图层\n- (void)setupLayer {\n    self.eaglLayer = (CAEAGLLayer *)self.layer;\n    \n    [self setContentScaleFactor:[UIScreen mainScreen].scale];\n    \n    /**\n     kEAGLDrawablePropertyColorFormat:颜色缓冲区格式\n     kEAGLDrawablePropertyRetainedBacking:绘制后是否保留其内容\n     */\n    self.eaglLayer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:@false, kEAGLDrawablePropertyRetainedBacking, kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, nil];\n}\n```\n\n需要重写`+ (Class)layerClass;`方法才能强转生效。\n```\n+ (Class)layerClass {\n    return [CAEAGLLayer class];\n}\n```\n\n**2.创建上下文**\n```\n//2.设置上下文\n- (void)setupContext {\n    self.context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];\n    if (!self.context) {\n        NSLog(@\"create context failed\");\n        return;\n    }\n    BOOL ret = [EAGLContext setCurrentContext:self.context];\n    if (!ret) {\n        NSLog(@\"setCurrentContext failed\");\n        return;\n    }\n}\n```\n\n**3.清空缓冲区**\n```\n//3.清空缓冲区\n- (void)clearRenderAndFrameBuffer {\n    //Frame Buffer Object FBO\n    //Render Buffer 三类：颜色缓冲区、深度缓冲区、模版缓冲区\n    \n    glDeleteRenderbuffers(1, &_renderBuffer);\n    self.renderBuffer = 0;\n    \n    glDeleteFramebuffers(1, &_frameBuffer);\n    self.frameBuffer = 0;\n}\n```\n\n**4.设置renderBuffer**\n```\n//4.设置renderBuffer \n-(void)setupRenderBuffer\n{\n    //定义一个缓存区ID\n    GLuint renderBuffer;\n    \n    //申请一个缓存区标志\n    glGenRenderbuffers(1, &renderBuffer); \n    self.renderBuffer = renderBuffer;\n    \n    //将标识符绑定到GL_RENDERBUFFER\n    glBindRenderbuffer(GL_RENDERBUFFER, self.renderBuffer);\n    \n    //将可绘制对象drawable object's  CAEAGLLayer的存储绑定到OpenGL ES renderBuffer对象\n    [self.context renderbufferStorage:GL_RENDERBUFFER fromDrawable:self.eaglLayer];\n}\n```\n\n**5.设置frameBuffer**\n```\n//5.设置frameBuffer\n- (void)setupFrameBuffer {\n    GLuint frameBuffer;\n    \n    glGenFramebuffers(1, &frameBuffer);\n    \n    self.frameBuffer = frameBuffer;\n    \n    glBindFramebuffer(GL_FRAMEBUFFER, self.frameBuffer);\n    \n    /*生成帧缓存区之后，则需要将renderbuffer跟framebuffer进行绑定，\n     调用glFramebufferRenderbuffer函数进行绑定到对应的附着点上，后面的绘制才能起作用\n     */\n    //将渲染缓存区frameBuffer 通过glFramebufferRenderbuffer函数绑定到 GL_COLOR_ATTACHMENT0上。\n    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, self.renderBuffer);\n}\n```\n\n**6.开始绘制**\n```\n//6.开始绘制\n- (void)renderLayer {\n    //设置背景色\n    glClearColor(0.45, 0.5, 0, 1);\n    //清空颜色缓冲区\n    glClear(GL_COLOR_BUFFER_BIT);\n    \n    CGFloat scale = [UIScreen mainScreen].scale;\n    //设置视口\n    glViewport(self.frame.origin.x * scale, self.frame.origin.y * scale, self.frame.size.width * scale, self.frame.size.height * scale);\n    \n    //顶点着色器和片元着色器文件路径\n    NSString *vertFilePath = [[NSBundle mainBundle] pathForResource:@\"shaderv\" ofType:@\"vsh\"];\n    NSString *fragFilePath = [[NSBundle mainBundle] pathForResource:@\"shaderf\" ofType:@\"fsh\"];\n    \n    //加载顶点着色器和纹理着色器 创建program\n    self.program = [self loaderShader:vertFilePath withFrag:fragFilePath];\n    \n    //链接program\n    glLinkProgram(self.program);\n    \n    //获取program链接状态\n    GLint linkStatus;\n    glGetProgramiv(self.program, GL_LINK_STATUS, &linkStatus);\n    if (linkStatus == GL_FALSE) {\n        GLchar loginfo[512];\n        glGetProgramInfoLog(self.program, sizeof(loginfo), 0, &loginfo[0]);\n        NSString *message = [NSString stringWithUTF8String:loginfo];\n        NSLog(@\"program link error:%@\", message);\n        return;\n    }\n    \n    //使用program\n    glUseProgram(self.program);\n    \n    //准备顶点数据/纹理坐标\n    GLfloat attrArr[] =\n     {\n         0.5f, -0.5f, -1.0f,     1.0f, 0.0f,\n         -0.5f, 0.5f, -1.0f,     0.0f, 1.0f,\n         -0.5f, -0.5f, -1.0f,    0.0f, 0.0f,\n         \n         0.5f, 0.5f, -1.0f,      1.0f, 1.0f,\n         -0.5f, 0.5f, -1.0f,     0.0f, 1.0f,\n         0.5f, -0.5f, -1.0f,     1.0f, 0.0f,\n     };\n    \n    //将顶点坐标和纹理坐标拷贝到GPU中\n    GLuint attrBuffer;\n    glGenBuffers(1, &attrBuffer);\n    glBindBuffer(GL_ARRAY_BUFFER, attrBuffer);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(attrArr), attrArr, GL_DYNAMIC_DRAW);\n    \n    //获取顶点数据通道ID v.sh positon 打开顶点通道 并设置数据读取方式\n    GLuint position = glGetAttribLocation(self.program, \"position\");\n    glEnableVertexAttribArray(position);\n    glVertexAttribPointer(position, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 5, (GLfloat *)NULL + 0);\n    \n    //打开纹理通道 并设置数据读取方式\n    GLuint textCoordinate = glGetAttribLocation(self.program, \"textCoordinate\");\n    glEnableVertexAttribArray(textCoordinate);\n    glVertexAttribPointer(textCoordinate, 2, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 5, (GLfloat *)NULL + 3);\n\n    //加载纹理\n    [self setupTexture:@\"mew_progressive.jpg\"];\n    \n    //设置纹理采样器\n    glUniform1i(glGetUniformLocation(self.program, \"colorMap\"), 0);\n    \n    //开始绘制\n    glDrawArrays(GL_TRIANGLES, 0, 6);\n    \n    //从渲染缓冲区显示到屏幕上\n    [self.context presentRenderbuffer:GL_RENDERBUFFER];\n}\n```\n\n**加载纹理**\n```\n//加载纹理\n- (GLuint)setupTexture:(NSString *)filePath {\n    //获取图像CGImage\n    CGImageRef cgImage = [UIImage imageNamed:filePath].CGImage;\n    if (!cgImage) {\n        NSLog(@\"faile to load image\");\n        return -1;\n    }\n    \n    //获取图片宽高\n    size_t width = CGImageGetWidth(cgImage);\n    size_t height = CGImageGetHeight(cgImage);\n    \n    //获取图片字节数 宽*高*4（RGBA）\n    GLubyte *data = (GLubyte *)calloc(width * height * 4, sizeof(GLubyte));\n    \n    //创建上下文\n    /*\n     参数1：data,指向要渲染的绘制图像的内存地址\n     参数2：width,bitmap的宽度，单位为像素\n     参数3：height,bitmap的高度，单位为像素\n     参数4：bitPerComponent,内存中像素的每个组件的位数，比如32位RGBA，就设置为8\n     参数5：bytesPerRow,bitmap的没一行的内存所占的比特数\n     参数6：colorSpace,bitmap上使用的颜色空间  kCGImageAlphaPremultipliedLast：RGBA\n     */\n    CGContextRef cgContext = CGBitmapContextCreate(\n                                                   data,\n                                                   width,\n                                                   height,\n                                                   8,\n                                                   width * 4,\n                                                   CGImageGetColorSpace(cgImage),\n                                                   kCGImageAlphaPremultipliedLast);\n    //使用CGContextRef 将图片绘制出来 也是一个解码的过程\n    /*\n     CGContextDrawImage 使用的是Core Graphics框架，坐标系与UIKit 不一样。UIKit框架的原点在屏幕的左上角，Core Graphics框架的原点在屏幕的左下角。\n     CGContextDrawImage\n     参数1：绘图上下文\n     参数2：rect坐标\n     参数3：绘制的图片\n     */\n    CGRect rect = CGRectMake(0, 0, width, height);\n    \n    CGContextDrawImage(cgContext, rect, cgImage);\n    \n    CGContextRelease(cgContext);\n    \n    //纹理 当只有一个纹理时 纹理ID为0, 多个纹理需要激活\n    GLuint textureID;\n    glGenTextures(1, &textureID);\n    \n    glBindTexture(GL_TEXTURE_2D, textureID);\n    \n    //设置纹理属性\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n    \n    float fw = width, fh = height;\n    //载入纹理2D数据\n    /*\n     参数1：纹理模式，GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D\n     参数2：加载的层次，一般设置为0\n     参数3：纹理的颜色值GL_RGBA\n     参数4：宽\n     参数5：高\n     参数6：border，边界宽度\n     参数7：format\n     参数8：type\n     参数9：纹理数据\n     */\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, fw, fh, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);\n    \n    free(data);\n    return 0;\n}\n```\n\n**加载着色器**\n```\n//加载着色器\n- (GLuint)loaderShader:(NSString *)vert withFrag:(NSString *)frag {\n    //顶点着色器对象 片元着色器对象/句柄\n    GLuint verShader, fragShader;\n    \n    //创建空的program\n    GLuint program = glCreateProgram();\n    \n    //编译\n    [self compileShader:&verShader type:GL_VERTEX_SHADER filePath:vert];\n    [self compileShader:&fragShader type:GL_FRAGMENT_SHADER filePath:frag];\n    \n    //把shader附着 到编译好的程序\n    glAttachShader(program, verShader);\n    glAttachShader(program, fragShader);\n    \n    //附着之后 就可以删除\n    glDeleteShader(verShader);\n    glDeleteShader(fragShader);\n    \n    return program;\n}\n```\n\n**编译program**\n```\n//编译\n- (void)compileShader:(GLuint *)shader type:(GLenum)type filePath:(NSString *)filePath {\n    //读取路径\n    NSString *content = [NSString stringWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];\n    const GLchar *source = [content UTF8String];\n    \n    //创建对应类型的shader\n    *shader = glCreateShader(type);\n    \n    //将着色器附着到 着色器对象上\n    glShaderSource(*shader, 1, &source, NULL);\n    \n    //编译\n    glCompileShader(*shader);\n}\n```\n\ndemo地址：[GLSL加载图片]([https://github.com/ugpass/GLSL_Hello_World](https://github.com/ugpass/GLSL_Hello_World)\n)\n\n> `glVertexAttribPointer`函数最后一个参数，从哪里开始访问数据的 `NULL`， 如果不加`(GLfloat *)`，将会导致纹理加载不上去！！！\n\n> 由于CoreGraphics坐标系与UIKit不一致，导致图片显示为倒的，之后介绍五种旋转图片的方法。","source":"_posts/2020-08-02-OpenGL ES GLSL加载纹理.md","raw":"---\ntitle:      \"OpenGL ES GLSL加载纹理\" \ndate:       2020-08-02\ntags:\n    - OpenGL ES \n    - GLSL\ncategories:\n    - OpenGL ES \n    - GLSL\n---\n\n使用GLSL语言加载纹理，需要自定义顶点着色器和片源着色器。\n\nGLSL编写的顶点着色器和片元着色器其实是一段代码，也是一段字符串，所以文件名和后缀可以自定义。\n\n通过创建`Empty`文件，修改文件名为`shaderv.vsh` 和  `shaderf.fsh`，分别代表顶点着色器和片元着色器。在GLSL语言编写的文件中，建议不要写中文注释，否则可能发生一些奇怪的错误。\n\n`顶点着色器 shaderv.vsh`代码\n\n```\nattribute vec4 position;\nattribute vec2 textCoordinate;\nvarying lowp vec2 varyTextCoord;\n\nvoid main() {\n    varyTextCoord = textCoordinate;\n    \n    gl_Position = position;\n}\n```\n\n>  解释：\n>  attribute vec4 position; 指的是attribute属性的 4维向量 的顶点坐标。\n>  attribute vec2 textCoordinate; 指的是attribute属性的 2维向量 的纹理坐标。\n>  varying lowp vec2 varyTextCoord; 指的是通过顶点着色器透传到片元着色器中的 低精度 的 2维向量 的纹理坐标。\n>  `varying`修饰符代表可以通过顶点着色器传参到片元着色器，在片元着色器中的接收变量 声明 需要和顶点着色器中 **一模一样**。\n>  每一个着色器文件都有一个`main`函数。\n>   varyTextCoord = textCoordinate; 将纹理坐标通过`varyTextCoord`变量传递到片元着色器。\n>  gl_Position = position; 不对顶点坐标做任何处理，直接传入给OpenGL ES中的内建变量`gl_Position`。\n\n`片元着色器 shaderf.fsh`代码\n\n```\nprecision highp float;\nvarying lowp vec2 varyTextCoord;\nuniform sampler2D colorMap;\n\nvoid main() {\n    lowp vec4 temp = texture2D(colorMap, varyTextCoord);\n    \n    gl_FragColor = temp;\n}\n```\n\n> 解释：\n> precision highp float; 在本文件中使用高精度的 `float`。\n> varying lowp vec2 varyTextCoord; 声明和顶点着色器中一致，用来接收纹理坐标。\n> uniform sampler2D colorMap;  纹理采样器\n> texture2D(colorMap, varyTextCoord); 通过纹理采样器，获取纹理每个像素点对应的颜色值，赋值给OpenGL ES中的内建变量`gl_FragColor`。\n\n\n使用GLSL编写自定义着色器加载纹理需要以下步骤：\n\n  - 创建图层\n  - 创建上下文\n  - 清空缓冲区\n  - 设置renderBuffer\n  - 设置frameBuffer\n  - 开始绘制\n\n> 以下代码在自定义CustomView继承自UIView中编写。\n\n**0.定义属性**\n```\n@interface CustomView()\n\n@property (nonatomic, strong) CAEAGLLayer *eaglLayer;//自定义图层\n\n@property (nonatomic, strong) EAGLContext *context;//上下文\n\n@property (nonatomic, assign) GLuint renderBuffer;//渲染缓冲区ID\n@property (nonatomic, assign) GLuint frameBuffer;//帧缓冲区ID\n\n@property (nonatomic, assign) GLuint program;//程序ID\n\n@end\n```\n\n**1.创建图层**\n```\n//1.设置图层\n- (void)setupLayer {\n    self.eaglLayer = (CAEAGLLayer *)self.layer;\n    \n    [self setContentScaleFactor:[UIScreen mainScreen].scale];\n    \n    /**\n     kEAGLDrawablePropertyColorFormat:颜色缓冲区格式\n     kEAGLDrawablePropertyRetainedBacking:绘制后是否保留其内容\n     */\n    self.eaglLayer.drawableProperties = [NSDictionary dictionaryWithObjectsAndKeys:@false, kEAGLDrawablePropertyRetainedBacking, kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, nil];\n}\n```\n\n需要重写`+ (Class)layerClass;`方法才能强转生效。\n```\n+ (Class)layerClass {\n    return [CAEAGLLayer class];\n}\n```\n\n**2.创建上下文**\n```\n//2.设置上下文\n- (void)setupContext {\n    self.context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];\n    if (!self.context) {\n        NSLog(@\"create context failed\");\n        return;\n    }\n    BOOL ret = [EAGLContext setCurrentContext:self.context];\n    if (!ret) {\n        NSLog(@\"setCurrentContext failed\");\n        return;\n    }\n}\n```\n\n**3.清空缓冲区**\n```\n//3.清空缓冲区\n- (void)clearRenderAndFrameBuffer {\n    //Frame Buffer Object FBO\n    //Render Buffer 三类：颜色缓冲区、深度缓冲区、模版缓冲区\n    \n    glDeleteRenderbuffers(1, &_renderBuffer);\n    self.renderBuffer = 0;\n    \n    glDeleteFramebuffers(1, &_frameBuffer);\n    self.frameBuffer = 0;\n}\n```\n\n**4.设置renderBuffer**\n```\n//4.设置renderBuffer \n-(void)setupRenderBuffer\n{\n    //定义一个缓存区ID\n    GLuint renderBuffer;\n    \n    //申请一个缓存区标志\n    glGenRenderbuffers(1, &renderBuffer); \n    self.renderBuffer = renderBuffer;\n    \n    //将标识符绑定到GL_RENDERBUFFER\n    glBindRenderbuffer(GL_RENDERBUFFER, self.renderBuffer);\n    \n    //将可绘制对象drawable object's  CAEAGLLayer的存储绑定到OpenGL ES renderBuffer对象\n    [self.context renderbufferStorage:GL_RENDERBUFFER fromDrawable:self.eaglLayer];\n}\n```\n\n**5.设置frameBuffer**\n```\n//5.设置frameBuffer\n- (void)setupFrameBuffer {\n    GLuint frameBuffer;\n    \n    glGenFramebuffers(1, &frameBuffer);\n    \n    self.frameBuffer = frameBuffer;\n    \n    glBindFramebuffer(GL_FRAMEBUFFER, self.frameBuffer);\n    \n    /*生成帧缓存区之后，则需要将renderbuffer跟framebuffer进行绑定，\n     调用glFramebufferRenderbuffer函数进行绑定到对应的附着点上，后面的绘制才能起作用\n     */\n    //将渲染缓存区frameBuffer 通过glFramebufferRenderbuffer函数绑定到 GL_COLOR_ATTACHMENT0上。\n    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, self.renderBuffer);\n}\n```\n\n**6.开始绘制**\n```\n//6.开始绘制\n- (void)renderLayer {\n    //设置背景色\n    glClearColor(0.45, 0.5, 0, 1);\n    //清空颜色缓冲区\n    glClear(GL_COLOR_BUFFER_BIT);\n    \n    CGFloat scale = [UIScreen mainScreen].scale;\n    //设置视口\n    glViewport(self.frame.origin.x * scale, self.frame.origin.y * scale, self.frame.size.width * scale, self.frame.size.height * scale);\n    \n    //顶点着色器和片元着色器文件路径\n    NSString *vertFilePath = [[NSBundle mainBundle] pathForResource:@\"shaderv\" ofType:@\"vsh\"];\n    NSString *fragFilePath = [[NSBundle mainBundle] pathForResource:@\"shaderf\" ofType:@\"fsh\"];\n    \n    //加载顶点着色器和纹理着色器 创建program\n    self.program = [self loaderShader:vertFilePath withFrag:fragFilePath];\n    \n    //链接program\n    glLinkProgram(self.program);\n    \n    //获取program链接状态\n    GLint linkStatus;\n    glGetProgramiv(self.program, GL_LINK_STATUS, &linkStatus);\n    if (linkStatus == GL_FALSE) {\n        GLchar loginfo[512];\n        glGetProgramInfoLog(self.program, sizeof(loginfo), 0, &loginfo[0]);\n        NSString *message = [NSString stringWithUTF8String:loginfo];\n        NSLog(@\"program link error:%@\", message);\n        return;\n    }\n    \n    //使用program\n    glUseProgram(self.program);\n    \n    //准备顶点数据/纹理坐标\n    GLfloat attrArr[] =\n     {\n         0.5f, -0.5f, -1.0f,     1.0f, 0.0f,\n         -0.5f, 0.5f, -1.0f,     0.0f, 1.0f,\n         -0.5f, -0.5f, -1.0f,    0.0f, 0.0f,\n         \n         0.5f, 0.5f, -1.0f,      1.0f, 1.0f,\n         -0.5f, 0.5f, -1.0f,     0.0f, 1.0f,\n         0.5f, -0.5f, -1.0f,     1.0f, 0.0f,\n     };\n    \n    //将顶点坐标和纹理坐标拷贝到GPU中\n    GLuint attrBuffer;\n    glGenBuffers(1, &attrBuffer);\n    glBindBuffer(GL_ARRAY_BUFFER, attrBuffer);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(attrArr), attrArr, GL_DYNAMIC_DRAW);\n    \n    //获取顶点数据通道ID v.sh positon 打开顶点通道 并设置数据读取方式\n    GLuint position = glGetAttribLocation(self.program, \"position\");\n    glEnableVertexAttribArray(position);\n    glVertexAttribPointer(position, 3, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 5, (GLfloat *)NULL + 0);\n    \n    //打开纹理通道 并设置数据读取方式\n    GLuint textCoordinate = glGetAttribLocation(self.program, \"textCoordinate\");\n    glEnableVertexAttribArray(textCoordinate);\n    glVertexAttribPointer(textCoordinate, 2, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 5, (GLfloat *)NULL + 3);\n\n    //加载纹理\n    [self setupTexture:@\"mew_progressive.jpg\"];\n    \n    //设置纹理采样器\n    glUniform1i(glGetUniformLocation(self.program, \"colorMap\"), 0);\n    \n    //开始绘制\n    glDrawArrays(GL_TRIANGLES, 0, 6);\n    \n    //从渲染缓冲区显示到屏幕上\n    [self.context presentRenderbuffer:GL_RENDERBUFFER];\n}\n```\n\n**加载纹理**\n```\n//加载纹理\n- (GLuint)setupTexture:(NSString *)filePath {\n    //获取图像CGImage\n    CGImageRef cgImage = [UIImage imageNamed:filePath].CGImage;\n    if (!cgImage) {\n        NSLog(@\"faile to load image\");\n        return -1;\n    }\n    \n    //获取图片宽高\n    size_t width = CGImageGetWidth(cgImage);\n    size_t height = CGImageGetHeight(cgImage);\n    \n    //获取图片字节数 宽*高*4（RGBA）\n    GLubyte *data = (GLubyte *)calloc(width * height * 4, sizeof(GLubyte));\n    \n    //创建上下文\n    /*\n     参数1：data,指向要渲染的绘制图像的内存地址\n     参数2：width,bitmap的宽度，单位为像素\n     参数3：height,bitmap的高度，单位为像素\n     参数4：bitPerComponent,内存中像素的每个组件的位数，比如32位RGBA，就设置为8\n     参数5：bytesPerRow,bitmap的没一行的内存所占的比特数\n     参数6：colorSpace,bitmap上使用的颜色空间  kCGImageAlphaPremultipliedLast：RGBA\n     */\n    CGContextRef cgContext = CGBitmapContextCreate(\n                                                   data,\n                                                   width,\n                                                   height,\n                                                   8,\n                                                   width * 4,\n                                                   CGImageGetColorSpace(cgImage),\n                                                   kCGImageAlphaPremultipliedLast);\n    //使用CGContextRef 将图片绘制出来 也是一个解码的过程\n    /*\n     CGContextDrawImage 使用的是Core Graphics框架，坐标系与UIKit 不一样。UIKit框架的原点在屏幕的左上角，Core Graphics框架的原点在屏幕的左下角。\n     CGContextDrawImage\n     参数1：绘图上下文\n     参数2：rect坐标\n     参数3：绘制的图片\n     */\n    CGRect rect = CGRectMake(0, 0, width, height);\n    \n    CGContextDrawImage(cgContext, rect, cgImage);\n    \n    CGContextRelease(cgContext);\n    \n    //纹理 当只有一个纹理时 纹理ID为0, 多个纹理需要激活\n    GLuint textureID;\n    glGenTextures(1, &textureID);\n    \n    glBindTexture(GL_TEXTURE_2D, textureID);\n    \n    //设置纹理属性\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n    \n    float fw = width, fh = height;\n    //载入纹理2D数据\n    /*\n     参数1：纹理模式，GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D\n     参数2：加载的层次，一般设置为0\n     参数3：纹理的颜色值GL_RGBA\n     参数4：宽\n     参数5：高\n     参数6：border，边界宽度\n     参数7：format\n     参数8：type\n     参数9：纹理数据\n     */\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, fw, fh, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);\n    \n    free(data);\n    return 0;\n}\n```\n\n**加载着色器**\n```\n//加载着色器\n- (GLuint)loaderShader:(NSString *)vert withFrag:(NSString *)frag {\n    //顶点着色器对象 片元着色器对象/句柄\n    GLuint verShader, fragShader;\n    \n    //创建空的program\n    GLuint program = glCreateProgram();\n    \n    //编译\n    [self compileShader:&verShader type:GL_VERTEX_SHADER filePath:vert];\n    [self compileShader:&fragShader type:GL_FRAGMENT_SHADER filePath:frag];\n    \n    //把shader附着 到编译好的程序\n    glAttachShader(program, verShader);\n    glAttachShader(program, fragShader);\n    \n    //附着之后 就可以删除\n    glDeleteShader(verShader);\n    glDeleteShader(fragShader);\n    \n    return program;\n}\n```\n\n**编译program**\n```\n//编译\n- (void)compileShader:(GLuint *)shader type:(GLenum)type filePath:(NSString *)filePath {\n    //读取路径\n    NSString *content = [NSString stringWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];\n    const GLchar *source = [content UTF8String];\n    \n    //创建对应类型的shader\n    *shader = glCreateShader(type);\n    \n    //将着色器附着到 着色器对象上\n    glShaderSource(*shader, 1, &source, NULL);\n    \n    //编译\n    glCompileShader(*shader);\n}\n```\n\ndemo地址：[GLSL加载图片]([https://github.com/ugpass/GLSL_Hello_World](https://github.com/ugpass/GLSL_Hello_World)\n)\n\n> `glVertexAttribPointer`函数最后一个参数，从哪里开始访问数据的 `NULL`， 如果不加`(GLfloat *)`，将会导致纹理加载不上去！！！\n\n> 由于CoreGraphics坐标系与UIKit不一致，导致图片显示为倒的，之后介绍五种旋转图片的方法。","slug":"2020-08-02-OpenGL ES GLSL加载纹理","published":1,"updated":"2021-06-19T03:46:24.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbpp0017bjrjei1lbgub","content":"<p>使用GLSL语言加载纹理，需要自定义顶点着色器和片源着色器。</p>\n<p>GLSL编写的顶点着色器和片元着色器其实是一段代码，也是一段字符串，所以文件名和后缀可以自定义。</p>\n<p>通过创建<code>Empty</code>文件，修改文件名为<code>shaderv.vsh</code> 和  <code>shaderf.fsh</code>，分别代表顶点着色器和片元着色器。在GLSL语言编写的文件中，建议不要写中文注释，否则可能发生一些奇怪的错误。</p>\n<p><code>顶点着色器 shaderv.vsh</code>代码</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec4</span> position;</span><br><span class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec2</span> textCoordinate;</span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"keyword\">lowp</span> <span class=\"type\">vec2</span> varyTextCoord;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    varyTextCoord = textCoordinate;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">gl_Position</span> = position;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p> 解释：<br> attribute vec4 position; 指的是attribute属性的 4维向量 的顶点坐标。<br> attribute vec2 textCoordinate; 指的是attribute属性的 2维向量 的纹理坐标。<br> varying lowp vec2 varyTextCoord; 指的是通过顶点着色器透传到片元着色器中的 低精度 的 2维向量 的纹理坐标。<br> <code>varying</code>修饰符代表可以通过顶点着色器传参到片元着色器，在片元着色器中的接收变量 声明 需要和顶点着色器中 <strong>一模一样</strong>。<br> 每一个着色器文件都有一个<code>main</code>函数。<br>  varyTextCoord = textCoordinate; 将纹理坐标通过<code>varyTextCoord</code>变量传递到片元着色器。<br> gl_Position = position; 不对顶点坐标做任何处理，直接传入给OpenGL ES中的内建变量<code>gl_Position</code>。</p>\n</blockquote>\n<p><code>片元着色器 shaderf.fsh</code>代码</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">precision</span> <span class=\"keyword\">highp</span> <span class=\"type\">float</span>;</span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"keyword\">lowp</span> <span class=\"type\">vec2</span> varyTextCoord;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> colorMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">lowp</span> <span class=\"type\">vec4</span> temp = <span class=\"built_in\">texture2D</span>(colorMap, varyTextCoord);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>解释：<br>precision highp float; 在本文件中使用高精度的 <code>float</code>。<br>varying lowp vec2 varyTextCoord; 声明和顶点着色器中一致，用来接收纹理坐标。<br>uniform sampler2D colorMap;  纹理采样器<br>texture2D(colorMap, varyTextCoord); 通过纹理采样器，获取纹理每个像素点对应的颜色值，赋值给OpenGL ES中的内建变量<code>gl_FragColor</code>。</p>\n</blockquote>\n<p>使用GLSL编写自定义着色器加载纹理需要以下步骤：</p>\n<ul>\n<li>创建图层</li>\n<li>创建上下文</li>\n<li>清空缓冲区</li>\n<li>设置renderBuffer</li>\n<li>设置frameBuffer</li>\n<li>开始绘制</li>\n</ul>\n<blockquote>\n<p>以下代码在自定义CustomView继承自UIView中编写。</p>\n</blockquote>\n<p><strong>0.定义属性</strong></p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@interface</span> CustomView()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">@property</span> (nonatomic, strong) CAEAGLLayer *eaglLayer;<span class=\"comment\">//自定义图层</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">@property</span> (nonatomic, strong) EAGLContext *context;<span class=\"comment\">//上下文</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">@property</span> (nonatomic, assign) GLuint renderBuffer;<span class=\"comment\">//渲染缓冲区ID</span></span><br><span class=\"line\"><span class=\"variable\">@property</span> (nonatomic, assign) GLuint frameBuffer;<span class=\"comment\">//帧缓冲区ID</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">@property</span> (nonatomic, assign) GLuint program;<span class=\"comment\">//程序ID</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>1.创建图层</strong></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.设置图层</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setupLayer &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.eaglLayer = (<span class=\"built_in\">CAEAGLLayer</span> *)<span class=\"keyword\">self</span>.layer;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setContentScaleFactor:[<span class=\"built_in\">UIScreen</span> mainScreen].scale];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     kEAGLDrawablePropertyColorFormat:颜色缓冲区格式</span></span><br><span class=\"line\"><span class=\"comment\">     kEAGLDrawablePropertyRetainedBacking:绘制后是否保留其内容</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.eaglLayer.drawableProperties = [<span class=\"built_in\">NSDictionary</span> dictionaryWithObjectsAndKeys:@false, kEAGLDrawablePropertyRetainedBacking, kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要重写<code>+ (Class)layerClass;</code>方法才能强转生效。</p>\n<figure class=\"highlight monkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"class\"><span class=\"keyword\">Class</span>)<span class=\"title\">layerClass</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [CAEAGLLayer <span class=\"class\"><span class=\"keyword\">class</span>];</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2.创建上下文</strong></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//2.设置上下文</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setupContext &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>.context) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;create context failed&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> ret = [EAGLContext setCurrentContext:<span class=\"keyword\">self</span>.context];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ret) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;setCurrentContext failed&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>3.清空缓冲区</strong></p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//3.清空缓冲区</span></span><br><span class=\"line\">- (void)clearRenderAndFrameBuffer &#123;</span><br><span class=\"line\">    <span class=\"comment\">//Frame Buffer Object FBO</span></span><br><span class=\"line\">    <span class=\"comment\">//Render Buffer 三类：颜色缓冲区、深度缓冲区、模版缓冲区</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    gl<span class=\"constructor\">DeleteRenderbuffers(1, &amp;<span class=\"params\">_renderBuffer</span>)</span>;</span><br><span class=\"line\">    self.renderBuffer = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    gl<span class=\"constructor\">DeleteFramebuffers(1, &amp;<span class=\"params\">_frameBuffer</span>)</span>;</span><br><span class=\"line\">    self.frameBuffer = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>4.设置renderBuffer</strong></p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//4.设置renderBuffer </span></span><br><span class=\"line\">-(<span class=\"literal\">void</span>)setupRenderBuffer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//定义一个缓存区ID</span></span><br><span class=\"line\">    GLuint renderBuffer;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//申请一个缓存区标志</span></span><br><span class=\"line\">    glGenRenderbuffers(<span class=\"number\">1</span>, &amp;renderBuffer); </span><br><span class=\"line\">    <span class=\"built_in\">self</span>.renderBuffer = renderBuffer;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//将标识符绑定到GL_RENDERBUFFER</span></span><br><span class=\"line\">    glBindRenderbuffer(GL_RENDERBUFFER, <span class=\"built_in\">self</span>.renderBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//将可绘制对象drawable object&#x27;s  CAEAGLLayer的存储绑定到OpenGL ES renderBuffer对象</span></span><br><span class=\"line\">    <span class=\"meta\">[</span><span class=\"built_in\">self</span>.context renderbufferStorage:GL_RENDERBUFFER fromDrawable:<span class=\"built_in\">self</span>.eaglLayer<span class=\"meta\">]</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>5.设置frameBuffer</strong></p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//5.设置frameBuffer</span></span><br><span class=\"line\">- (void)setupFrameBuffer &#123;</span><br><span class=\"line\">    GLuint frameBuffer;</span><br><span class=\"line\">    </span><br><span class=\"line\">    gl<span class=\"constructor\">GenFramebuffers(1, &amp;<span class=\"params\">frameBuffer</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    self.frameBuffer = frameBuffer;</span><br><span class=\"line\">    </span><br><span class=\"line\">    gl<span class=\"constructor\">BindFramebuffer(GL_FRAMEBUFFER, <span class=\"params\">self</span>.<span class=\"params\">frameBuffer</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/*生成帧缓存区之后，则需要将renderbuffer跟framebuffer进行绑定，</span></span><br><span class=\"line\"><span class=\"comment\">     调用glFramebufferRenderbuffer函数进行绑定到对应的附着点上，后面的绘制才能起作用</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"comment\">//将渲染缓存区frameBuffer 通过glFramebufferRenderbuffer函数绑定到 GL_COLOR_ATTACHMENT0上。</span></span><br><span class=\"line\">    gl<span class=\"constructor\">FramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, <span class=\"params\">self</span>.<span class=\"params\">renderBuffer</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>6.开始绘制</strong></p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//6.开始绘制</span></span><br><span class=\"line\">- (void)renderLayer &#123;</span><br><span class=\"line\">    <span class=\"comment\">//设置背景色</span></span><br><span class=\"line\">    gl<span class=\"constructor\">ClearColor(0.45, 0.5, 0, 1)</span>;</span><br><span class=\"line\">    <span class=\"comment\">//清空颜色缓冲区</span></span><br><span class=\"line\">    gl<span class=\"constructor\">Clear(GL_COLOR_BUFFER_BIT)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    CGFloat scale = <span class=\"literal\">[UIS<span class=\"identifier\">creen</span> <span class=\"identifier\">mainScreen</span>]</span>.scale;</span><br><span class=\"line\">    <span class=\"comment\">//设置视口</span></span><br><span class=\"line\">    gl<span class=\"constructor\">Viewport(<span class=\"params\">self</span>.<span class=\"params\">frame</span>.<span class=\"params\">origin</span>.<span class=\"params\">x</span> <span class=\"operator\">*</span> <span class=\"params\">scale</span>, <span class=\"params\">self</span>.<span class=\"params\">frame</span>.<span class=\"params\">origin</span>.<span class=\"params\">y</span> <span class=\"operator\">*</span> <span class=\"params\">scale</span>, <span class=\"params\">self</span>.<span class=\"params\">frame</span>.<span class=\"params\">size</span>.<span class=\"params\">width</span> <span class=\"operator\">*</span> <span class=\"params\">scale</span>, <span class=\"params\">self</span>.<span class=\"params\">frame</span>.<span class=\"params\">size</span>.<span class=\"params\">height</span> <span class=\"operator\">*</span> <span class=\"params\">scale</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//顶点着色器和片元着色器文件路径</span></span><br><span class=\"line\">    NSString *vertFilePath = <span class=\"literal\">[[NSB<span class=\"identifier\">undle</span> <span class=\"identifier\">mainBundle</span>]</span> pathForResource:@<span class=\"string\">&quot;shaderv&quot;</span> ofType:@<span class=\"string\">&quot;vsh&quot;</span>];</span><br><span class=\"line\">    NSString *fragFilePath = <span class=\"literal\">[[NSB<span class=\"identifier\">undle</span> <span class=\"identifier\">mainBundle</span>]</span> pathForResource:@<span class=\"string\">&quot;shaderf&quot;</span> ofType:@<span class=\"string\">&quot;fsh&quot;</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//加载顶点着色器和纹理着色器 创建program</span></span><br><span class=\"line\">    self.program = <span class=\"literal\">[<span class=\"identifier\">self</span> <span class=\"identifier\">loaderShader</span>:<span class=\"identifier\">vertFilePath</span> <span class=\"identifier\">withFrag</span>:<span class=\"identifier\">fragFilePath</span>]</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//链接program</span></span><br><span class=\"line\">    gl<span class=\"constructor\">LinkProgram(<span class=\"params\">self</span>.<span class=\"params\">program</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//获取program链接状态</span></span><br><span class=\"line\">    GLint linkStatus;</span><br><span class=\"line\">    gl<span class=\"constructor\">GetProgramiv(<span class=\"params\">self</span>.<span class=\"params\">program</span>, GL_LINK_STATUS, &amp;<span class=\"params\">linkStatus</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (linkStatus<span class=\"operator\"> == </span>GL_FALSE) &#123;</span><br><span class=\"line\">        GLchar loginfo<span class=\"literal\">[<span class=\"number\">512</span>]</span>;</span><br><span class=\"line\">        gl<span class=\"constructor\">GetProgramInfoLog(<span class=\"params\">self</span>.<span class=\"params\">program</span>, <span class=\"params\">sizeof</span>(<span class=\"params\">loginfo</span>)</span>, <span class=\"number\">0</span>, &amp;loginfo<span class=\"literal\">[<span class=\"number\">0</span>]</span>);</span><br><span class=\"line\">        NSString *message = <span class=\"literal\">[NSS<span class=\"identifier\">tring</span> <span class=\"identifier\">stringWithUTF8String</span>:<span class=\"identifier\">loginfo</span>]</span>;</span><br><span class=\"line\">        <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;program link error:%@&quot;</span>, <span class=\"params\">message</span>)</span>;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//使用program</span></span><br><span class=\"line\">    gl<span class=\"constructor\">UseProgram(<span class=\"params\">self</span>.<span class=\"params\">program</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//准备顶点数据/纹理坐标</span></span><br><span class=\"line\">    GLfloat attrArr<span class=\"literal\">[]</span> =</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         <span class=\"number\">0.5</span>f, -<span class=\"number\">0.5</span>f, -<span class=\"number\">1.0</span>f,     <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">         -<span class=\"number\">0.5</span>f, <span class=\"number\">0.5</span>f, -<span class=\"number\">1.0</span>f,     <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">         -<span class=\"number\">0.5</span>f, -<span class=\"number\">0.5</span>f, -<span class=\"number\">1.0</span>f,    <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">         </span><br><span class=\"line\">         <span class=\"number\">0.5</span>f, <span class=\"number\">0.5</span>f, -<span class=\"number\">1.0</span>f,      <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">         -<span class=\"number\">0.5</span>f, <span class=\"number\">0.5</span>f, -<span class=\"number\">1.0</span>f,     <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">         <span class=\"number\">0.5</span>f, -<span class=\"number\">0.5</span>f, -<span class=\"number\">1.0</span>f,     <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//将顶点坐标和纹理坐标拷贝到GPU中</span></span><br><span class=\"line\">    GLuint attrBuffer;</span><br><span class=\"line\">    gl<span class=\"constructor\">GenBuffers(1, &amp;<span class=\"params\">attrBuffer</span>)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">BindBuffer(GL_ARRAY_BUFFER, <span class=\"params\">attrBuffer</span>)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">BufferData(GL_ARRAY_BUFFER, <span class=\"params\">sizeof</span>(<span class=\"params\">attrArr</span>)</span>, attrArr, GL_DYNAMIC_DRAW);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//获取顶点数据通道ID v.sh positon 打开顶点通道 并设置数据读取方式</span></span><br><span class=\"line\">    GLuint position = gl<span class=\"constructor\">GetAttribLocation(<span class=\"params\">self</span>.<span class=\"params\">program</span>, <span class=\"string\">&quot;position&quot;</span>)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">EnableVertexAttribArray(<span class=\"params\">position</span>)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">VertexAttribPointer(<span class=\"params\">position</span>, 3, GL_FLOAT, GL_FALSE, <span class=\"params\">sizeof</span>(GLfloat)</span><span class=\"operator\"> * </span><span class=\"number\">5</span>, (GLfloat *)NULL + <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//打开纹理通道 并设置数据读取方式</span></span><br><span class=\"line\">    GLuint textCoordinate = gl<span class=\"constructor\">GetAttribLocation(<span class=\"params\">self</span>.<span class=\"params\">program</span>, <span class=\"string\">&quot;textCoordinate&quot;</span>)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">EnableVertexAttribArray(<span class=\"params\">textCoordinate</span>)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">VertexAttribPointer(<span class=\"params\">textCoordinate</span>, 2, GL_FLOAT, GL_FALSE, <span class=\"params\">sizeof</span>(GLfloat)</span><span class=\"operator\"> * </span><span class=\"number\">5</span>, (GLfloat *)NULL + <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//加载纹理</span></span><br><span class=\"line\">    <span class=\"literal\">[<span class=\"identifier\">self</span> <span class=\"identifier\">setupTexture</span>:@&quot;<span class=\"identifier\">mew_progressive</span>.<span class=\"identifier\">jpg</span>&quot;]</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置纹理采样器</span></span><br><span class=\"line\">    gl<span class=\"constructor\">Uniform1i(<span class=\"params\">glGetUniformLocation</span>(<span class=\"params\">self</span>.<span class=\"params\">program</span>, <span class=\"string\">&quot;colorMap&quot;</span>)</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//开始绘制</span></span><br><span class=\"line\">    gl<span class=\"constructor\">DrawArrays(GL_TRIANGLES, 0, 6)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//从渲染缓冲区显示到屏幕上</span></span><br><span class=\"line\">    <span class=\"literal\">[<span class=\"identifier\">self</span>.<span class=\"identifier\">context</span> <span class=\"identifier\">presentRenderbuffer</span>:GL<span class=\"identifier\">_RENDERBUFFER</span>]</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>加载纹理</strong></p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//加载纹理</span></span><br><span class=\"line\">- (GLuint)setupTexture:(NSString *)filePath &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取图像CGImage</span></span><br><span class=\"line\">    CGImageRef cgImage = [UIImage imageNamed:filePath].CGImage;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cgImage) &#123;</span><br><span class=\"line\">        NSLog(@<span class=\"string\">&quot;faile to load image&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//获取图片宽高</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> <span class=\"built_in\">width</span> = CGImageGetWidth(cgImage);</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> <span class=\"built_in\">height</span> = CGImageGetHeight(cgImage);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//获取图片字节数 宽*高*4（RGBA）</span></span><br><span class=\"line\">    GLubyte *data = (GLubyte *)<span class=\"built_in\">calloc</span>(<span class=\"built_in\">width</span> * <span class=\"built_in\">height</span> * <span class=\"number\">4</span>, <span class=\"keyword\">sizeof</span>(GLubyte));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建上下文</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     参数1：data,指向要渲染的绘制图像的内存地址</span></span><br><span class=\"line\"><span class=\"comment\">     参数2：width,bitmap的宽度，单位为像素</span></span><br><span class=\"line\"><span class=\"comment\">     参数3：height,bitmap的高度，单位为像素</span></span><br><span class=\"line\"><span class=\"comment\">     参数4：bitPerComponent,内存中像素的每个组件的位数，比如32位RGBA，就设置为8</span></span><br><span class=\"line\"><span class=\"comment\">     参数5：bytesPerRow,bitmap的没一行的内存所占的比特数</span></span><br><span class=\"line\"><span class=\"comment\">     参数6：colorSpace,bitmap上使用的颜色空间  kCGImageAlphaPremultipliedLast：RGBA</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    CGContextRef cgContext = CGBitmapContextCreate(</span><br><span class=\"line\">                                                   data,</span><br><span class=\"line\">                                                   <span class=\"built_in\">width</span>,</span><br><span class=\"line\">                                                   <span class=\"built_in\">height</span>,</span><br><span class=\"line\">                                                   <span class=\"number\">8</span>,</span><br><span class=\"line\">                                                   <span class=\"built_in\">width</span> * <span class=\"number\">4</span>,</span><br><span class=\"line\">                                                   CGImageGetColorSpace(cgImage),</span><br><span class=\"line\">                                                   kCGImageAlphaPremultipliedLast);</span><br><span class=\"line\">    <span class=\"comment\">//使用CGContextRef 将图片绘制出来 也是一个解码的过程</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     CGContextDrawImage 使用的是Core Graphics框架，坐标系与UIKit 不一样。UIKit框架的原点在屏幕的左上角，Core Graphics框架的原点在屏幕的左下角。</span></span><br><span class=\"line\"><span class=\"comment\">     CGContextDrawImage</span></span><br><span class=\"line\"><span class=\"comment\">     参数1：绘图上下文</span></span><br><span class=\"line\"><span class=\"comment\">     参数2：rect坐标</span></span><br><span class=\"line\"><span class=\"comment\">     参数3：绘制的图片</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    CGRect <span class=\"built_in\">rect</span> = CGRectMake(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"built_in\">width</span>, <span class=\"built_in\">height</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    CGContextDrawImage(cgContext, <span class=\"built_in\">rect</span>, cgImage);</span><br><span class=\"line\">    </span><br><span class=\"line\">    CGContextRelease(cgContext);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//纹理 当只有一个纹理时 纹理ID为0, 多个纹理需要激活</span></span><br><span class=\"line\">    GLuint textureID;</span><br><span class=\"line\">    glGenTextures(<span class=\"number\">1</span>, &amp;textureID);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, textureID);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置纹理属性</span></span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">float</span> fw = <span class=\"built_in\">width</span>, fh = <span class=\"built_in\">height</span>;</span><br><span class=\"line\">    <span class=\"comment\">//载入纹理2D数据</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     参数1：纹理模式，GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D</span></span><br><span class=\"line\"><span class=\"comment\">     参数2：加载的层次，一般设置为0</span></span><br><span class=\"line\"><span class=\"comment\">     参数3：纹理的颜色值GL_RGBA</span></span><br><span class=\"line\"><span class=\"comment\">     参数4：宽</span></span><br><span class=\"line\"><span class=\"comment\">     参数5：高</span></span><br><span class=\"line\"><span class=\"comment\">     参数6：border，边界宽度</span></span><br><span class=\"line\"><span class=\"comment\">     参数7：format</span></span><br><span class=\"line\"><span class=\"comment\">     参数8：type</span></span><br><span class=\"line\"><span class=\"comment\">     参数9：纹理数据</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    glTexImage2D(GL_TEXTURE_2D, <span class=\"number\">0</span>, GL_RGBA, fw, fh, <span class=\"number\">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">free</span>(data);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>加载着色器</strong></p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//加载着色器</span></span><br><span class=\"line\">- (GLuint)loaderShader:(NSString *)vert withFrag:(NSString *)frag &#123;</span><br><span class=\"line\">    <span class=\"comment\">//顶点着色器对象 片元着色器对象/句柄</span></span><br><span class=\"line\">    GLuint verShader, fragShader;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建空的program</span></span><br><span class=\"line\">    GLuint program = gl<span class=\"constructor\">CreateProgram()</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//编译</span></span><br><span class=\"line\">    <span class=\"literal\">[<span class=\"identifier\">self</span> <span class=\"identifier\">compileShader</span>:&amp;<span class=\"identifier\">verShader</span> <span class=\"identifier\">type</span>:GL<span class=\"identifier\">_VERTEX_SHADER</span> <span class=\"identifier\">filePath</span>:<span class=\"identifier\">vert</span>]</span>;</span><br><span class=\"line\">    <span class=\"literal\">[<span class=\"identifier\">self</span> <span class=\"identifier\">compileShader</span>:&amp;<span class=\"identifier\">fragShader</span> <span class=\"identifier\">type</span>:GL<span class=\"identifier\">_FRAGMENT_SHADER</span> <span class=\"identifier\">filePath</span>:<span class=\"identifier\">frag</span>]</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//把shader附着 到编译好的程序</span></span><br><span class=\"line\">    gl<span class=\"constructor\">AttachShader(<span class=\"params\">program</span>, <span class=\"params\">verShader</span>)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">AttachShader(<span class=\"params\">program</span>, <span class=\"params\">fragShader</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//附着之后 就可以删除</span></span><br><span class=\"line\">    gl<span class=\"constructor\">DeleteShader(<span class=\"params\">verShader</span>)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">DeleteShader(<span class=\"params\">fragShader</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return program;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>编译program</strong></p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//编译</span><br><span class=\"line\">- (void)compileShader:(<span class=\"type\">GLuint</span> *)shader <span class=\"keyword\">type</span>:(<span class=\"type\">GLenum</span>)<span class=\"keyword\">type</span> filePath:(<span class=\"type\">NSString</span> *)filePath &#123;</span><br><span class=\"line\">    //读取路径</span><br><span class=\"line\">    <span class=\"type\">NSString</span> *content = [<span class=\"type\">NSString</span> stringWithContentsOfFile:filePath encoding:<span class=\"type\">NSUTF8StringEncoding</span> error:nil];</span><br><span class=\"line\">    const <span class=\"type\">GLchar</span> *source = [content <span class=\"type\">UTF8String</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    //创建对应类型的shader</span><br><span class=\"line\">    *shader = glCreateShader(type);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //将着色器附着到 着色器对象上</span><br><span class=\"line\">    glShaderSource(*shader, 1, &amp;source, <span class=\"type\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //编译</span><br><span class=\"line\">    glCompileShader(*shader);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>demo地址：<a href=\"%5Bhttps://github.com/ugpass/GLSL_Hello_World%5D(https://github.com/ugpass/GLSL_Hello_World)\">GLSL加载图片</a></p>\n<blockquote>\n<p><code>glVertexAttribPointer</code>函数最后一个参数，从哪里开始访问数据的 <code>NULL</code>， 如果不加<code>(GLfloat *)</code>，将会导致纹理加载不上去！！！</p>\n</blockquote>\n<blockquote>\n<p>由于CoreGraphics坐标系与UIKit不一致，导致图片显示为倒的，之后介绍五种旋转图片的方法。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>使用GLSL语言加载纹理，需要自定义顶点着色器和片源着色器。</p>\n<p>GLSL编写的顶点着色器和片元着色器其实是一段代码，也是一段字符串，所以文件名和后缀可以自定义。</p>\n<p>通过创建<code>Empty</code>文件，修改文件名为<code>shaderv.vsh</code> 和  <code>shaderf.fsh</code>，分别代表顶点着色器和片元着色器。在GLSL语言编写的文件中，建议不要写中文注释，否则可能发生一些奇怪的错误。</p>\n<p><code>顶点着色器 shaderv.vsh</code>代码</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec4</span> position;</span><br><span class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec2</span> textCoordinate;</span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"keyword\">lowp</span> <span class=\"type\">vec2</span> varyTextCoord;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    varyTextCoord = textCoordinate;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">gl_Position</span> = position;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p> 解释：<br> attribute vec4 position; 指的是attribute属性的 4维向量 的顶点坐标。<br> attribute vec2 textCoordinate; 指的是attribute属性的 2维向量 的纹理坐标。<br> varying lowp vec2 varyTextCoord; 指的是通过顶点着色器透传到片元着色器中的 低精度 的 2维向量 的纹理坐标。<br> <code>varying</code>修饰符代表可以通过顶点着色器传参到片元着色器，在片元着色器中的接收变量 声明 需要和顶点着色器中 <strong>一模一样</strong>。<br> 每一个着色器文件都有一个<code>main</code>函数。<br>  varyTextCoord = textCoordinate; 将纹理坐标通过<code>varyTextCoord</code>变量传递到片元着色器。<br> gl_Position = position; 不对顶点坐标做任何处理，直接传入给OpenGL ES中的内建变量<code>gl_Position</code>。</p>\n</blockquote>\n<p><code>片元着色器 shaderf.fsh</code>代码</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">precision</span> <span class=\"keyword\">highp</span> <span class=\"type\">float</span>;</span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"keyword\">lowp</span> <span class=\"type\">vec2</span> varyTextCoord;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> colorMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">lowp</span> <span class=\"type\">vec4</span> temp = <span class=\"built_in\">texture2D</span>(colorMap, varyTextCoord);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>解释：<br>precision highp float; 在本文件中使用高精度的 <code>float</code>。<br>varying lowp vec2 varyTextCoord; 声明和顶点着色器中一致，用来接收纹理坐标。<br>uniform sampler2D colorMap;  纹理采样器<br>texture2D(colorMap, varyTextCoord); 通过纹理采样器，获取纹理每个像素点对应的颜色值，赋值给OpenGL ES中的内建变量<code>gl_FragColor</code>。</p>\n</blockquote>\n<p>使用GLSL编写自定义着色器加载纹理需要以下步骤：</p>\n<ul>\n<li>创建图层</li>\n<li>创建上下文</li>\n<li>清空缓冲区</li>\n<li>设置renderBuffer</li>\n<li>设置frameBuffer</li>\n<li>开始绘制</li>\n</ul>\n<blockquote>\n<p>以下代码在自定义CustomView继承自UIView中编写。</p>\n</blockquote>\n<p><strong>0.定义属性</strong></p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@interface</span> CustomView()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">@property</span> (nonatomic, strong) CAEAGLLayer *eaglLayer;<span class=\"comment\">//自定义图层</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">@property</span> (nonatomic, strong) EAGLContext *context;<span class=\"comment\">//上下文</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">@property</span> (nonatomic, assign) GLuint renderBuffer;<span class=\"comment\">//渲染缓冲区ID</span></span><br><span class=\"line\"><span class=\"variable\">@property</span> (nonatomic, assign) GLuint frameBuffer;<span class=\"comment\">//帧缓冲区ID</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">@property</span> (nonatomic, assign) GLuint program;<span class=\"comment\">//程序ID</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>1.创建图层</strong></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.设置图层</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setupLayer &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.eaglLayer = (<span class=\"built_in\">CAEAGLLayer</span> *)<span class=\"keyword\">self</span>.layer;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setContentScaleFactor:[<span class=\"built_in\">UIScreen</span> mainScreen].scale];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     kEAGLDrawablePropertyColorFormat:颜色缓冲区格式</span></span><br><span class=\"line\"><span class=\"comment\">     kEAGLDrawablePropertyRetainedBacking:绘制后是否保留其内容</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.eaglLayer.drawableProperties = [<span class=\"built_in\">NSDictionary</span> dictionaryWithObjectsAndKeys:@false, kEAGLDrawablePropertyRetainedBacking, kEAGLColorFormatRGBA8, kEAGLDrawablePropertyColorFormat, <span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要重写<code>+ (Class)layerClass;</code>方法才能强转生效。</p>\n<figure class=\"highlight monkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"class\"><span class=\"keyword\">Class</span>)<span class=\"title\">layerClass</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [CAEAGLLayer <span class=\"class\"><span class=\"keyword\">class</span>];</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2.创建上下文</strong></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//2.设置上下文</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)setupContext &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>.context) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;create context failed&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> ret = [EAGLContext setCurrentContext:<span class=\"keyword\">self</span>.context];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ret) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;setCurrentContext failed&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>3.清空缓冲区</strong></p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//3.清空缓冲区</span></span><br><span class=\"line\">- (void)clearRenderAndFrameBuffer &#123;</span><br><span class=\"line\">    <span class=\"comment\">//Frame Buffer Object FBO</span></span><br><span class=\"line\">    <span class=\"comment\">//Render Buffer 三类：颜色缓冲区、深度缓冲区、模版缓冲区</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    gl<span class=\"constructor\">DeleteRenderbuffers(1, &amp;<span class=\"params\">_renderBuffer</span>)</span>;</span><br><span class=\"line\">    self.renderBuffer = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    gl<span class=\"constructor\">DeleteFramebuffers(1, &amp;<span class=\"params\">_frameBuffer</span>)</span>;</span><br><span class=\"line\">    self.frameBuffer = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>4.设置renderBuffer</strong></p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//4.设置renderBuffer </span></span><br><span class=\"line\">-(<span class=\"literal\">void</span>)setupRenderBuffer</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//定义一个缓存区ID</span></span><br><span class=\"line\">    GLuint renderBuffer;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//申请一个缓存区标志</span></span><br><span class=\"line\">    glGenRenderbuffers(<span class=\"number\">1</span>, &amp;renderBuffer); </span><br><span class=\"line\">    <span class=\"built_in\">self</span>.renderBuffer = renderBuffer;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//将标识符绑定到GL_RENDERBUFFER</span></span><br><span class=\"line\">    glBindRenderbuffer(GL_RENDERBUFFER, <span class=\"built_in\">self</span>.renderBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//将可绘制对象drawable object&#x27;s  CAEAGLLayer的存储绑定到OpenGL ES renderBuffer对象</span></span><br><span class=\"line\">    <span class=\"meta\">[</span><span class=\"built_in\">self</span>.context renderbufferStorage:GL_RENDERBUFFER fromDrawable:<span class=\"built_in\">self</span>.eaglLayer<span class=\"meta\">]</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>5.设置frameBuffer</strong></p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//5.设置frameBuffer</span></span><br><span class=\"line\">- (void)setupFrameBuffer &#123;</span><br><span class=\"line\">    GLuint frameBuffer;</span><br><span class=\"line\">    </span><br><span class=\"line\">    gl<span class=\"constructor\">GenFramebuffers(1, &amp;<span class=\"params\">frameBuffer</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    self.frameBuffer = frameBuffer;</span><br><span class=\"line\">    </span><br><span class=\"line\">    gl<span class=\"constructor\">BindFramebuffer(GL_FRAMEBUFFER, <span class=\"params\">self</span>.<span class=\"params\">frameBuffer</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/*生成帧缓存区之后，则需要将renderbuffer跟framebuffer进行绑定，</span></span><br><span class=\"line\"><span class=\"comment\">     调用glFramebufferRenderbuffer函数进行绑定到对应的附着点上，后面的绘制才能起作用</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"comment\">//将渲染缓存区frameBuffer 通过glFramebufferRenderbuffer函数绑定到 GL_COLOR_ATTACHMENT0上。</span></span><br><span class=\"line\">    gl<span class=\"constructor\">FramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, <span class=\"params\">self</span>.<span class=\"params\">renderBuffer</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>6.开始绘制</strong></p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//6.开始绘制</span></span><br><span class=\"line\">- (void)renderLayer &#123;</span><br><span class=\"line\">    <span class=\"comment\">//设置背景色</span></span><br><span class=\"line\">    gl<span class=\"constructor\">ClearColor(0.45, 0.5, 0, 1)</span>;</span><br><span class=\"line\">    <span class=\"comment\">//清空颜色缓冲区</span></span><br><span class=\"line\">    gl<span class=\"constructor\">Clear(GL_COLOR_BUFFER_BIT)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    CGFloat scale = <span class=\"literal\">[UIS<span class=\"identifier\">creen</span> <span class=\"identifier\">mainScreen</span>]</span>.scale;</span><br><span class=\"line\">    <span class=\"comment\">//设置视口</span></span><br><span class=\"line\">    gl<span class=\"constructor\">Viewport(<span class=\"params\">self</span>.<span class=\"params\">frame</span>.<span class=\"params\">origin</span>.<span class=\"params\">x</span> <span class=\"operator\">*</span> <span class=\"params\">scale</span>, <span class=\"params\">self</span>.<span class=\"params\">frame</span>.<span class=\"params\">origin</span>.<span class=\"params\">y</span> <span class=\"operator\">*</span> <span class=\"params\">scale</span>, <span class=\"params\">self</span>.<span class=\"params\">frame</span>.<span class=\"params\">size</span>.<span class=\"params\">width</span> <span class=\"operator\">*</span> <span class=\"params\">scale</span>, <span class=\"params\">self</span>.<span class=\"params\">frame</span>.<span class=\"params\">size</span>.<span class=\"params\">height</span> <span class=\"operator\">*</span> <span class=\"params\">scale</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//顶点着色器和片元着色器文件路径</span></span><br><span class=\"line\">    NSString *vertFilePath = <span class=\"literal\">[[NSB<span class=\"identifier\">undle</span> <span class=\"identifier\">mainBundle</span>]</span> pathForResource:@<span class=\"string\">&quot;shaderv&quot;</span> ofType:@<span class=\"string\">&quot;vsh&quot;</span>];</span><br><span class=\"line\">    NSString *fragFilePath = <span class=\"literal\">[[NSB<span class=\"identifier\">undle</span> <span class=\"identifier\">mainBundle</span>]</span> pathForResource:@<span class=\"string\">&quot;shaderf&quot;</span> ofType:@<span class=\"string\">&quot;fsh&quot;</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//加载顶点着色器和纹理着色器 创建program</span></span><br><span class=\"line\">    self.program = <span class=\"literal\">[<span class=\"identifier\">self</span> <span class=\"identifier\">loaderShader</span>:<span class=\"identifier\">vertFilePath</span> <span class=\"identifier\">withFrag</span>:<span class=\"identifier\">fragFilePath</span>]</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//链接program</span></span><br><span class=\"line\">    gl<span class=\"constructor\">LinkProgram(<span class=\"params\">self</span>.<span class=\"params\">program</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//获取program链接状态</span></span><br><span class=\"line\">    GLint linkStatus;</span><br><span class=\"line\">    gl<span class=\"constructor\">GetProgramiv(<span class=\"params\">self</span>.<span class=\"params\">program</span>, GL_LINK_STATUS, &amp;<span class=\"params\">linkStatus</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (linkStatus<span class=\"operator\"> == </span>GL_FALSE) &#123;</span><br><span class=\"line\">        GLchar loginfo<span class=\"literal\">[<span class=\"number\">512</span>]</span>;</span><br><span class=\"line\">        gl<span class=\"constructor\">GetProgramInfoLog(<span class=\"params\">self</span>.<span class=\"params\">program</span>, <span class=\"params\">sizeof</span>(<span class=\"params\">loginfo</span>)</span>, <span class=\"number\">0</span>, &amp;loginfo<span class=\"literal\">[<span class=\"number\">0</span>]</span>);</span><br><span class=\"line\">        NSString *message = <span class=\"literal\">[NSS<span class=\"identifier\">tring</span> <span class=\"identifier\">stringWithUTF8String</span>:<span class=\"identifier\">loginfo</span>]</span>;</span><br><span class=\"line\">        <span class=\"constructor\">NSLog(@<span class=\"string\">&quot;program link error:%@&quot;</span>, <span class=\"params\">message</span>)</span>;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//使用program</span></span><br><span class=\"line\">    gl<span class=\"constructor\">UseProgram(<span class=\"params\">self</span>.<span class=\"params\">program</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//准备顶点数据/纹理坐标</span></span><br><span class=\"line\">    GLfloat attrArr<span class=\"literal\">[]</span> =</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         <span class=\"number\">0.5</span>f, -<span class=\"number\">0.5</span>f, -<span class=\"number\">1.0</span>f,     <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">         -<span class=\"number\">0.5</span>f, <span class=\"number\">0.5</span>f, -<span class=\"number\">1.0</span>f,     <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">         -<span class=\"number\">0.5</span>f, -<span class=\"number\">0.5</span>f, -<span class=\"number\">1.0</span>f,    <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">         </span><br><span class=\"line\">         <span class=\"number\">0.5</span>f, <span class=\"number\">0.5</span>f, -<span class=\"number\">1.0</span>f,      <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">         -<span class=\"number\">0.5</span>f, <span class=\"number\">0.5</span>f, -<span class=\"number\">1.0</span>f,     <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f,</span><br><span class=\"line\">         <span class=\"number\">0.5</span>f, -<span class=\"number\">0.5</span>f, -<span class=\"number\">1.0</span>f,     <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f,</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//将顶点坐标和纹理坐标拷贝到GPU中</span></span><br><span class=\"line\">    GLuint attrBuffer;</span><br><span class=\"line\">    gl<span class=\"constructor\">GenBuffers(1, &amp;<span class=\"params\">attrBuffer</span>)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">BindBuffer(GL_ARRAY_BUFFER, <span class=\"params\">attrBuffer</span>)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">BufferData(GL_ARRAY_BUFFER, <span class=\"params\">sizeof</span>(<span class=\"params\">attrArr</span>)</span>, attrArr, GL_DYNAMIC_DRAW);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//获取顶点数据通道ID v.sh positon 打开顶点通道 并设置数据读取方式</span></span><br><span class=\"line\">    GLuint position = gl<span class=\"constructor\">GetAttribLocation(<span class=\"params\">self</span>.<span class=\"params\">program</span>, <span class=\"string\">&quot;position&quot;</span>)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">EnableVertexAttribArray(<span class=\"params\">position</span>)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">VertexAttribPointer(<span class=\"params\">position</span>, 3, GL_FLOAT, GL_FALSE, <span class=\"params\">sizeof</span>(GLfloat)</span><span class=\"operator\"> * </span><span class=\"number\">5</span>, (GLfloat *)NULL + <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//打开纹理通道 并设置数据读取方式</span></span><br><span class=\"line\">    GLuint textCoordinate = gl<span class=\"constructor\">GetAttribLocation(<span class=\"params\">self</span>.<span class=\"params\">program</span>, <span class=\"string\">&quot;textCoordinate&quot;</span>)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">EnableVertexAttribArray(<span class=\"params\">textCoordinate</span>)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">VertexAttribPointer(<span class=\"params\">textCoordinate</span>, 2, GL_FLOAT, GL_FALSE, <span class=\"params\">sizeof</span>(GLfloat)</span><span class=\"operator\"> * </span><span class=\"number\">5</span>, (GLfloat *)NULL + <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//加载纹理</span></span><br><span class=\"line\">    <span class=\"literal\">[<span class=\"identifier\">self</span> <span class=\"identifier\">setupTexture</span>:@&quot;<span class=\"identifier\">mew_progressive</span>.<span class=\"identifier\">jpg</span>&quot;]</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置纹理采样器</span></span><br><span class=\"line\">    gl<span class=\"constructor\">Uniform1i(<span class=\"params\">glGetUniformLocation</span>(<span class=\"params\">self</span>.<span class=\"params\">program</span>, <span class=\"string\">&quot;colorMap&quot;</span>)</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//开始绘制</span></span><br><span class=\"line\">    gl<span class=\"constructor\">DrawArrays(GL_TRIANGLES, 0, 6)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//从渲染缓冲区显示到屏幕上</span></span><br><span class=\"line\">    <span class=\"literal\">[<span class=\"identifier\">self</span>.<span class=\"identifier\">context</span> <span class=\"identifier\">presentRenderbuffer</span>:GL<span class=\"identifier\">_RENDERBUFFER</span>]</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>加载纹理</strong></p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//加载纹理</span></span><br><span class=\"line\">- (GLuint)setupTexture:(NSString *)filePath &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取图像CGImage</span></span><br><span class=\"line\">    CGImageRef cgImage = [UIImage imageNamed:filePath].CGImage;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cgImage) &#123;</span><br><span class=\"line\">        NSLog(@<span class=\"string\">&quot;faile to load image&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//获取图片宽高</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> <span class=\"built_in\">width</span> = CGImageGetWidth(cgImage);</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> <span class=\"built_in\">height</span> = CGImageGetHeight(cgImage);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//获取图片字节数 宽*高*4（RGBA）</span></span><br><span class=\"line\">    GLubyte *data = (GLubyte *)<span class=\"built_in\">calloc</span>(<span class=\"built_in\">width</span> * <span class=\"built_in\">height</span> * <span class=\"number\">4</span>, <span class=\"keyword\">sizeof</span>(GLubyte));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建上下文</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     参数1：data,指向要渲染的绘制图像的内存地址</span></span><br><span class=\"line\"><span class=\"comment\">     参数2：width,bitmap的宽度，单位为像素</span></span><br><span class=\"line\"><span class=\"comment\">     参数3：height,bitmap的高度，单位为像素</span></span><br><span class=\"line\"><span class=\"comment\">     参数4：bitPerComponent,内存中像素的每个组件的位数，比如32位RGBA，就设置为8</span></span><br><span class=\"line\"><span class=\"comment\">     参数5：bytesPerRow,bitmap的没一行的内存所占的比特数</span></span><br><span class=\"line\"><span class=\"comment\">     参数6：colorSpace,bitmap上使用的颜色空间  kCGImageAlphaPremultipliedLast：RGBA</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    CGContextRef cgContext = CGBitmapContextCreate(</span><br><span class=\"line\">                                                   data,</span><br><span class=\"line\">                                                   <span class=\"built_in\">width</span>,</span><br><span class=\"line\">                                                   <span class=\"built_in\">height</span>,</span><br><span class=\"line\">                                                   <span class=\"number\">8</span>,</span><br><span class=\"line\">                                                   <span class=\"built_in\">width</span> * <span class=\"number\">4</span>,</span><br><span class=\"line\">                                                   CGImageGetColorSpace(cgImage),</span><br><span class=\"line\">                                                   kCGImageAlphaPremultipliedLast);</span><br><span class=\"line\">    <span class=\"comment\">//使用CGContextRef 将图片绘制出来 也是一个解码的过程</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     CGContextDrawImage 使用的是Core Graphics框架，坐标系与UIKit 不一样。UIKit框架的原点在屏幕的左上角，Core Graphics框架的原点在屏幕的左下角。</span></span><br><span class=\"line\"><span class=\"comment\">     CGContextDrawImage</span></span><br><span class=\"line\"><span class=\"comment\">     参数1：绘图上下文</span></span><br><span class=\"line\"><span class=\"comment\">     参数2：rect坐标</span></span><br><span class=\"line\"><span class=\"comment\">     参数3：绘制的图片</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    CGRect <span class=\"built_in\">rect</span> = CGRectMake(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"built_in\">width</span>, <span class=\"built_in\">height</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    CGContextDrawImage(cgContext, <span class=\"built_in\">rect</span>, cgImage);</span><br><span class=\"line\">    </span><br><span class=\"line\">    CGContextRelease(cgContext);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//纹理 当只有一个纹理时 纹理ID为0, 多个纹理需要激活</span></span><br><span class=\"line\">    GLuint textureID;</span><br><span class=\"line\">    glGenTextures(<span class=\"number\">1</span>, &amp;textureID);</span><br><span class=\"line\">    </span><br><span class=\"line\">    glBindTexture(GL_TEXTURE_2D, textureID);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置纹理属性</span></span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">float</span> fw = <span class=\"built_in\">width</span>, fh = <span class=\"built_in\">height</span>;</span><br><span class=\"line\">    <span class=\"comment\">//载入纹理2D数据</span></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     参数1：纹理模式，GL_TEXTURE_1D、GL_TEXTURE_2D、GL_TEXTURE_3D</span></span><br><span class=\"line\"><span class=\"comment\">     参数2：加载的层次，一般设置为0</span></span><br><span class=\"line\"><span class=\"comment\">     参数3：纹理的颜色值GL_RGBA</span></span><br><span class=\"line\"><span class=\"comment\">     参数4：宽</span></span><br><span class=\"line\"><span class=\"comment\">     参数5：高</span></span><br><span class=\"line\"><span class=\"comment\">     参数6：border，边界宽度</span></span><br><span class=\"line\"><span class=\"comment\">     参数7：format</span></span><br><span class=\"line\"><span class=\"comment\">     参数8：type</span></span><br><span class=\"line\"><span class=\"comment\">     参数9：纹理数据</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    glTexImage2D(GL_TEXTURE_2D, <span class=\"number\">0</span>, GL_RGBA, fw, fh, <span class=\"number\">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">free</span>(data);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>加载着色器</strong></p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//加载着色器</span></span><br><span class=\"line\">- (GLuint)loaderShader:(NSString *)vert withFrag:(NSString *)frag &#123;</span><br><span class=\"line\">    <span class=\"comment\">//顶点着色器对象 片元着色器对象/句柄</span></span><br><span class=\"line\">    GLuint verShader, fragShader;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建空的program</span></span><br><span class=\"line\">    GLuint program = gl<span class=\"constructor\">CreateProgram()</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//编译</span></span><br><span class=\"line\">    <span class=\"literal\">[<span class=\"identifier\">self</span> <span class=\"identifier\">compileShader</span>:&amp;<span class=\"identifier\">verShader</span> <span class=\"identifier\">type</span>:GL<span class=\"identifier\">_VERTEX_SHADER</span> <span class=\"identifier\">filePath</span>:<span class=\"identifier\">vert</span>]</span>;</span><br><span class=\"line\">    <span class=\"literal\">[<span class=\"identifier\">self</span> <span class=\"identifier\">compileShader</span>:&amp;<span class=\"identifier\">fragShader</span> <span class=\"identifier\">type</span>:GL<span class=\"identifier\">_FRAGMENT_SHADER</span> <span class=\"identifier\">filePath</span>:<span class=\"identifier\">frag</span>]</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//把shader附着 到编译好的程序</span></span><br><span class=\"line\">    gl<span class=\"constructor\">AttachShader(<span class=\"params\">program</span>, <span class=\"params\">verShader</span>)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">AttachShader(<span class=\"params\">program</span>, <span class=\"params\">fragShader</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//附着之后 就可以删除</span></span><br><span class=\"line\">    gl<span class=\"constructor\">DeleteShader(<span class=\"params\">verShader</span>)</span>;</span><br><span class=\"line\">    gl<span class=\"constructor\">DeleteShader(<span class=\"params\">fragShader</span>)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return program;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>编译program</strong></p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//编译</span><br><span class=\"line\">- (void)compileShader:(<span class=\"type\">GLuint</span> *)shader <span class=\"keyword\">type</span>:(<span class=\"type\">GLenum</span>)<span class=\"keyword\">type</span> filePath:(<span class=\"type\">NSString</span> *)filePath &#123;</span><br><span class=\"line\">    //读取路径</span><br><span class=\"line\">    <span class=\"type\">NSString</span> *content = [<span class=\"type\">NSString</span> stringWithContentsOfFile:filePath encoding:<span class=\"type\">NSUTF8StringEncoding</span> error:nil];</span><br><span class=\"line\">    const <span class=\"type\">GLchar</span> *source = [content <span class=\"type\">UTF8String</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    //创建对应类型的shader</span><br><span class=\"line\">    *shader = glCreateShader(type);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //将着色器附着到 着色器对象上</span><br><span class=\"line\">    glShaderSource(*shader, 1, &amp;source, <span class=\"type\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //编译</span><br><span class=\"line\">    glCompileShader(*shader);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>demo地址：<a href=\"%5Bhttps://github.com/ugpass/GLSL_Hello_World%5D(https://github.com/ugpass/GLSL_Hello_World)\">GLSL加载图片</a></p>\n<blockquote>\n<p><code>glVertexAttribPointer</code>函数最后一个参数，从哪里开始访问数据的 <code>NULL</code>， 如果不加<code>(GLfloat *)</code>，将会导致纹理加载不上去！！！</p>\n</blockquote>\n<blockquote>\n<p>由于CoreGraphics坐标系与UIKit不一致，导致图片显示为倒的，之后介绍五种旋转图片的方法。</p>\n</blockquote>\n"},{"title":"翻转纹理的5种方式","date":"2020-08-01T16:00:00.000Z","_content":"\n由于`CoreGraphics`坐标系与`UIKit`坐标系不一致，导致`CoreGraphics`解码图片加载纹理后，图片显示倒置，下面介绍五种翻转纹理的方式。\n\n方式一：在顶点着色器中，给顶点坐标乘以一个旋转矩阵，之后再赋值给内建变量`gl_Position`。\n\n即顶点着色器代码改为\n```\nattribute vec4 position;\nattribute vec2 textCoordinate;\nvarying lowp vec2 varyTextCoord;\nuniform mat4 rotateMatrix;\n\nvoid main() {\n    varyTextCoord = textCoordinate;\n    \n    vec4 vPos = position;\n    vPos = vPos * rotateMatrix;\n    gl_Position = vPos;\n}\n```\n\n> 注意，如果想要获取shader里面的变量，必须要在glLinkProgram后面！\n\n在开始绘制步骤中 设置纹理采样器`glUniform1i` 和 开始绘制`glDrawArrays`之间将旋转矩阵传入顶点着色器。\n\n**设置旋转矩阵，旋转纹理**\n```\n//设置旋转矩阵\n- (void)rotateTexture {\n    //获取shader中的 rotateMatrix 变量\n    GLuint rotate = glGetUniformLocation(self.program, \"rotateMatrix\");\n    \n    //设置旋转弧度\n    float radians = 180 * 3.14159f / 180.0f;\n    \n    //求弧度对于的sin/cos值\n    float s = sin(radians);\n    float c = cos(radians);\n    \n    //旋转矩阵\n    GLfloat zRotation[16] = {\n        c,-s,0,0,\n        s,c,0,0,\n        0,0,1,0,\n        0,0,0,1\n    };\n    \n    //设置旋转矩阵\n    glUniformMatrix4fv(rotate, 1, GL_FALSE, zRotation);\n}\n```\n\n方法二：使用CoreGraphics函数 对图片做翻转\n\n在 加载纹理函数 `- (GLuint)setupTexture:(NSString *)filePath` 中，解码图片后，翻转坐标，再次重新绘制一次\n\n```\n    CGContextDrawImage(cgContext, rect, cgImage);\n    \n    CGContextTranslateCTM(cgContext, rect.origin.x, rect.origin.y);\n    CGContextTranslateCTM(cgContext, 0, height);\n    CGContextScaleCTM(cgContext, 1.0, -1.0);\n    CGContextTranslateCTM(cgContext, -rect.origin.x, -rect.origin.y);\n    CGContextDrawImage(cgContext, rect, cgImage);\n    \n    CGContextRelease(cgContext);\n```\n\n方法三：修改片元着色器，对纹理坐标的y值进行翻转\n```\nprecision highp float;\nvarying lowp vec2 varyTextCoord;\nuniform sampler2D colorMap;\n\nvoid main() {\n    lowp vec4 temp = texture2D(colorMap, vec2(varyTextCoord.x,1.0-varyTextCoord.y));\n    \n    gl_FragColor = temp;\n}\n```\n\n方法四：修改顶点着色器中的纹理坐标，对y值进行翻转\n```\nattribute vec4 position;\nattribute vec2 textCoordinate;\nvarying lowp vec2 varyTextCoord;\n\nvoid main() {\n    varyTextCoord = vec2(textCoordinate.x,1.0-textCoordinate.y);;\n    \n    gl_Position = position;\n} \n```\n\n方法五：直接修改顶点坐标 对应对纹理坐标\n```\nGLfloat attrArr[] =\n        {\n        0.5f, -0.5f, 0.0f,        1.0f, 1.0f, //右下\n        -0.5f, 0.5f, 0.0f,        0.0f, 0.0f, // 左上\n        -0.5f, -0.5f, 0.0f,       0.0f, 1.0f, // 左下\n        0.5f, 0.5f, 0.0f,         1.0f, 0.0f, // 右上\n        -0.5f, 0.5f, 0.0f,        0.0f, 0.0f, // 左上\n        0.5f, -0.5f, 0.0f,        1.0f, 1.0f, // 右下\n        };\n```\n\n> 推荐使用 方法二","source":"_posts/2020-08-02-翻转纹理的5种方式.md","raw":"---\ntitle:      \"翻转纹理的5种方式\" \ndate:       2020-08-02\ntags:\n    - OpenGL ES \ncategories:\n    - OpenGL ES \n---\n\n由于`CoreGraphics`坐标系与`UIKit`坐标系不一致，导致`CoreGraphics`解码图片加载纹理后，图片显示倒置，下面介绍五种翻转纹理的方式。\n\n方式一：在顶点着色器中，给顶点坐标乘以一个旋转矩阵，之后再赋值给内建变量`gl_Position`。\n\n即顶点着色器代码改为\n```\nattribute vec4 position;\nattribute vec2 textCoordinate;\nvarying lowp vec2 varyTextCoord;\nuniform mat4 rotateMatrix;\n\nvoid main() {\n    varyTextCoord = textCoordinate;\n    \n    vec4 vPos = position;\n    vPos = vPos * rotateMatrix;\n    gl_Position = vPos;\n}\n```\n\n> 注意，如果想要获取shader里面的变量，必须要在glLinkProgram后面！\n\n在开始绘制步骤中 设置纹理采样器`glUniform1i` 和 开始绘制`glDrawArrays`之间将旋转矩阵传入顶点着色器。\n\n**设置旋转矩阵，旋转纹理**\n```\n//设置旋转矩阵\n- (void)rotateTexture {\n    //获取shader中的 rotateMatrix 变量\n    GLuint rotate = glGetUniformLocation(self.program, \"rotateMatrix\");\n    \n    //设置旋转弧度\n    float radians = 180 * 3.14159f / 180.0f;\n    \n    //求弧度对于的sin/cos值\n    float s = sin(radians);\n    float c = cos(radians);\n    \n    //旋转矩阵\n    GLfloat zRotation[16] = {\n        c,-s,0,0,\n        s,c,0,0,\n        0,0,1,0,\n        0,0,0,1\n    };\n    \n    //设置旋转矩阵\n    glUniformMatrix4fv(rotate, 1, GL_FALSE, zRotation);\n}\n```\n\n方法二：使用CoreGraphics函数 对图片做翻转\n\n在 加载纹理函数 `- (GLuint)setupTexture:(NSString *)filePath` 中，解码图片后，翻转坐标，再次重新绘制一次\n\n```\n    CGContextDrawImage(cgContext, rect, cgImage);\n    \n    CGContextTranslateCTM(cgContext, rect.origin.x, rect.origin.y);\n    CGContextTranslateCTM(cgContext, 0, height);\n    CGContextScaleCTM(cgContext, 1.0, -1.0);\n    CGContextTranslateCTM(cgContext, -rect.origin.x, -rect.origin.y);\n    CGContextDrawImage(cgContext, rect, cgImage);\n    \n    CGContextRelease(cgContext);\n```\n\n方法三：修改片元着色器，对纹理坐标的y值进行翻转\n```\nprecision highp float;\nvarying lowp vec2 varyTextCoord;\nuniform sampler2D colorMap;\n\nvoid main() {\n    lowp vec4 temp = texture2D(colorMap, vec2(varyTextCoord.x,1.0-varyTextCoord.y));\n    \n    gl_FragColor = temp;\n}\n```\n\n方法四：修改顶点着色器中的纹理坐标，对y值进行翻转\n```\nattribute vec4 position;\nattribute vec2 textCoordinate;\nvarying lowp vec2 varyTextCoord;\n\nvoid main() {\n    varyTextCoord = vec2(textCoordinate.x,1.0-textCoordinate.y);;\n    \n    gl_Position = position;\n} \n```\n\n方法五：直接修改顶点坐标 对应对纹理坐标\n```\nGLfloat attrArr[] =\n        {\n        0.5f, -0.5f, 0.0f,        1.0f, 1.0f, //右下\n        -0.5f, 0.5f, 0.0f,        0.0f, 0.0f, // 左上\n        -0.5f, -0.5f, 0.0f,       0.0f, 1.0f, // 左下\n        0.5f, 0.5f, 0.0f,         1.0f, 0.0f, // 右上\n        -0.5f, 0.5f, 0.0f,        0.0f, 0.0f, // 左上\n        0.5f, -0.5f, 0.0f,        1.0f, 1.0f, // 右下\n        };\n```\n\n> 推荐使用 方法二","slug":"2020-08-02-翻转纹理的5种方式","published":1,"updated":"2021-06-19T03:46:24.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbpr001cbjrjhjy22qbh","content":"<p>由于<code>CoreGraphics</code>坐标系与<code>UIKit</code>坐标系不一致，导致<code>CoreGraphics</code>解码图片加载纹理后，图片显示倒置，下面介绍五种翻转纹理的方式。</p>\n<p>方式一：在顶点着色器中，给顶点坐标乘以一个旋转矩阵，之后再赋值给内建变量<code>gl_Position</code>。</p>\n<p>即顶点着色器代码改为</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec4</span> position;</span><br><span class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec2</span> textCoordinate;</span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"keyword\">lowp</span> <span class=\"type\">vec2</span> varyTextCoord;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">mat4</span> rotateMatrix;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    varyTextCoord = textCoordinate;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">vec4</span> vPos = position;</span><br><span class=\"line\">    vPos = vPos * rotateMatrix;</span><br><span class=\"line\">    <span class=\"built_in\">gl_Position</span> = vPos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意，如果想要获取shader里面的变量，必须要在glLinkProgram后面！</p>\n</blockquote>\n<p>在开始绘制步骤中 设置纹理采样器<code>glUniform1i</code> 和 开始绘制<code>glDrawArrays</code>之间将旋转矩阵传入顶点着色器。</p>\n<p><strong>设置旋转矩阵，旋转纹理</strong></p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设置旋转矩阵</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)rotateTexture &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取shader中的 rotateMatrix 变量</span></span><br><span class=\"line\">    GLuint <span class=\"built_in\">rotate</span> = glGetUniformLocation(self.program, <span class=\"string\">&quot;rotateMatrix&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置旋转弧度</span></span><br><span class=\"line\">    <span class=\"built_in\">float</span> <span class=\"built_in\">radians</span> = <span class=\"number\">180</span> * <span class=\"number\">3.14159</span>f / <span class=\"number\">180.0</span>f;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//求弧度对于的sin/cos值</span></span><br><span class=\"line\">    <span class=\"built_in\">float</span> s = <span class=\"built_in\">sin</span>(<span class=\"built_in\">radians</span>);</span><br><span class=\"line\">    <span class=\"built_in\">float</span> c = <span class=\"built_in\">cos</span>(<span class=\"built_in\">radians</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//旋转矩阵</span></span><br><span class=\"line\">    GLfloat zRotation[<span class=\"number\">16</span>] = &#123;</span><br><span class=\"line\">        c,-s,<span class=\"number\">0</span>,<span class=\"number\">0</span>,</span><br><span class=\"line\">        s,c,<span class=\"number\">0</span>,<span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置旋转矩阵</span></span><br><span class=\"line\">    glUniformMatrix4fv(<span class=\"built_in\">rotate</span>, <span class=\"number\">1</span>, GL_FALSE, zRotation);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法二：使用CoreGraphics函数 对图片做翻转</p>\n<p>在 加载纹理函数 <code>- (GLuint)setupTexture:(NSString *)filePath</code> 中，解码图片后，翻转坐标，再次重新绘制一次</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"constructor\">CGContextDrawImage(<span class=\"params\">cgContext</span>, <span class=\"params\">rect</span>, <span class=\"params\">cgImage</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"constructor\">CGContextTranslateCTM(<span class=\"params\">cgContext</span>, <span class=\"params\">rect</span>.<span class=\"params\">origin</span>.<span class=\"params\">x</span>, <span class=\"params\">rect</span>.<span class=\"params\">origin</span>.<span class=\"params\">y</span>)</span>;</span><br><span class=\"line\"><span class=\"constructor\">CGContextTranslateCTM(<span class=\"params\">cgContext</span>, 0, <span class=\"params\">height</span>)</span>;</span><br><span class=\"line\"><span class=\"constructor\">CGContextScaleCTM(<span class=\"params\">cgContext</span>, 1.0, -1.0)</span>;</span><br><span class=\"line\"><span class=\"constructor\">CGContextTranslateCTM(<span class=\"params\">cgContext</span>, -<span class=\"params\">rect</span>.<span class=\"params\">origin</span>.<span class=\"params\">x</span>, -<span class=\"params\">rect</span>.<span class=\"params\">origin</span>.<span class=\"params\">y</span>)</span>;</span><br><span class=\"line\"><span class=\"constructor\">CGContextDrawImage(<span class=\"params\">cgContext</span>, <span class=\"params\">rect</span>, <span class=\"params\">cgImage</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"constructor\">CGContextRelease(<span class=\"params\">cgContext</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>方法三：修改片元着色器，对纹理坐标的y值进行翻转</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">precision</span> <span class=\"keyword\">highp</span> <span class=\"type\">float</span>;</span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"keyword\">lowp</span> <span class=\"type\">vec2</span> varyTextCoord;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> colorMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">lowp</span> <span class=\"type\">vec4</span> temp = <span class=\"built_in\">texture2D</span>(colorMap, <span class=\"type\">vec2</span>(varyTextCoord.x,<span class=\"number\">1.0</span>-varyTextCoord.y));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法四：修改顶点着色器中的纹理坐标，对y值进行翻转</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec4</span> position;</span><br><span class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec2</span> textCoordinate;</span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"keyword\">lowp</span> <span class=\"type\">vec2</span> varyTextCoord;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    varyTextCoord = <span class=\"type\">vec2</span>(textCoordinate.x,<span class=\"number\">1.0</span>-textCoordinate.y);;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">gl_Position</span> = position;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>方法五：直接修改顶点坐标 对应对纹理坐标</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat attrArr[] =</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        <span class=\"number\">0.5</span>f, -<span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,        <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"regexp\">//</span>右下</span><br><span class=\"line\">        -<span class=\"number\">0.5</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,        <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"regexp\">//</span> 左上</span><br><span class=\"line\">        -<span class=\"number\">0.5</span>f, -<span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,       <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"regexp\">//</span> 左下</span><br><span class=\"line\">        <span class=\"number\">0.5</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,         <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"regexp\">//</span> 右上</span><br><span class=\"line\">        -<span class=\"number\">0.5</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,        <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"regexp\">//</span> 左上</span><br><span class=\"line\">        <span class=\"number\">0.5</span>f, -<span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,        <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"regexp\">//</span> 右下</span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>推荐使用 方法二</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>由于<code>CoreGraphics</code>坐标系与<code>UIKit</code>坐标系不一致，导致<code>CoreGraphics</code>解码图片加载纹理后，图片显示倒置，下面介绍五种翻转纹理的方式。</p>\n<p>方式一：在顶点着色器中，给顶点坐标乘以一个旋转矩阵，之后再赋值给内建变量<code>gl_Position</code>。</p>\n<p>即顶点着色器代码改为</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec4</span> position;</span><br><span class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec2</span> textCoordinate;</span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"keyword\">lowp</span> <span class=\"type\">vec2</span> varyTextCoord;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">mat4</span> rotateMatrix;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    varyTextCoord = textCoordinate;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">vec4</span> vPos = position;</span><br><span class=\"line\">    vPos = vPos * rotateMatrix;</span><br><span class=\"line\">    <span class=\"built_in\">gl_Position</span> = vPos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意，如果想要获取shader里面的变量，必须要在glLinkProgram后面！</p>\n</blockquote>\n<p>在开始绘制步骤中 设置纹理采样器<code>glUniform1i</code> 和 开始绘制<code>glDrawArrays</code>之间将旋转矩阵传入顶点着色器。</p>\n<p><strong>设置旋转矩阵，旋转纹理</strong></p>\n<figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设置旋转矩阵</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)rotateTexture &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取shader中的 rotateMatrix 变量</span></span><br><span class=\"line\">    GLuint <span class=\"built_in\">rotate</span> = glGetUniformLocation(self.program, <span class=\"string\">&quot;rotateMatrix&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置旋转弧度</span></span><br><span class=\"line\">    <span class=\"built_in\">float</span> <span class=\"built_in\">radians</span> = <span class=\"number\">180</span> * <span class=\"number\">3.14159</span>f / <span class=\"number\">180.0</span>f;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//求弧度对于的sin/cos值</span></span><br><span class=\"line\">    <span class=\"built_in\">float</span> s = <span class=\"built_in\">sin</span>(<span class=\"built_in\">radians</span>);</span><br><span class=\"line\">    <span class=\"built_in\">float</span> c = <span class=\"built_in\">cos</span>(<span class=\"built_in\">radians</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//旋转矩阵</span></span><br><span class=\"line\">    GLfloat zRotation[<span class=\"number\">16</span>] = &#123;</span><br><span class=\"line\">        c,-s,<span class=\"number\">0</span>,<span class=\"number\">0</span>,</span><br><span class=\"line\">        s,c,<span class=\"number\">0</span>,<span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置旋转矩阵</span></span><br><span class=\"line\">    glUniformMatrix4fv(<span class=\"built_in\">rotate</span>, <span class=\"number\">1</span>, GL_FALSE, zRotation);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法二：使用CoreGraphics函数 对图片做翻转</p>\n<p>在 加载纹理函数 <code>- (GLuint)setupTexture:(NSString *)filePath</code> 中，解码图片后，翻转坐标，再次重新绘制一次</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"constructor\">CGContextDrawImage(<span class=\"params\">cgContext</span>, <span class=\"params\">rect</span>, <span class=\"params\">cgImage</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"constructor\">CGContextTranslateCTM(<span class=\"params\">cgContext</span>, <span class=\"params\">rect</span>.<span class=\"params\">origin</span>.<span class=\"params\">x</span>, <span class=\"params\">rect</span>.<span class=\"params\">origin</span>.<span class=\"params\">y</span>)</span>;</span><br><span class=\"line\"><span class=\"constructor\">CGContextTranslateCTM(<span class=\"params\">cgContext</span>, 0, <span class=\"params\">height</span>)</span>;</span><br><span class=\"line\"><span class=\"constructor\">CGContextScaleCTM(<span class=\"params\">cgContext</span>, 1.0, -1.0)</span>;</span><br><span class=\"line\"><span class=\"constructor\">CGContextTranslateCTM(<span class=\"params\">cgContext</span>, -<span class=\"params\">rect</span>.<span class=\"params\">origin</span>.<span class=\"params\">x</span>, -<span class=\"params\">rect</span>.<span class=\"params\">origin</span>.<span class=\"params\">y</span>)</span>;</span><br><span class=\"line\"><span class=\"constructor\">CGContextDrawImage(<span class=\"params\">cgContext</span>, <span class=\"params\">rect</span>, <span class=\"params\">cgImage</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"constructor\">CGContextRelease(<span class=\"params\">cgContext</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>方法三：修改片元着色器，对纹理坐标的y值进行翻转</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">precision</span> <span class=\"keyword\">highp</span> <span class=\"type\">float</span>;</span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"keyword\">lowp</span> <span class=\"type\">vec2</span> varyTextCoord;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> colorMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">lowp</span> <span class=\"type\">vec4</span> temp = <span class=\"built_in\">texture2D</span>(colorMap, <span class=\"type\">vec2</span>(varyTextCoord.x,<span class=\"number\">1.0</span>-varyTextCoord.y));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">gl_FragColor</span> = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法四：修改顶点着色器中的纹理坐标，对y值进行翻转</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec4</span> position;</span><br><span class=\"line\"><span class=\"keyword\">attribute</span> <span class=\"type\">vec2</span> textCoordinate;</span><br><span class=\"line\"><span class=\"keyword\">varying</span> <span class=\"keyword\">lowp</span> <span class=\"type\">vec2</span> varyTextCoord;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main() &#123;</span><br><span class=\"line\">    varyTextCoord = <span class=\"type\">vec2</span>(textCoordinate.x,<span class=\"number\">1.0</span>-textCoordinate.y);;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">gl_Position</span> = position;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>方法五：直接修改顶点坐标 对应对纹理坐标</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLfloat attrArr[] =</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        <span class=\"number\">0.5</span>f, -<span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,        <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"regexp\">//</span>右下</span><br><span class=\"line\">        -<span class=\"number\">0.5</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,        <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"regexp\">//</span> 左上</span><br><span class=\"line\">        -<span class=\"number\">0.5</span>f, -<span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,       <span class=\"number\">0.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"regexp\">//</span> 左下</span><br><span class=\"line\">        <span class=\"number\">0.5</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,         <span class=\"number\">1.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"regexp\">//</span> 右上</span><br><span class=\"line\">        -<span class=\"number\">0.5</span>f, <span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,        <span class=\"number\">0.0</span>f, <span class=\"number\">0.0</span>f, <span class=\"regexp\">//</span> 左上</span><br><span class=\"line\">        <span class=\"number\">0.5</span>f, -<span class=\"number\">0.5</span>f, <span class=\"number\">0.0</span>f,        <span class=\"number\">1.0</span>f, <span class=\"number\">1.0</span>f, <span class=\"regexp\">//</span> 右下</span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>推荐使用 方法二</p>\n</blockquote>\n"},{"title":"iOS alloc原理分析","date":"2020-09-05T16:00:00.000Z","_content":"\n首先自定义类`LSPerson`继承自`NSObject`\n\n```\n创建LSPerson对象\nLSPerson *p1 = [LSPerson alloc];\n```\n\n断点在该行，`control` + `step into`进入断点即可看到调用`objc_alloc函数`，在[ojbc源码]([https://opensource.apple.com/tarballs/](https://opensource.apple.com/tarballs/)\n)中源码如下\n\n```\ncallAlloc源码\n// Call [cls alloc] or [cls allocWithZone:nil], with appropriate \n// shortcutting optimizations.\nstatic ALWAYS_INLINE id\ncallAlloc(Class cls, bool checkNil, bool allocWithZone=false)\n{\n#if __OBJC2__\n    if (slowpath(checkNil && !cls)) return nil;\n    if (fastpath(!cls->ISA()->hasCustomAWZ())) {\n        return _objc_rootAllocWithZone(cls, nil);\n    }\n#endif\n\n    // No shortcuts available.\n    if (allocWithZone) {\n        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);\n    }\n    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));\n}\n```\n\n分析alloc流程如下：\n\n![alloc流程](https://upload-images.jianshu.io/upload_images/1395687-66f1fbc4ee92add4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其中`slowpath`和`fastpath`为宏定义，`__builtin_expect`用于编译器对代码优化，减少指令跳转。这个指令是gcc引入的，作用是\"允许程序员将最有可能执行的分支告诉编译器\"\n```\n#define fastpath(x) (__builtin_expect(bool(x), 1))\n#define slowpath(x) (__builtin_expect(bool(x), 0))\n```  \n\n`!cls->ISA()->hasCustomAWZ()`判断该类是否有自定义的`allocWithZone`实现\n\n1. instanceSize源码\n```\nsize_t instanceSize(size_t extraBytes) const {\n        if (fastpath(cache.hasFastInstanceSize(extraBytes))) {\n            return cache.fastInstanceSize(extraBytes);\n        }\n\n        size_t size = alignedInstanceSize() + extraBytes;\n        // CF requires all objects be at least 16 bytes.\n        if (size < 16) size = 16;\n        return size;\n    }\n```\n根据调试信息从缓存中读取所需开辟空间大小`cache.fastInstanceSize`\n\nfastInstanceSize源码\n```\nsize_t fastInstanceSize(size_t extra) const\n    {\n        ASSERT(hasFastInstanceSize(extra));\n\n        if (__builtin_constant_p(extra) && extra == 0) {\n            return _flags & FAST_CACHE_ALLOC_MASK16;\n        } else {\n            size_t size = _flags & FAST_CACHE_ALLOC_MASK;\n            // remove the FAST_CACHE_ALLOC_DELTA16 that was added\n            // by setFastInstanceSize\n            return align16(size + extra - FAST_CACHE_ALLOC_DELTA16);\n        }\n    }\n```\n`__builtin_constant_p(exp)`用于在编译器判断exp是否为常量，如果是则函数的值为1，否则为0。此处exp为非常量\n\nalign16源码\n```\nstatic inline size_t align16(size_t x) {\n    return (x + size_t(15)) & ~size_t(15);\n}\n```\nalign16函数对变量x进行内存对齐，计算后为16的倍数，该算法是对x的二进制的后四位进行清零运算\n\n![字节对齐算法示意图](https://upload-images.jianshu.io/upload_images/1395687-d42f8abca7382024.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2. `calloc` 返回开辟内存的地址指针\n\n3. `initInstanceIsa`源码  做了一件事即初始化isa `initIsa`\n```\ninline void \nobjc_object::initInstanceIsa(Class cls, bool hasCxxDtor)\n{\n    ASSERT(!cls->instancesRequireRawIsa());\n    ASSERT(hasCxxDtor == cls->hasCxxDtor());\n\n    initIsa(cls, true, hasCxxDtor);\n}\n```\n\n`initIsa`源码\n```\ninline void \nobjc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) \n{ \n    ASSERT(!isTaggedPointer()); \n    \n    if (!nonpointer) {\n        isa = isa_t((uintptr_t)cls);\n    } else {\n        ASSERT(!DisableNonpointerIsa);\n        ASSERT(!cls->instancesRequireRawIsa());\n\n        isa_t newisa(0);\n\n#if SUPPORT_INDEXED_ISA\n        ASSERT(cls->classArrayIndex() > 0);\n        newisa.bits = ISA_INDEX_MAGIC_VALUE;\n        // isa.magic is part of ISA_MAGIC_VALUE\n        // isa.nonpointer is part of ISA_MAGIC_VALUE\n        newisa.has_cxx_dtor = hasCxxDtor;\n        newisa.indexcls = (uintptr_t)cls->classArrayIndex();\n#else\n        newisa.bits = ISA_MAGIC_VALUE;\n        // isa.magic is part of ISA_MAGIC_VALUE\n        // isa.nonpointer is part of ISA_MAGIC_VALUE\n        newisa.has_cxx_dtor = hasCxxDtor;\n        newisa.shiftcls = (uintptr_t)cls >> 3;\n#endif\n\n        // This write must be performed in a single store in some cases\n        // (for example when realizing a class because other threads\n        // may simultaneously try to use the class).\n        // fixme use atomics here to guarantee single-store and to\n        // guarantee memory order w.r.t. the class index table\n        // ...but not too atomic because we don't want to hurt instantiation\n        isa = newisa;\n    }\n}\n```\n自定义类非taggedPointer，且nonpointer为true，走到else分支，初始化`isa_t newisa`结构体","source":"_posts/2020-09-06-iOS alloc原理.md","raw":"---\ntitle:      \"iOS alloc原理分析\" \ndate:       2020-09-06\ntags:\n    - iOS底层原理\ncategories:\n    - iOS底层原理\n---\n\n首先自定义类`LSPerson`继承自`NSObject`\n\n```\n创建LSPerson对象\nLSPerson *p1 = [LSPerson alloc];\n```\n\n断点在该行，`control` + `step into`进入断点即可看到调用`objc_alloc函数`，在[ojbc源码]([https://opensource.apple.com/tarballs/](https://opensource.apple.com/tarballs/)\n)中源码如下\n\n```\ncallAlloc源码\n// Call [cls alloc] or [cls allocWithZone:nil], with appropriate \n// shortcutting optimizations.\nstatic ALWAYS_INLINE id\ncallAlloc(Class cls, bool checkNil, bool allocWithZone=false)\n{\n#if __OBJC2__\n    if (slowpath(checkNil && !cls)) return nil;\n    if (fastpath(!cls->ISA()->hasCustomAWZ())) {\n        return _objc_rootAllocWithZone(cls, nil);\n    }\n#endif\n\n    // No shortcuts available.\n    if (allocWithZone) {\n        return ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, @selector(allocWithZone:), nil);\n    }\n    return ((id(*)(id, SEL))objc_msgSend)(cls, @selector(alloc));\n}\n```\n\n分析alloc流程如下：\n\n![alloc流程](https://upload-images.jianshu.io/upload_images/1395687-66f1fbc4ee92add4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其中`slowpath`和`fastpath`为宏定义，`__builtin_expect`用于编译器对代码优化，减少指令跳转。这个指令是gcc引入的，作用是\"允许程序员将最有可能执行的分支告诉编译器\"\n```\n#define fastpath(x) (__builtin_expect(bool(x), 1))\n#define slowpath(x) (__builtin_expect(bool(x), 0))\n```  \n\n`!cls->ISA()->hasCustomAWZ()`判断该类是否有自定义的`allocWithZone`实现\n\n1. instanceSize源码\n```\nsize_t instanceSize(size_t extraBytes) const {\n        if (fastpath(cache.hasFastInstanceSize(extraBytes))) {\n            return cache.fastInstanceSize(extraBytes);\n        }\n\n        size_t size = alignedInstanceSize() + extraBytes;\n        // CF requires all objects be at least 16 bytes.\n        if (size < 16) size = 16;\n        return size;\n    }\n```\n根据调试信息从缓存中读取所需开辟空间大小`cache.fastInstanceSize`\n\nfastInstanceSize源码\n```\nsize_t fastInstanceSize(size_t extra) const\n    {\n        ASSERT(hasFastInstanceSize(extra));\n\n        if (__builtin_constant_p(extra) && extra == 0) {\n            return _flags & FAST_CACHE_ALLOC_MASK16;\n        } else {\n            size_t size = _flags & FAST_CACHE_ALLOC_MASK;\n            // remove the FAST_CACHE_ALLOC_DELTA16 that was added\n            // by setFastInstanceSize\n            return align16(size + extra - FAST_CACHE_ALLOC_DELTA16);\n        }\n    }\n```\n`__builtin_constant_p(exp)`用于在编译器判断exp是否为常量，如果是则函数的值为1，否则为0。此处exp为非常量\n\nalign16源码\n```\nstatic inline size_t align16(size_t x) {\n    return (x + size_t(15)) & ~size_t(15);\n}\n```\nalign16函数对变量x进行内存对齐，计算后为16的倍数，该算法是对x的二进制的后四位进行清零运算\n\n![字节对齐算法示意图](https://upload-images.jianshu.io/upload_images/1395687-d42f8abca7382024.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2. `calloc` 返回开辟内存的地址指针\n\n3. `initInstanceIsa`源码  做了一件事即初始化isa `initIsa`\n```\ninline void \nobjc_object::initInstanceIsa(Class cls, bool hasCxxDtor)\n{\n    ASSERT(!cls->instancesRequireRawIsa());\n    ASSERT(hasCxxDtor == cls->hasCxxDtor());\n\n    initIsa(cls, true, hasCxxDtor);\n}\n```\n\n`initIsa`源码\n```\ninline void \nobjc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) \n{ \n    ASSERT(!isTaggedPointer()); \n    \n    if (!nonpointer) {\n        isa = isa_t((uintptr_t)cls);\n    } else {\n        ASSERT(!DisableNonpointerIsa);\n        ASSERT(!cls->instancesRequireRawIsa());\n\n        isa_t newisa(0);\n\n#if SUPPORT_INDEXED_ISA\n        ASSERT(cls->classArrayIndex() > 0);\n        newisa.bits = ISA_INDEX_MAGIC_VALUE;\n        // isa.magic is part of ISA_MAGIC_VALUE\n        // isa.nonpointer is part of ISA_MAGIC_VALUE\n        newisa.has_cxx_dtor = hasCxxDtor;\n        newisa.indexcls = (uintptr_t)cls->classArrayIndex();\n#else\n        newisa.bits = ISA_MAGIC_VALUE;\n        // isa.magic is part of ISA_MAGIC_VALUE\n        // isa.nonpointer is part of ISA_MAGIC_VALUE\n        newisa.has_cxx_dtor = hasCxxDtor;\n        newisa.shiftcls = (uintptr_t)cls >> 3;\n#endif\n\n        // This write must be performed in a single store in some cases\n        // (for example when realizing a class because other threads\n        // may simultaneously try to use the class).\n        // fixme use atomics here to guarantee single-store and to\n        // guarantee memory order w.r.t. the class index table\n        // ...but not too atomic because we don't want to hurt instantiation\n        isa = newisa;\n    }\n}\n```\n自定义类非taggedPointer，且nonpointer为true，走到else分支，初始化`isa_t newisa`结构体","slug":"2020-09-06-iOS alloc原理","published":1,"updated":"2021-06-19T03:46:24.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbpu001ebjrj3hxu9lrt","content":"<p>首先自定义类<code>LSPerson</code>继承自<code>NSObject</code></p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建LSPerson对象</span><br><span class=\"line\">LSPerson *p1 = [LSPerson alloc]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>断点在该行，<code>control</code> + <code>step into</code>进入断点即可看到调用<code>objc_alloc函数</code>，在<a href=\"%5Bhttps://opensource.apple.com/tarballs/%5D(https://opensource.apple.com/tarballs/)\">ojbc源码</a>中源码如下</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">callAlloc</span>源码</span><br><span class=\"line\"><span class=\"comment\">// Call [cls alloc] or [cls allocWithZone:nil], with appropriate </span></span><br><span class=\"line\"><span class=\"comment\">// shortcutting optimizations.</span></span><br><span class=\"line\"><span class=\"selector-tag\">static</span> <span class=\"selector-tag\">ALWAYS_INLINE</span> <span class=\"selector-tag\">id</span></span><br><span class=\"line\"><span class=\"selector-tag\">callAlloc</span>(Class cls, bool checkNil, bool allocWithZone=false)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"selector-id\">#if</span> <span class=\"selector-tag\">__OBJC2__</span></span><br><span class=\"line\">    <span class=\"selector-tag\">if</span> (slowpath(checkNil &amp;&amp; !cls)) <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">nil</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">if</span> (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">_objc_rootAllocWithZone</span>(cls, nil);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"selector-id\">#endif</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// No shortcuts available.</span></span><br><span class=\"line\">    <span class=\"selector-tag\">if</span> (allocWithZone) &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, <span class=\"variable\">@selector</span>(<span class=\"attribute\">allocWithZone</span>:), nil);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">return</span> ((id(*)(id, SEL))objc_msgSend)(cls, <span class=\"variable\">@selector</span>(alloc));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>分析alloc流程如下：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-66f1fbc4ee92add4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"alloc流程\"></p>\n<p>其中<code>slowpath</code>和<code>fastpath</code>为宏定义，<code>__builtin_expect</code>用于编译器对代码优化，减少指令跳转。这个指令是gcc引入的，作用是”允许程序员将最有可能执行的分支告诉编译器”</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#define</span> <span class=\"selector-tag\">fastpath</span>(x) (__builtin_expect(bool(x), <span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"selector-id\">#define</span> <span class=\"selector-tag\">slowpath</span>(x) (__builtin_expect(bool(x), <span class=\"number\">0</span>))</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">`!<span class=\"selector-tag\">cls-</span>&gt;<span class=\"selector-tag\">ISA</span>()<span class=\"selector-tag\">-</span>&gt;<span class=\"selector-tag\">hasCustomAWZ</span>()`判断该类是否有自定义的`<span class=\"selector-tag\">allocWithZone</span>`实现</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">1</span>. <span class=\"selector-tag\">instanceSize</span>源码</span><br></pre></td></tr></table></figure>\n<p>size_t instanceSize(size_t extraBytes) const {<br>        if (fastpath(cache.hasFastInstanceSize(extraBytes))) {<br>            return cache.fastInstanceSize(extraBytes);<br>        }</p>\n<pre><code>    size_t size = alignedInstanceSize() + extraBytes;\n    // CF requires all objects be at least 16 bytes.\n    if (size &lt; 16) size = 16;\n    return size;\n&#125;\n</code></pre>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">根据调试信息从缓存中读取所需开辟空间大小`cache.fastInstanceSize`</span><br><span class=\"line\"></span><br><span class=\"line\">fastInstanceSize源码</span><br></pre></td></tr></table></figure>\n<p>size_t fastInstanceSize(size_t extra) const<br>    {<br>        ASSERT(hasFastInstanceSize(extra));</p>\n<pre><code>    if (__builtin_constant_p(extra) &amp;&amp; extra == 0) &#123;\n        return _flags &amp; FAST_CACHE_ALLOC_MASK16;\n    &#125; else &#123;\n        size_t size = _flags &amp; FAST_CACHE_ALLOC_MASK;\n        // remove the FAST_CACHE_ALLOC_DELTA16 that was added\n        // by setFastInstanceSize\n        return align16(size + extra - FAST_CACHE_ALLOC_DELTA16);\n    &#125;\n&#125;\n</code></pre>\n<figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`<span class=\"variable\">__builtin_constant_p</span>(<span class=\"built_in\">exp</span>)`用于在编译器判断<span class=\"built_in\">exp</span>是否为常量，如果是则函数的值为<span class=\"number\">1</span>，否则为<span class=\"number\">0</span>。此处<span class=\"built_in\">exp</span>为非常量</span><br><span class=\"line\"></span><br><span class=\"line\">align16源码</span><br></pre></td></tr></table></figure>\n<p>static inline size_t align16(size_t x) {<br>    return (x + size_t(15)) &amp; ~size_t(15);<br>}</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">align16函数对变量x进行内存对齐，计算后为<span class=\"number\">16</span>的倍数，该算法是对x的二进制的后四位进行清零运算</span><br><span class=\"line\"></span><br><span class=\"line\">![字节对齐算法示意图](https:<span class=\"regexp\">//u</span>pload-images.jianshu.io<span class=\"regexp\">/upload_images/</span><span class=\"number\">1395687</span>-d42f8abca7382024.png?imageMogr2<span class=\"regexp\">/auto-orient/</span>strip%<span class=\"number\">7</span>CimageView2<span class=\"regexp\">/2/</span>w/<span class=\"number\">1240</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span>. `calloc` 返回开辟内存的地址指针</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3</span>. `initInstanceIsa`源码  做了一件事即初始化isa `initIsa`</span><br></pre></td></tr></table></figure>\n<p>inline void<br>objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)<br>{<br>    ASSERT(!cls-&gt;instancesRequireRawIsa());<br>    ASSERT(hasCxxDtor == cls-&gt;hasCxxDtor());</p>\n<pre><code>initIsa(cls, true, hasCxxDtor);\n</code></pre>\n<p>}</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">`initIsa`源码</span><br></pre></td></tr></table></figure>\n<p>inline void<br>objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor)<br>{<br>    ASSERT(!isTaggedPointer()); </p>\n<pre><code>if (!nonpointer) &#123;\n    isa = isa_t((uintptr_t)cls);\n&#125; else &#123;\n    ASSERT(!DisableNonpointerIsa);\n    ASSERT(!cls-&gt;instancesRequireRawIsa());\n\n    isa_t newisa(0);\n</code></pre>\n<p>#if SUPPORT_INDEXED_ISA<br>        ASSERT(cls-&gt;classArrayIndex() &gt; 0);<br>        newisa.bits = ISA_INDEX_MAGIC_VALUE;<br>        // isa.magic is part of ISA_MAGIC_VALUE<br>        // isa.nonpointer is part of ISA_MAGIC_VALUE<br>        newisa.has_cxx_dtor = hasCxxDtor;<br>        newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();<br>#else<br>        newisa.bits = ISA_MAGIC_VALUE;<br>        // isa.magic is part of ISA_MAGIC_VALUE<br>        // isa.nonpointer is part of ISA_MAGIC_VALUE<br>        newisa.has_cxx_dtor = hasCxxDtor;<br>        newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;<br>#endif</p>\n<pre><code>    // This write must be performed in a single store in some cases\n    // (for example when realizing a class because other threads\n    // may simultaneously try to use the class).\n    // fixme use atomics here to guarantee single-store and to\n    // guarantee memory order w.r.t. the class index table\n    // ...but not too atomic because we don&#39;t want to hurt instantiation\n    isa = newisa;\n&#125;\n</code></pre>\n<p>}</p>\n<p>```<br>自定义类非taggedPointer，且nonpointer为true，走到else分支，初始化<code>isa_t newisa</code>结构体</p>\n","site":{"data":{}},"excerpt":"","more":"<p>首先自定义类<code>LSPerson</code>继承自<code>NSObject</code></p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">创建LSPerson对象</span><br><span class=\"line\">LSPerson *p1 = [LSPerson alloc]<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>断点在该行，<code>control</code> + <code>step into</code>进入断点即可看到调用<code>objc_alloc函数</code>，在<a href=\"%5Bhttps://opensource.apple.com/tarballs/%5D(https://opensource.apple.com/tarballs/)\">ojbc源码</a>中源码如下</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">callAlloc</span>源码</span><br><span class=\"line\"><span class=\"comment\">// Call [cls alloc] or [cls allocWithZone:nil], with appropriate </span></span><br><span class=\"line\"><span class=\"comment\">// shortcutting optimizations.</span></span><br><span class=\"line\"><span class=\"selector-tag\">static</span> <span class=\"selector-tag\">ALWAYS_INLINE</span> <span class=\"selector-tag\">id</span></span><br><span class=\"line\"><span class=\"selector-tag\">callAlloc</span>(Class cls, bool checkNil, bool allocWithZone=false)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"selector-id\">#if</span> <span class=\"selector-tag\">__OBJC2__</span></span><br><span class=\"line\">    <span class=\"selector-tag\">if</span> (slowpath(checkNil &amp;&amp; !cls)) <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">nil</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">if</span> (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">_objc_rootAllocWithZone</span>(cls, nil);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"selector-id\">#endif</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// No shortcuts available.</span></span><br><span class=\"line\">    <span class=\"selector-tag\">if</span> (allocWithZone) &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> ((id(*)(id, SEL, struct _NSZone *))objc_msgSend)(cls, <span class=\"variable\">@selector</span>(<span class=\"attribute\">allocWithZone</span>:), nil);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">return</span> ((id(*)(id, SEL))objc_msgSend)(cls, <span class=\"variable\">@selector</span>(alloc));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>分析alloc流程如下：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-66f1fbc4ee92add4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"alloc流程\"></p>\n<p>其中<code>slowpath</code>和<code>fastpath</code>为宏定义，<code>__builtin_expect</code>用于编译器对代码优化，减少指令跳转。这个指令是gcc引入的，作用是”允许程序员将最有可能执行的分支告诉编译器”</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#define</span> <span class=\"selector-tag\">fastpath</span>(x) (__builtin_expect(bool(x), <span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"selector-id\">#define</span> <span class=\"selector-tag\">slowpath</span>(x) (__builtin_expect(bool(x), <span class=\"number\">0</span>))</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">`!<span class=\"selector-tag\">cls-</span>&gt;<span class=\"selector-tag\">ISA</span>()<span class=\"selector-tag\">-</span>&gt;<span class=\"selector-tag\">hasCustomAWZ</span>()`判断该类是否有自定义的`<span class=\"selector-tag\">allocWithZone</span>`实现</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">1</span>. <span class=\"selector-tag\">instanceSize</span>源码</span><br></pre></td></tr></table></figure>\n<p>size_t instanceSize(size_t extraBytes) const {<br>        if (fastpath(cache.hasFastInstanceSize(extraBytes))) {<br>            return cache.fastInstanceSize(extraBytes);<br>        }</p>\n<pre><code>    size_t size = alignedInstanceSize() + extraBytes;\n    // CF requires all objects be at least 16 bytes.\n    if (size &lt; 16) size = 16;\n    return size;\n&#125;\n</code></pre>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">根据调试信息从缓存中读取所需开辟空间大小`cache.fastInstanceSize`</span><br><span class=\"line\"></span><br><span class=\"line\">fastInstanceSize源码</span><br></pre></td></tr></table></figure>\n<p>size_t fastInstanceSize(size_t extra) const<br>    {<br>        ASSERT(hasFastInstanceSize(extra));</p>\n<pre><code>    if (__builtin_constant_p(extra) &amp;&amp; extra == 0) &#123;\n        return _flags &amp; FAST_CACHE_ALLOC_MASK16;\n    &#125; else &#123;\n        size_t size = _flags &amp; FAST_CACHE_ALLOC_MASK;\n        // remove the FAST_CACHE_ALLOC_DELTA16 that was added\n        // by setFastInstanceSize\n        return align16(size + extra - FAST_CACHE_ALLOC_DELTA16);\n    &#125;\n&#125;\n</code></pre>\n<figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">`<span class=\"variable\">__builtin_constant_p</span>(<span class=\"built_in\">exp</span>)`用于在编译器判断<span class=\"built_in\">exp</span>是否为常量，如果是则函数的值为<span class=\"number\">1</span>，否则为<span class=\"number\">0</span>。此处<span class=\"built_in\">exp</span>为非常量</span><br><span class=\"line\"></span><br><span class=\"line\">align16源码</span><br></pre></td></tr></table></figure>\n<p>static inline size_t align16(size_t x) {<br>    return (x + size_t(15)) &amp; ~size_t(15);<br>}</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">align16函数对变量x进行内存对齐，计算后为<span class=\"number\">16</span>的倍数，该算法是对x的二进制的后四位进行清零运算</span><br><span class=\"line\"></span><br><span class=\"line\">![字节对齐算法示意图](https:<span class=\"regexp\">//u</span>pload-images.jianshu.io<span class=\"regexp\">/upload_images/</span><span class=\"number\">1395687</span>-d42f8abca7382024.png?imageMogr2<span class=\"regexp\">/auto-orient/</span>strip%<span class=\"number\">7</span>CimageView2<span class=\"regexp\">/2/</span>w/<span class=\"number\">1240</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span>. `calloc` 返回开辟内存的地址指针</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3</span>. `initInstanceIsa`源码  做了一件事即初始化isa `initIsa`</span><br></pre></td></tr></table></figure>\n<p>inline void<br>objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)<br>{<br>    ASSERT(!cls-&gt;instancesRequireRawIsa());<br>    ASSERT(hasCxxDtor == cls-&gt;hasCxxDtor());</p>\n<pre><code>initIsa(cls, true, hasCxxDtor);\n</code></pre>\n<p>}</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">`initIsa`源码</span><br></pre></td></tr></table></figure>\n<p>inline void<br>objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor)<br>{<br>    ASSERT(!isTaggedPointer()); </p>\n<pre><code>if (!nonpointer) &#123;\n    isa = isa_t((uintptr_t)cls);\n&#125; else &#123;\n    ASSERT(!DisableNonpointerIsa);\n    ASSERT(!cls-&gt;instancesRequireRawIsa());\n\n    isa_t newisa(0);\n</code></pre>\n<p>#if SUPPORT_INDEXED_ISA<br>        ASSERT(cls-&gt;classArrayIndex() &gt; 0);<br>        newisa.bits = ISA_INDEX_MAGIC_VALUE;<br>        // isa.magic is part of ISA_MAGIC_VALUE<br>        // isa.nonpointer is part of ISA_MAGIC_VALUE<br>        newisa.has_cxx_dtor = hasCxxDtor;<br>        newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();<br>#else<br>        newisa.bits = ISA_MAGIC_VALUE;<br>        // isa.magic is part of ISA_MAGIC_VALUE<br>        // isa.nonpointer is part of ISA_MAGIC_VALUE<br>        newisa.has_cxx_dtor = hasCxxDtor;<br>        newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;<br>#endif</p>\n<pre><code>    // This write must be performed in a single store in some cases\n    // (for example when realizing a class because other threads\n    // may simultaneously try to use the class).\n    // fixme use atomics here to guarantee single-store and to\n    // guarantee memory order w.r.t. the class index table\n    // ...but not too atomic because we don&#39;t want to hurt instantiation\n    isa = newisa;\n&#125;\n</code></pre>\n<p>}</p>\n<p>```<br>自定义类非taggedPointer，且nonpointer为true，走到else分支，初始化<code>isa_t newisa</code>结构体</p>\n"},{"title":"isa结构解析","date":"2020-09-09T16:00:00.000Z","_content":"\n#### 1. isa初始化\n在 [iOS alloc原理分析]([https://www.jianshu.com/p/d4091f8a703a](https://www.jianshu.com/p/d4091f8a703a)\n) 中会 `initInstanceIsa`中初始化isa，源码如下：\n```\ninline void \nobjc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) \n{ \n    ASSERT(!isTaggedPointer()); \n    \n    if (!nonpointer) {\n        isa = isa_t((uintptr_t)cls);\n    } else {\n        ASSERT(!DisableNonpointerIsa);\n        ASSERT(!cls->instancesRequireRawIsa());\n\n        isa_t newisa(0);\n\n#if SUPPORT_INDEXED_ISA\n        ASSERT(cls->classArrayIndex() > 0);\n        newisa.bits = ISA_INDEX_MAGIC_VALUE;\n        // isa.magic is part of ISA_MAGIC_VALUE\n        // isa.nonpointer is part of ISA_MAGIC_VALUE\n        newisa.has_cxx_dtor = hasCxxDtor;\n        newisa.indexcls = (uintptr_t)cls->classArrayIndex();\n#else\n        newisa.bits = ISA_MAGIC_VALUE;\n        // isa.magic is part of ISA_MAGIC_VALUE\n        // isa.nonpointer is part of ISA_MAGIC_VALUE\n        newisa.has_cxx_dtor = hasCxxDtor;\n        newisa.shiftcls = (uintptr_t)cls >> 3;\n#endif\n\n        // This write must be performed in a single store in some cases\n        // (for example when realizing a class because other threads\n        // may simultaneously try to use the class).\n        // fixme use atomics here to guarantee single-store and to\n        // guarantee memory order w.r.t. the class index table\n        // ...but not too atomic because we don't want to hurt instantiation\n        isa = newisa;\n    }\n}\n```  \n分析：  \n如果没有开启指针优化，则直接将类赋值给isa指针，即isa直接指向该类，`isa = isa_t((uintptr_t)cls);`。  \n如果开启指针优化，则以另一种形式初始化isa指针。\n\n#### 2. isa结构\n根据源码可知isa类型为`isa_t`联合体类型，源码如下：  \n```  \nunion isa_t {\n    isa_t() { }\n    isa_t(uintptr_t value) : bits(value) { }\n\n    Class cls;\n    uintptr_t bits;\n#if defined(ISA_BITFIELD)\n    struct {\n        ISA_BITFIELD;  // defined in isa.h\n    };\n#endif\n};\n\n# if __arm64__\n#   define ISA_MASK        0x0000000ffffffff8ULL\n#   define ISA_MAGIC_MASK  0x000003f000000001ULL\n#   define ISA_MAGIC_VALUE 0x000001a000000001ULL\n#   define ISA_BITFIELD                                                      \\\n      uintptr_t nonpointer        : 1;                                       \\\n      uintptr_t has_assoc         : 1;                                       \\\n      uintptr_t has_cxx_dtor      : 1;                                       \\\n      uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\\n      uintptr_t magic             : 6;                                       \\\n      uintptr_t weakly_referenced : 1;                                       \\\n      uintptr_t deallocating      : 1;                                       \\\n      uintptr_t has_sidetable_rc  : 1;                                       \\\n      uintptr_t extra_rc          : 19\n```\n> 联合体：又名共用体，可以包含多个不同类型的成员。结构体和联合体的区别在于结构体的各个成员会占据不同的内存，而联合体的成员共用一块内存，各个成员的首地址相同。\n\n所以在`isa_t`联合体中`Class cls`和`uintptr_t bits`是互斥的。\n由 `typedef unsigned long           uintptr_t;` 所知，bits占据8字节，共64位，64位中存储的即`ISA_BITFIELD`宏定义中的内容。\n\n`uintptr_t nonpointer        : 1;  ` 是否对isa指针开启优化。0:纯isa指针 1:不只类对象地址，还包括了类信息，对象对引用计数等。\n`uintptr_t has_assoc        : 1;  ` 关联对象标识位 0:没有 1:存在。\n`uintptr_t has_cxx_dtor    : 1;  ` 是否有c++或objc的析构函数 如果有则需要调用析构逻辑，如果没有则可以更快释放对象。\n`uintptr_t shiftcls          : 33;  ` 存储类指针的值，开启指针优化时，有33位用来存放类指针。\n` uintptr_t magic             : 6;   ` 用于调试器判断当前对象是真的对象还是未初始化的空间。\n`uintptr_t weakly_referenced : 1;  ` 标志对象是否被指向或曾经指向一个ARC的弱变量，没有弱引用的对象可以更快的释放。\n`uintptr_t deallocating      : 1; ` 标志对象是否正在释放内存。\n`uintptr_t has_sidetable_rc  : 1; ` 当引用计数大于10时，则需要借助该变量存储进位。\n`uintptr_t extra_rc          : 19 ` 表示该对象的引用计数减1，如果引用计数为10，则extra_rc为9，如果引用计数大于10，则需要借助has_sidetable_rc。\n\n#### 3. isa与类关联\n```\n- (Class)class {\n    return object_getClass(self);\n}\n```\n获取类对象，元类也是特殊的类对象\n\n```\nClass object_getClass(id obj)\n{\n    if (obj) return obj->getIsa();\n    else return Nil;\n}\n\ninline Class \nobjc_object::getIsa() \n{\n    if (fastpath(!isTaggedPointer())) return ISA();\n\n    extern objc_class OBJC_CLASS_$___NSUnrecognizedTaggedPointer;\n    uintptr_t slot, ptr = (uintptr_t)this;\n    Class cls;\n\n    slot = (ptr >> _OBJC_TAG_SLOT_SHIFT) & _OBJC_TAG_SLOT_MASK;\n    cls = objc_tag_classes[slot];\n    if (slowpath(cls == (Class)&OBJC_CLASS_$___NSUnrecognizedTaggedPointer)) {\n        slot = (ptr >> _OBJC_TAG_EXT_SLOT_SHIFT) & _OBJC_TAG_EXT_SLOT_MASK;\n        cls = objc_tag_ext_classes[slot];\n    }\n    return cls;\n}\n\ninline Class \nobjc_object::ISA() \n{\n    ASSERT(!isTaggedPointer()); \n#if SUPPORT_INDEXED_ISA\n    if (isa.nonpointer) {\n        uintptr_t slot = isa.indexcls;\n        return classForIndex((unsigned)slot);\n    }\n    return (Class)isa.bits;\n#else\n    return (Class)(isa.bits & ISA_MASK);\n#endif\n}\n```\n获取类对象，即获取isa的指向。非taggedPointer的isa，最终返回`return (Class)(isa.bits & ISA_MASK);`\n\n#### 4. 对象的本质\n```\n//main.m\n#import <Foundation/Foundation.h>\n#import \"LSPerson.h\"\n\nstruct Person {\n    char * name;\n};\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        LSPerson *p1 = [[LSPerson alloc] init]; \n    }\n    return 0;\n}\n```\n通过`clang -rewrite-objc main.m -o main.cpp`将以上文件转成c++文件 \n `NSObject`底层结构为\n```\nstruct NSObject_IMPL {\n\tClass isa;\n};\n```\nLSPerson底层结构为\n```\nstruct LSPerson_IMPL {\n\tstruct NSObject_IMPL NSObject_IVARS;\n};\n```\n因为LSPerson并没有其他成员变量，则直接继承自NSObject的结构体，所以继承自NSObject的对象都会有isa指针。\n\n属性的setter方法都会调用`objc_setProperty`函数\n```\nvoid objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy) \n{\n    bool copy = (shouldCopy && shouldCopy != MUTABLE_COPY);\n    bool mutableCopy = (shouldCopy == MUTABLE_COPY);\n    reallySetProperty(self, _cmd, newValue, offset, atomic, copy, mutableCopy);\n}\n\nstatic inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)\n{\n    if (offset == 0) {\n        object_setClass(self, newValue);\n        return;\n    }\n\n    id oldValue;\n    id *slot = (id*) ((char*)self + offset);\n\n    if (copy) {\n        newValue = [newValue copyWithZone:nil];\n    } else if (mutableCopy) {\n        newValue = [newValue mutableCopyWithZone:nil];\n    } else {\n        if (*slot == newValue) return;\n        newValue = objc_retain(newValue);\n    }\n\n    if (!atomic) {\n        oldValue = *slot;\n        *slot = newValue;\n    } else {\n        spinlock_t& slotlock = PropertyLocks[slot];\n        slotlock.lock();\n        oldValue = *slot;\n        *slot = newValue;        \n        slotlock.unlock();\n    }\n\n    objc_release(oldValue);\n}\n```\n总结为retain新值，release旧值。\n","source":"_posts/2020-09-10-isa结构解析.md","raw":"---\ntitle:      \"isa结构解析\" \ndate:       2020-09-10\ntags:\n    - iOS底层原理\ncategories:\n    - iOS底层原理\n---\n\n#### 1. isa初始化\n在 [iOS alloc原理分析]([https://www.jianshu.com/p/d4091f8a703a](https://www.jianshu.com/p/d4091f8a703a)\n) 中会 `initInstanceIsa`中初始化isa，源码如下：\n```\ninline void \nobjc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) \n{ \n    ASSERT(!isTaggedPointer()); \n    \n    if (!nonpointer) {\n        isa = isa_t((uintptr_t)cls);\n    } else {\n        ASSERT(!DisableNonpointerIsa);\n        ASSERT(!cls->instancesRequireRawIsa());\n\n        isa_t newisa(0);\n\n#if SUPPORT_INDEXED_ISA\n        ASSERT(cls->classArrayIndex() > 0);\n        newisa.bits = ISA_INDEX_MAGIC_VALUE;\n        // isa.magic is part of ISA_MAGIC_VALUE\n        // isa.nonpointer is part of ISA_MAGIC_VALUE\n        newisa.has_cxx_dtor = hasCxxDtor;\n        newisa.indexcls = (uintptr_t)cls->classArrayIndex();\n#else\n        newisa.bits = ISA_MAGIC_VALUE;\n        // isa.magic is part of ISA_MAGIC_VALUE\n        // isa.nonpointer is part of ISA_MAGIC_VALUE\n        newisa.has_cxx_dtor = hasCxxDtor;\n        newisa.shiftcls = (uintptr_t)cls >> 3;\n#endif\n\n        // This write must be performed in a single store in some cases\n        // (for example when realizing a class because other threads\n        // may simultaneously try to use the class).\n        // fixme use atomics here to guarantee single-store and to\n        // guarantee memory order w.r.t. the class index table\n        // ...but not too atomic because we don't want to hurt instantiation\n        isa = newisa;\n    }\n}\n```  \n分析：  \n如果没有开启指针优化，则直接将类赋值给isa指针，即isa直接指向该类，`isa = isa_t((uintptr_t)cls);`。  \n如果开启指针优化，则以另一种形式初始化isa指针。\n\n#### 2. isa结构\n根据源码可知isa类型为`isa_t`联合体类型，源码如下：  \n```  \nunion isa_t {\n    isa_t() { }\n    isa_t(uintptr_t value) : bits(value) { }\n\n    Class cls;\n    uintptr_t bits;\n#if defined(ISA_BITFIELD)\n    struct {\n        ISA_BITFIELD;  // defined in isa.h\n    };\n#endif\n};\n\n# if __arm64__\n#   define ISA_MASK        0x0000000ffffffff8ULL\n#   define ISA_MAGIC_MASK  0x000003f000000001ULL\n#   define ISA_MAGIC_VALUE 0x000001a000000001ULL\n#   define ISA_BITFIELD                                                      \\\n      uintptr_t nonpointer        : 1;                                       \\\n      uintptr_t has_assoc         : 1;                                       \\\n      uintptr_t has_cxx_dtor      : 1;                                       \\\n      uintptr_t shiftcls          : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\\n      uintptr_t magic             : 6;                                       \\\n      uintptr_t weakly_referenced : 1;                                       \\\n      uintptr_t deallocating      : 1;                                       \\\n      uintptr_t has_sidetable_rc  : 1;                                       \\\n      uintptr_t extra_rc          : 19\n```\n> 联合体：又名共用体，可以包含多个不同类型的成员。结构体和联合体的区别在于结构体的各个成员会占据不同的内存，而联合体的成员共用一块内存，各个成员的首地址相同。\n\n所以在`isa_t`联合体中`Class cls`和`uintptr_t bits`是互斥的。\n由 `typedef unsigned long           uintptr_t;` 所知，bits占据8字节，共64位，64位中存储的即`ISA_BITFIELD`宏定义中的内容。\n\n`uintptr_t nonpointer        : 1;  ` 是否对isa指针开启优化。0:纯isa指针 1:不只类对象地址，还包括了类信息，对象对引用计数等。\n`uintptr_t has_assoc        : 1;  ` 关联对象标识位 0:没有 1:存在。\n`uintptr_t has_cxx_dtor    : 1;  ` 是否有c++或objc的析构函数 如果有则需要调用析构逻辑，如果没有则可以更快释放对象。\n`uintptr_t shiftcls          : 33;  ` 存储类指针的值，开启指针优化时，有33位用来存放类指针。\n` uintptr_t magic             : 6;   ` 用于调试器判断当前对象是真的对象还是未初始化的空间。\n`uintptr_t weakly_referenced : 1;  ` 标志对象是否被指向或曾经指向一个ARC的弱变量，没有弱引用的对象可以更快的释放。\n`uintptr_t deallocating      : 1; ` 标志对象是否正在释放内存。\n`uintptr_t has_sidetable_rc  : 1; ` 当引用计数大于10时，则需要借助该变量存储进位。\n`uintptr_t extra_rc          : 19 ` 表示该对象的引用计数减1，如果引用计数为10，则extra_rc为9，如果引用计数大于10，则需要借助has_sidetable_rc。\n\n#### 3. isa与类关联\n```\n- (Class)class {\n    return object_getClass(self);\n}\n```\n获取类对象，元类也是特殊的类对象\n\n```\nClass object_getClass(id obj)\n{\n    if (obj) return obj->getIsa();\n    else return Nil;\n}\n\ninline Class \nobjc_object::getIsa() \n{\n    if (fastpath(!isTaggedPointer())) return ISA();\n\n    extern objc_class OBJC_CLASS_$___NSUnrecognizedTaggedPointer;\n    uintptr_t slot, ptr = (uintptr_t)this;\n    Class cls;\n\n    slot = (ptr >> _OBJC_TAG_SLOT_SHIFT) & _OBJC_TAG_SLOT_MASK;\n    cls = objc_tag_classes[slot];\n    if (slowpath(cls == (Class)&OBJC_CLASS_$___NSUnrecognizedTaggedPointer)) {\n        slot = (ptr >> _OBJC_TAG_EXT_SLOT_SHIFT) & _OBJC_TAG_EXT_SLOT_MASK;\n        cls = objc_tag_ext_classes[slot];\n    }\n    return cls;\n}\n\ninline Class \nobjc_object::ISA() \n{\n    ASSERT(!isTaggedPointer()); \n#if SUPPORT_INDEXED_ISA\n    if (isa.nonpointer) {\n        uintptr_t slot = isa.indexcls;\n        return classForIndex((unsigned)slot);\n    }\n    return (Class)isa.bits;\n#else\n    return (Class)(isa.bits & ISA_MASK);\n#endif\n}\n```\n获取类对象，即获取isa的指向。非taggedPointer的isa，最终返回`return (Class)(isa.bits & ISA_MASK);`\n\n#### 4. 对象的本质\n```\n//main.m\n#import <Foundation/Foundation.h>\n#import \"LSPerson.h\"\n\nstruct Person {\n    char * name;\n};\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        LSPerson *p1 = [[LSPerson alloc] init]; \n    }\n    return 0;\n}\n```\n通过`clang -rewrite-objc main.m -o main.cpp`将以上文件转成c++文件 \n `NSObject`底层结构为\n```\nstruct NSObject_IMPL {\n\tClass isa;\n};\n```\nLSPerson底层结构为\n```\nstruct LSPerson_IMPL {\n\tstruct NSObject_IMPL NSObject_IVARS;\n};\n```\n因为LSPerson并没有其他成员变量，则直接继承自NSObject的结构体，所以继承自NSObject的对象都会有isa指针。\n\n属性的setter方法都会调用`objc_setProperty`函数\n```\nvoid objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy) \n{\n    bool copy = (shouldCopy && shouldCopy != MUTABLE_COPY);\n    bool mutableCopy = (shouldCopy == MUTABLE_COPY);\n    reallySetProperty(self, _cmd, newValue, offset, atomic, copy, mutableCopy);\n}\n\nstatic inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)\n{\n    if (offset == 0) {\n        object_setClass(self, newValue);\n        return;\n    }\n\n    id oldValue;\n    id *slot = (id*) ((char*)self + offset);\n\n    if (copy) {\n        newValue = [newValue copyWithZone:nil];\n    } else if (mutableCopy) {\n        newValue = [newValue mutableCopyWithZone:nil];\n    } else {\n        if (*slot == newValue) return;\n        newValue = objc_retain(newValue);\n    }\n\n    if (!atomic) {\n        oldValue = *slot;\n        *slot = newValue;\n    } else {\n        spinlock_t& slotlock = PropertyLocks[slot];\n        slotlock.lock();\n        oldValue = *slot;\n        *slot = newValue;        \n        slotlock.unlock();\n    }\n\n    objc_release(oldValue);\n}\n```\n总结为retain新值，release旧值。\n","slug":"2020-09-10-isa结构解析","published":1,"updated":"2021-06-19T03:46:24.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbpv001jbjrj3df85i8p","content":"<h4 id=\"1-isa初始化\"><a href=\"#1-isa初始化\" class=\"headerlink\" title=\"1. isa初始化\"></a>1. isa初始化</h4><p>在 <a href=\"%5Bhttps://www.jianshu.com/p/d4091f8a703a%5D(https://www.jianshu.com/p/d4091f8a703a)\">iOS alloc原理分析</a> 中会 <code>initInstanceIsa</code>中初始化isa，源码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> </span><br><span class=\"line\">objc_object::initIsa(Class cls, <span class=\"keyword\">bool</span> nonpointer, <span class=\"keyword\">bool</span> hasCxxDtor) </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    ASSERT(!isTaggedPointer()); </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!nonpointer) &#123;</span><br><span class=\"line\">        isa = <span class=\"keyword\">isa_t</span>((<span class=\"keyword\">uintptr_t</span>)cls);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ASSERT(!DisableNonpointerIsa);</span><br><span class=\"line\">        ASSERT(!cls-&gt;instancesRequireRawIsa());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">isa_t</span> <span class=\"title\">newisa</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class=\"line\">        ASSERT(cls-&gt;classArrayIndex() &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        newisa.bits = ISA_INDEX_MAGIC_VALUE;</span><br><span class=\"line\">        <span class=\"comment\">// isa.magic is part of ISA_MAGIC_VALUE</span></span><br><span class=\"line\">        <span class=\"comment\">// isa.nonpointer is part of ISA_MAGIC_VALUE</span></span><br><span class=\"line\">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class=\"line\">        newisa.indexcls = (<span class=\"keyword\">uintptr_t</span>)cls-&gt;classArrayIndex();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">        newisa.bits = ISA_MAGIC_VALUE;</span><br><span class=\"line\">        <span class=\"comment\">// isa.magic is part of ISA_MAGIC_VALUE</span></span><br><span class=\"line\">        <span class=\"comment\">// isa.nonpointer is part of ISA_MAGIC_VALUE</span></span><br><span class=\"line\">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class=\"line\">        newisa.shiftcls = (<span class=\"keyword\">uintptr_t</span>)cls &gt;&gt; <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// This write must be performed in a single store in some cases</span></span><br><span class=\"line\">        <span class=\"comment\">// (for example when realizing a class because other threads</span></span><br><span class=\"line\">        <span class=\"comment\">// may simultaneously try to use the class).</span></span><br><span class=\"line\">        <span class=\"comment\">// fixme use atomics here to guarantee single-store and to</span></span><br><span class=\"line\">        <span class=\"comment\">// guarantee memory order w.r.t. the class index table</span></span><br><span class=\"line\">        <span class=\"comment\">// ...but not too atomic because we don&#x27;t want to hurt instantiation</span></span><br><span class=\"line\">        isa = newisa;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">```  </span><br><span class=\"line\">分析：  </span><br><span class=\"line\">如果没有开启指针优化，则直接将类赋值给isa指针，即isa直接指向该类，`isa = <span class=\"keyword\">isa_t</span>((<span class=\"keyword\">uintptr_t</span>)cls);`。  </span><br><span class=\"line\">如果开启指针优化，则以另一种形式初始化isa指针。</span><br><span class=\"line\"></span><br><span class=\"line\">#### <span class=\"number\">2.</span> isa结构</span><br><span class=\"line\">根据源码可知isa类型为`<span class=\"keyword\">isa_t</span>`联合体类型，源码如下：  </span><br><span class=\"line\">```  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">isa_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">isa_t</span>() &#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">isa_t</span>(<span class=\"keyword\">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class cls;</span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> bits;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(ISA_BITFIELD)</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">        ISA_BITFIELD;  <span class=\"comment\">// defined in isa.h</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">if</span> __arm64__</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> ISA_BITFIELD                                                      \\</span></span><br><span class=\"line\">      <span class=\"keyword\">uintptr_t</span> nonpointer        : <span class=\"number\">1</span>;                                       \\</span><br><span class=\"line\">      <span class=\"keyword\">uintptr_t</span> has_assoc         : <span class=\"number\">1</span>;                                       \\</span><br><span class=\"line\">      <span class=\"keyword\">uintptr_t</span> has_cxx_dtor      : <span class=\"number\">1</span>;                                       \\</span><br><span class=\"line\">      <span class=\"keyword\">uintptr_t</span> shiftcls          : <span class=\"number\">33</span>; <span class=\"comment\">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> \\</span><br><span class=\"line\">      <span class=\"keyword\">uintptr_t</span> magic             : <span class=\"number\">6</span>;                                       \\</span><br><span class=\"line\">      <span class=\"keyword\">uintptr_t</span> weakly_referenced : <span class=\"number\">1</span>;                                       \\</span><br><span class=\"line\">      <span class=\"keyword\">uintptr_t</span> deallocating      : <span class=\"number\">1</span>;                                       \\</span><br><span class=\"line\">      <span class=\"keyword\">uintptr_t</span> has_sidetable_rc  : <span class=\"number\">1</span>;                                       \\</span><br><span class=\"line\">      <span class=\"keyword\">uintptr_t</span> extra_rc          : <span class=\"number\">19</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>联合体：又名共用体，可以包含多个不同类型的成员。结构体和联合体的区别在于结构体的各个成员会占据不同的内存，而联合体的成员共用一块内存，各个成员的首地址相同。</p>\n</blockquote>\n<p>所以在<code>isa_t</code>联合体中<code>Class cls</code>和<code>uintptr_t bits</code>是互斥的。<br>由 <code>typedef unsigned long           uintptr_t;</code> 所知，bits占据8字节，共64位，64位中存储的即<code>ISA_BITFIELD</code>宏定义中的内容。</p>\n<p><code>uintptr_t nonpointer        : 1;  </code> 是否对isa指针开启优化。0:纯isa指针 1:不只类对象地址，还包括了类信息，对象对引用计数等。<br><code>uintptr_t has_assoc        : 1;  </code> 关联对象标识位 0:没有 1:存在。<br><code>uintptr_t has_cxx_dtor    : 1;  </code> 是否有c++或objc的析构函数 如果有则需要调用析构逻辑，如果没有则可以更快释放对象。<br><code>uintptr_t shiftcls          : 33;  </code> 存储类指针的值，开启指针优化时，有33位用来存放类指针。<br><code>uintptr_t magic             : 6;  </code> 用于调试器判断当前对象是真的对象还是未初始化的空间。<br><code>uintptr_t weakly_referenced : 1;  </code> 标志对象是否被指向或曾经指向一个ARC的弱变量，没有弱引用的对象可以更快的释放。<br><code>uintptr_t deallocating      : 1; </code> 标志对象是否正在释放内存。<br><code>uintptr_t has_sidetable_rc  : 1; </code> 当引用计数大于10时，则需要借助该变量存储进位。<br><code>uintptr_t extra_rc          : 19 </code> 表示该对象的引用计数减1，如果引用计数为10，则extra_rc为9，如果引用计数大于10，则需要借助has_sidetable_rc。</p>\n<h4 id=\"3-isa与类关联\"><a href=\"#3-isa与类关联\" class=\"headerlink\" title=\"3. isa与类关联\"></a>3. isa与类关联</h4><figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (Class)<span class=\"class\"><span class=\"keyword\">class</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> object_getClass(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取类对象，元类也是特殊的类对象</p>\n<figure class=\"highlight monkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">Class</span> <span class=\"title\">object_getClass</span>(<span class=\"title\">id</span> <span class=\"title\">obj</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) <span class=\"keyword\">return</span> obj-&gt;getIsa();</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> Nil;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">Class</span> </span></span><br><span class=\"line\">objc_object::getIsa() </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fastpath(!isTaggedPointer())) <span class=\"keyword\">return</span> ISA();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">extern</span> objc_class OBJC_CLASS_$___NSUnrecognizedTaggedPointer;</span><br><span class=\"line\">    uintptr_t slot, ptr = (uintptr_t)this;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">Class</span> <span class=\"title\">cls</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    slot = (ptr &gt;&gt; _OBJC_TAG_SLOT_SHIFT) &amp; _OBJC_TAG_SLOT_MASK;</span><br><span class=\"line\">    cls = objc_tag_classes[slot];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(cls == (<span class=\"class\"><span class=\"keyword\">Class</span>)&amp;<span class=\"title\">OBJC_CLASS_</span>$<span class=\"title\">___NSUnrecognizedTaggedPointer</span>)) &#123;</span></span><br><span class=\"line\">        slot = (ptr &gt;&gt; _OBJC_TAG_EXT_SLOT_SHIFT) &amp; _OBJC_TAG_EXT_SLOT_MASK;</span><br><span class=\"line\">        cls = objc_tag_ext_classes[slot];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cls;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">Class</span> </span></span><br><span class=\"line\">objc_object::ISA() </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ASSERT(!isTaggedPointer()); </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isa.nonpointer) &#123;</span><br><span class=\"line\">        uintptr_t slot = isa.indexcls;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> classForIndex((unsigned)slot);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"class\"><span class=\"keyword\">Class</span>)<span class=\"title\">isa</span>.<span class=\"title\">bits</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"class\"><span class=\"keyword\">Class</span>)(<span class=\"title\">isa</span>.<span class=\"title\">bits</span> &amp; <span class=\"title\">ISA_MASK</span>);</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取类对象，即获取isa的指向。非taggedPointer的isa，最终返回<code>return (Class)(isa.bits &amp; ISA_MASK);</code></p>\n<h4 id=\"4-对象的本质\"><a href=\"#4-对象的本质\" class=\"headerlink\" title=\"4. 对象的本质\"></a>4. 对象的本质</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main.m</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&quot;LSPerson.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> * name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[])</span> </span>&#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        LSPerson *p1 = [[LSPerson alloc] init]; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过<code>clang -rewrite-objc main.m -o main.cpp</code>将以上文件转成c++文件<br> <code>NSObject</code>底层结构为</p>\n<figure class=\"highlight capnproto\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NSObject_IMPL</span> </span>&#123;</span><br><span class=\"line\">\tClass isa;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>LSPerson底层结构为</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LSPerson_IMPL</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NSObject_IMPL</span> <span class=\"title\">NSObject_IVARS</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>因为LSPerson并没有其他成员变量，则直接继承自NSObject的结构体，所以继承自NSObject的对象都会有isa指针。</p>\n<p>属性的setter方法都会调用<code>objc_setProperty</code>函数</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void objc<span class=\"constructor\">_setProperty(<span class=\"params\">id</span> <span class=\"params\">self</span>, SEL <span class=\"params\">_cmd</span>, <span class=\"params\">ptrdiff_t</span> <span class=\"params\">offset</span>, <span class=\"params\">id</span> <span class=\"params\">newValue</span>, BOOL <span class=\"params\">atomic</span>, <span class=\"params\">signed</span> <span class=\"params\">char</span> <span class=\"params\">shouldCopy</span>)</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> copy = (shouldCopy<span class=\"operator\"> &amp;&amp; </span>shouldCopy != MUTABLE_COPY);</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> mutableCopy = (shouldCopy<span class=\"operator\"> == </span>MUTABLE_COPY);</span><br><span class=\"line\">    really<span class=\"constructor\">SetProperty(<span class=\"params\">self</span>, <span class=\"params\">_cmd</span>, <span class=\"params\">newValue</span>, <span class=\"params\">offset</span>, <span class=\"params\">atomic</span>, <span class=\"params\">copy</span>, <span class=\"params\">mutableCopy</span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static inline void really<span class=\"constructor\">SetProperty(<span class=\"params\">id</span> <span class=\"params\">self</span>, SEL <span class=\"params\">_cmd</span>, <span class=\"params\">id</span> <span class=\"params\">newValue</span>, <span class=\"params\">ptrdiff_t</span> <span class=\"params\">offset</span>, <span class=\"params\">bool</span> <span class=\"params\">atomic</span>, <span class=\"params\">bool</span> <span class=\"params\">copy</span>, <span class=\"params\">bool</span> <span class=\"params\">mutableCopy</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (offset<span class=\"operator\"> == </span><span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">object</span><span class=\"constructor\">_setClass(<span class=\"params\">self</span>, <span class=\"params\">newValue</span>)</span>;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    id oldValue;</span><br><span class=\"line\">    id *slot = (id*) ((<span class=\"built_in\">char</span>*)self + offset);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (copy) &#123;</span><br><span class=\"line\">        newValue = <span class=\"literal\">[<span class=\"identifier\">newValue</span> <span class=\"identifier\">copyWithZone</span>:<span class=\"identifier\">nil</span>]</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mutableCopy) &#123;</span><br><span class=\"line\">        newValue = <span class=\"literal\">[<span class=\"identifier\">newValue</span> <span class=\"identifier\">mutableCopyWithZone</span>:<span class=\"identifier\">nil</span>]</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*slot<span class=\"operator\"> == </span>newValue) return;</span><br><span class=\"line\">        newValue = objc<span class=\"constructor\">_retain(<span class=\"params\">newValue</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!atomic) &#123;</span><br><span class=\"line\">        oldValue = *slot;</span><br><span class=\"line\">        *slot = newValue;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        spinlock_t&amp; slotlock = PropertyLocks<span class=\"literal\">[<span class=\"identifier\">slot</span>]</span>;</span><br><span class=\"line\">        slotlock.lock<span class=\"literal\">()</span>;</span><br><span class=\"line\">        oldValue = *slot;</span><br><span class=\"line\">        *slot = newValue;        </span><br><span class=\"line\">        slotlock.unlock<span class=\"literal\">()</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    objc<span class=\"constructor\">_release(<span class=\"params\">oldValue</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结为retain新值，release旧值。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1-isa初始化\"><a href=\"#1-isa初始化\" class=\"headerlink\" title=\"1. isa初始化\"></a>1. isa初始化</h4><p>在 <a href=\"%5Bhttps://www.jianshu.com/p/d4091f8a703a%5D(https://www.jianshu.com/p/d4091f8a703a)\">iOS alloc原理分析</a> 中会 <code>initInstanceIsa</code>中初始化isa，源码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> </span><br><span class=\"line\">objc_object::initIsa(Class cls, <span class=\"keyword\">bool</span> nonpointer, <span class=\"keyword\">bool</span> hasCxxDtor) </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    ASSERT(!isTaggedPointer()); </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!nonpointer) &#123;</span><br><span class=\"line\">        isa = <span class=\"keyword\">isa_t</span>((<span class=\"keyword\">uintptr_t</span>)cls);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ASSERT(!DisableNonpointerIsa);</span><br><span class=\"line\">        ASSERT(!cls-&gt;instancesRequireRawIsa());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">isa_t</span> <span class=\"title\">newisa</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class=\"line\">        ASSERT(cls-&gt;classArrayIndex() &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        newisa.bits = ISA_INDEX_MAGIC_VALUE;</span><br><span class=\"line\">        <span class=\"comment\">// isa.magic is part of ISA_MAGIC_VALUE</span></span><br><span class=\"line\">        <span class=\"comment\">// isa.nonpointer is part of ISA_MAGIC_VALUE</span></span><br><span class=\"line\">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class=\"line\">        newisa.indexcls = (<span class=\"keyword\">uintptr_t</span>)cls-&gt;classArrayIndex();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">        newisa.bits = ISA_MAGIC_VALUE;</span><br><span class=\"line\">        <span class=\"comment\">// isa.magic is part of ISA_MAGIC_VALUE</span></span><br><span class=\"line\">        <span class=\"comment\">// isa.nonpointer is part of ISA_MAGIC_VALUE</span></span><br><span class=\"line\">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class=\"line\">        newisa.shiftcls = (<span class=\"keyword\">uintptr_t</span>)cls &gt;&gt; <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// This write must be performed in a single store in some cases</span></span><br><span class=\"line\">        <span class=\"comment\">// (for example when realizing a class because other threads</span></span><br><span class=\"line\">        <span class=\"comment\">// may simultaneously try to use the class).</span></span><br><span class=\"line\">        <span class=\"comment\">// fixme use atomics here to guarantee single-store and to</span></span><br><span class=\"line\">        <span class=\"comment\">// guarantee memory order w.r.t. the class index table</span></span><br><span class=\"line\">        <span class=\"comment\">// ...but not too atomic because we don&#x27;t want to hurt instantiation</span></span><br><span class=\"line\">        isa = newisa;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">```  </span><br><span class=\"line\">分析：  </span><br><span class=\"line\">如果没有开启指针优化，则直接将类赋值给isa指针，即isa直接指向该类，`isa = <span class=\"keyword\">isa_t</span>((<span class=\"keyword\">uintptr_t</span>)cls);`。  </span><br><span class=\"line\">如果开启指针优化，则以另一种形式初始化isa指针。</span><br><span class=\"line\"></span><br><span class=\"line\">#### <span class=\"number\">2.</span> isa结构</span><br><span class=\"line\">根据源码可知isa类型为`<span class=\"keyword\">isa_t</span>`联合体类型，源码如下：  </span><br><span class=\"line\">```  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">isa_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">isa_t</span>() &#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">isa_t</span>(<span class=\"keyword\">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class cls;</span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> bits;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined(ISA_BITFIELD)</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">        ISA_BITFIELD;  <span class=\"comment\">// defined in isa.h</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">if</span> __arm64__</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> ISA_BITFIELD                                                      \\</span></span><br><span class=\"line\">      <span class=\"keyword\">uintptr_t</span> nonpointer        : <span class=\"number\">1</span>;                                       \\</span><br><span class=\"line\">      <span class=\"keyword\">uintptr_t</span> has_assoc         : <span class=\"number\">1</span>;                                       \\</span><br><span class=\"line\">      <span class=\"keyword\">uintptr_t</span> has_cxx_dtor      : <span class=\"number\">1</span>;                                       \\</span><br><span class=\"line\">      <span class=\"keyword\">uintptr_t</span> shiftcls          : <span class=\"number\">33</span>; <span class=\"comment\">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> \\</span><br><span class=\"line\">      <span class=\"keyword\">uintptr_t</span> magic             : <span class=\"number\">6</span>;                                       \\</span><br><span class=\"line\">      <span class=\"keyword\">uintptr_t</span> weakly_referenced : <span class=\"number\">1</span>;                                       \\</span><br><span class=\"line\">      <span class=\"keyword\">uintptr_t</span> deallocating      : <span class=\"number\">1</span>;                                       \\</span><br><span class=\"line\">      <span class=\"keyword\">uintptr_t</span> has_sidetable_rc  : <span class=\"number\">1</span>;                                       \\</span><br><span class=\"line\">      <span class=\"keyword\">uintptr_t</span> extra_rc          : <span class=\"number\">19</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>联合体：又名共用体，可以包含多个不同类型的成员。结构体和联合体的区别在于结构体的各个成员会占据不同的内存，而联合体的成员共用一块内存，各个成员的首地址相同。</p>\n</blockquote>\n<p>所以在<code>isa_t</code>联合体中<code>Class cls</code>和<code>uintptr_t bits</code>是互斥的。<br>由 <code>typedef unsigned long           uintptr_t;</code> 所知，bits占据8字节，共64位，64位中存储的即<code>ISA_BITFIELD</code>宏定义中的内容。</p>\n<p><code>uintptr_t nonpointer        : 1;  </code> 是否对isa指针开启优化。0:纯isa指针 1:不只类对象地址，还包括了类信息，对象对引用计数等。<br><code>uintptr_t has_assoc        : 1;  </code> 关联对象标识位 0:没有 1:存在。<br><code>uintptr_t has_cxx_dtor    : 1;  </code> 是否有c++或objc的析构函数 如果有则需要调用析构逻辑，如果没有则可以更快释放对象。<br><code>uintptr_t shiftcls          : 33;  </code> 存储类指针的值，开启指针优化时，有33位用来存放类指针。<br><code>uintptr_t magic             : 6;  </code> 用于调试器判断当前对象是真的对象还是未初始化的空间。<br><code>uintptr_t weakly_referenced : 1;  </code> 标志对象是否被指向或曾经指向一个ARC的弱变量，没有弱引用的对象可以更快的释放。<br><code>uintptr_t deallocating      : 1; </code> 标志对象是否正在释放内存。<br><code>uintptr_t has_sidetable_rc  : 1; </code> 当引用计数大于10时，则需要借助该变量存储进位。<br><code>uintptr_t extra_rc          : 19 </code> 表示该对象的引用计数减1，如果引用计数为10，则extra_rc为9，如果引用计数大于10，则需要借助has_sidetable_rc。</p>\n<h4 id=\"3-isa与类关联\"><a href=\"#3-isa与类关联\" class=\"headerlink\" title=\"3. isa与类关联\"></a>3. isa与类关联</h4><figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (Class)<span class=\"class\"><span class=\"keyword\">class</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> object_getClass(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取类对象，元类也是特殊的类对象</p>\n<figure class=\"highlight monkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">Class</span> <span class=\"title\">object_getClass</span>(<span class=\"title\">id</span> <span class=\"title\">obj</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) <span class=\"keyword\">return</span> obj-&gt;getIsa();</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> Nil;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">Class</span> </span></span><br><span class=\"line\">objc_object::getIsa() </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fastpath(!isTaggedPointer())) <span class=\"keyword\">return</span> ISA();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">extern</span> objc_class OBJC_CLASS_$___NSUnrecognizedTaggedPointer;</span><br><span class=\"line\">    uintptr_t slot, ptr = (uintptr_t)this;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">Class</span> <span class=\"title\">cls</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    slot = (ptr &gt;&gt; _OBJC_TAG_SLOT_SHIFT) &amp; _OBJC_TAG_SLOT_MASK;</span><br><span class=\"line\">    cls = objc_tag_classes[slot];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(cls == (<span class=\"class\"><span class=\"keyword\">Class</span>)&amp;<span class=\"title\">OBJC_CLASS_</span>$<span class=\"title\">___NSUnrecognizedTaggedPointer</span>)) &#123;</span></span><br><span class=\"line\">        slot = (ptr &gt;&gt; _OBJC_TAG_EXT_SLOT_SHIFT) &amp; _OBJC_TAG_EXT_SLOT_MASK;</span><br><span class=\"line\">        cls = objc_tag_ext_classes[slot];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cls;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"class\"><span class=\"keyword\">Class</span> </span></span><br><span class=\"line\">objc_object::ISA() </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ASSERT(!isTaggedPointer()); </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isa.nonpointer) &#123;</span><br><span class=\"line\">        uintptr_t slot = isa.indexcls;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> classForIndex((unsigned)slot);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"class\"><span class=\"keyword\">Class</span>)<span class=\"title\">isa</span>.<span class=\"title\">bits</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"class\"><span class=\"keyword\">Class</span>)(<span class=\"title\">isa</span>.<span class=\"title\">bits</span> &amp; <span class=\"title\">ISA_MASK</span>);</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取类对象，即获取isa的指向。非taggedPointer的isa，最终返回<code>return (Class)(isa.bits &amp; ISA_MASK);</code></p>\n<h4 id=\"4-对象的本质\"><a href=\"#4-对象的本质\" class=\"headerlink\" title=\"4. 对象的本质\"></a>4. 对象的本质</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main.m</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&quot;LSPerson.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> * name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[])</span> </span>&#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        LSPerson *p1 = [[LSPerson alloc] init]; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过<code>clang -rewrite-objc main.m -o main.cpp</code>将以上文件转成c++文件<br> <code>NSObject</code>底层结构为</p>\n<figure class=\"highlight capnproto\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NSObject_IMPL</span> </span>&#123;</span><br><span class=\"line\">\tClass isa;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>LSPerson底层结构为</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LSPerson_IMPL</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NSObject_IMPL</span> <span class=\"title\">NSObject_IVARS</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>因为LSPerson并没有其他成员变量，则直接继承自NSObject的结构体，所以继承自NSObject的对象都会有isa指针。</p>\n<p>属性的setter方法都会调用<code>objc_setProperty</code>函数</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void objc<span class=\"constructor\">_setProperty(<span class=\"params\">id</span> <span class=\"params\">self</span>, SEL <span class=\"params\">_cmd</span>, <span class=\"params\">ptrdiff_t</span> <span class=\"params\">offset</span>, <span class=\"params\">id</span> <span class=\"params\">newValue</span>, BOOL <span class=\"params\">atomic</span>, <span class=\"params\">signed</span> <span class=\"params\">char</span> <span class=\"params\">shouldCopy</span>)</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> copy = (shouldCopy<span class=\"operator\"> &amp;&amp; </span>shouldCopy != MUTABLE_COPY);</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> mutableCopy = (shouldCopy<span class=\"operator\"> == </span>MUTABLE_COPY);</span><br><span class=\"line\">    really<span class=\"constructor\">SetProperty(<span class=\"params\">self</span>, <span class=\"params\">_cmd</span>, <span class=\"params\">newValue</span>, <span class=\"params\">offset</span>, <span class=\"params\">atomic</span>, <span class=\"params\">copy</span>, <span class=\"params\">mutableCopy</span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static inline void really<span class=\"constructor\">SetProperty(<span class=\"params\">id</span> <span class=\"params\">self</span>, SEL <span class=\"params\">_cmd</span>, <span class=\"params\">id</span> <span class=\"params\">newValue</span>, <span class=\"params\">ptrdiff_t</span> <span class=\"params\">offset</span>, <span class=\"params\">bool</span> <span class=\"params\">atomic</span>, <span class=\"params\">bool</span> <span class=\"params\">copy</span>, <span class=\"params\">bool</span> <span class=\"params\">mutableCopy</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (offset<span class=\"operator\"> == </span><span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">object</span><span class=\"constructor\">_setClass(<span class=\"params\">self</span>, <span class=\"params\">newValue</span>)</span>;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    id oldValue;</span><br><span class=\"line\">    id *slot = (id*) ((<span class=\"built_in\">char</span>*)self + offset);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (copy) &#123;</span><br><span class=\"line\">        newValue = <span class=\"literal\">[<span class=\"identifier\">newValue</span> <span class=\"identifier\">copyWithZone</span>:<span class=\"identifier\">nil</span>]</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mutableCopy) &#123;</span><br><span class=\"line\">        newValue = <span class=\"literal\">[<span class=\"identifier\">newValue</span> <span class=\"identifier\">mutableCopyWithZone</span>:<span class=\"identifier\">nil</span>]</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*slot<span class=\"operator\"> == </span>newValue) return;</span><br><span class=\"line\">        newValue = objc<span class=\"constructor\">_retain(<span class=\"params\">newValue</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!atomic) &#123;</span><br><span class=\"line\">        oldValue = *slot;</span><br><span class=\"line\">        *slot = newValue;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        spinlock_t&amp; slotlock = PropertyLocks<span class=\"literal\">[<span class=\"identifier\">slot</span>]</span>;</span><br><span class=\"line\">        slotlock.lock<span class=\"literal\">()</span>;</span><br><span class=\"line\">        oldValue = *slot;</span><br><span class=\"line\">        *slot = newValue;        </span><br><span class=\"line\">        slotlock.unlock<span class=\"literal\">()</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    objc<span class=\"constructor\">_release(<span class=\"params\">oldValue</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结为retain新值，release旧值。</p>\n"},{"title":"iOS 类的结构分析","date":"2020-09-12T16:00:00.000Z","_content":"\n#### 1. 类的初探  \n在[isa结构解析]()中，自定义`LSPerson` 类继承自`NSObject`,重写成C++代码如下\n```\nstruct LSPerson_IMPL {\n\tstruct NSObject_IMPL NSObject_IVARS;\n};\n```\n\n`struct NSObject_IMPL`结构体定义如下\n```\nstruct NSObject_IMPL {\n\tClass isa;\n};\n```\n\n`typedef struct objc_class *Class;`\nClass为指向 结构体`struct objc_class`的指针，所以继承自`NSObject`的对象中都有isa成员变量。那么`NSObject`的isa来自何处呢？\n\n`objc_class`源码如下\n```\nstruct objc_class : objc_object {\n    // Class ISA;\n    Class superclass;\n    cache_t cache;             // formerly cache pointer and vtable\n    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\n\n    class_rw_t *data() const {\n        return bits.data();\n    }\n\n    ...省略的函数\n}\n```\n由此可以知道`struct objc_class`继承自`struct objc_object`\n\n`struct objc_object`源码如下\n```\nstruct objc_object {\nprivate:\n    isa_t isa;\n\npublic:\n    ...省略的函数\n}\n```\n总结：在OC层，对象的isa指向对象的类，对象的类继承自`NSObject`，`NSObject`是以结构体`struct objc_class`为模版创建的；在C++层，`struct objc_class`继承自`struct objc_object`，`struct objc_object`内部有isa成员变量。\n\n#### 2. 类的结构分析\n由结构体`struct objc_class`源码可知，类的信息存储在`class_data_bits_t bits;`中。\n为了取到`class_data_bits_t bits;`，需要在结构体`struct objc_class`进行地址偏移计算。\n\n1.  Class ISA; //结构体指针类型 8字节\n2.  Class superclass;//结构体指针类型 8字节\n3.  cache_t cache; \n\ncache_t源码\n```\nstruct cache_t {\n#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_OUTLINED\n    explicit_atomic<struct bucket_t *> _buckets;\n    explicit_atomic<mask_t> _mask;\n#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16\n    explicit_atomic<uintptr_t> _maskAndBuckets;\n    mask_t _mask_unused;\n\n    ...其他全局变量\n\n#if __LP64__\n    uint16_t _flags;\n#endif\n    uint16_t _occupied;\n\n    ...其他方法\n```\n`cache_t`结构体计算：`explicit_atomic<uintptr_t> _maskAndBuckets;` long类型 8字节； `mask_t  _mask_unused;` int类型 4字节； `uint16_t _flags;` short类型 2字节；`uint16_t _occupied;` short类型 2字节。根据内存对齐原则`cache_t`大小为16字节。故为了取到`class_data_bits_t bits;`，需要在结构体`struct objc_class`对首地址进行偏移**32字节**。\n\n探索流程：\n```\n//获取LSPerson类首地址\n(lldb) p/x LSPerson.class\n(Class) $0 = 0x00000001000021c8 LSPerson\n\n//获取类isa中对内存信息\n(lldb) x/4gx 0x00000001000021c8\n(lldb) x/4gx 0x00000001000021c8\n0x1000021c8: 0x00000001000021a0 0x00007fff944ae118\n0x1000021d8: 0x00007fff6cd18140 0x0000801000000000\n\n//根据地址偏移0x1000021c8 -> 0x1000021d8 获取bits信息\n(lldb) p (class_data_bits_t *)0x1000021d8\n(class_data_bits_t *) $1 = 0x00000001000021e8\n\n//根据struct objc_class中data()函数获取class_rw_t\n(lldb) p $1->data()\n(class_rw_t *) $2 = 0x00000001010224b0\n\n(lldb) p *($2)\n(class_rw_t) $4 = {\n  flags = 2148007936\n  witness = 0\n  ro_or_rw_ext = {\n    std::__1::atomic<unsigned long> = 4294975744\n  }\n  firstSubclass = nil\n  nextSiblingClass = NSUUID\n}\n\n(lldb) p $4.methods()      //打印出对象方法列表\n(lldb) p $4.properties()    //打印出属性列表\n(lldb) p $4.protocols()     //打印出协议列表\n```\n\nclass_rw_t源码\n```\nstruct class_rw_t {\n    // Be warned that Symbolication knows the layout of this structure.\n    uint32_t flags;\n    uint16_t witness;\n#if SUPPORT_INDEXED_ISA\n    uint16_t index;\n#endif\n\n    explicit_atomic<uintptr_t> ro_or_rw_ext;\n\n    Class firstSubclass;\n    Class nextSiblingClass;\n\nprivate: \n    ...省去其他函数\n\npublic: \n    ...省去其他函数\n    const class_ro_t *ro() const {\n        auto v = get_ro_or_rwe();\n        if (slowpath(v.is<class_rw_ext_t *>())) {\n            return v.get<class_rw_ext_t *>()->ro;\n        }\n        return v.get<const class_ro_t *>();\n    } \n\n    const method_array_t methods() const {\n        auto v = get_ro_or_rwe();\n        if (v.is<class_rw_ext_t *>()) {\n            return v.get<class_rw_ext_t *>()->methods;\n        } else {\n            return method_array_t{v.get<const class_ro_t *>()->baseMethods()};\n        }\n    }\n\n    const property_array_t properties() const {\n        auto v = get_ro_or_rwe();\n        if (v.is<class_rw_ext_t *>()) {\n            return v.get<class_rw_ext_t *>()->properties;\n        } else {\n            return property_array_t{v.get<const class_ro_t *>()->baseProperties};\n        }\n    }\n\n    const protocol_array_t protocols() const {\n        auto v = get_ro_or_rwe();\n        if (v.is<class_rw_ext_t *>()) {\n            return v.get<class_rw_ext_t *>()->protocols;\n        } else {\n            return protocol_array_t{v.get<const class_ro_t *>()->baseProtocols};\n        }\n    }\n};\n```\n\n根据已获取的class_rw_t，调用结构体内部函数`methods()`、`properties()`、`protocols()`即可获取类的方法列表，属性列表以及协议列表。","source":"_posts/2020-09-13-iOS 类的结构分析.md","raw":"---\ntitle:      \"iOS 类的结构分析\" \ndate:       2020-09-13\ntags:\n    - iOS底层原理\ncategories:\n    - iOS底层原理\n---\n\n#### 1. 类的初探  \n在[isa结构解析]()中，自定义`LSPerson` 类继承自`NSObject`,重写成C++代码如下\n```\nstruct LSPerson_IMPL {\n\tstruct NSObject_IMPL NSObject_IVARS;\n};\n```\n\n`struct NSObject_IMPL`结构体定义如下\n```\nstruct NSObject_IMPL {\n\tClass isa;\n};\n```\n\n`typedef struct objc_class *Class;`\nClass为指向 结构体`struct objc_class`的指针，所以继承自`NSObject`的对象中都有isa成员变量。那么`NSObject`的isa来自何处呢？\n\n`objc_class`源码如下\n```\nstruct objc_class : objc_object {\n    // Class ISA;\n    Class superclass;\n    cache_t cache;             // formerly cache pointer and vtable\n    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\n\n    class_rw_t *data() const {\n        return bits.data();\n    }\n\n    ...省略的函数\n}\n```\n由此可以知道`struct objc_class`继承自`struct objc_object`\n\n`struct objc_object`源码如下\n```\nstruct objc_object {\nprivate:\n    isa_t isa;\n\npublic:\n    ...省略的函数\n}\n```\n总结：在OC层，对象的isa指向对象的类，对象的类继承自`NSObject`，`NSObject`是以结构体`struct objc_class`为模版创建的；在C++层，`struct objc_class`继承自`struct objc_object`，`struct objc_object`内部有isa成员变量。\n\n#### 2. 类的结构分析\n由结构体`struct objc_class`源码可知，类的信息存储在`class_data_bits_t bits;`中。\n为了取到`class_data_bits_t bits;`，需要在结构体`struct objc_class`进行地址偏移计算。\n\n1.  Class ISA; //结构体指针类型 8字节\n2.  Class superclass;//结构体指针类型 8字节\n3.  cache_t cache; \n\ncache_t源码\n```\nstruct cache_t {\n#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_OUTLINED\n    explicit_atomic<struct bucket_t *> _buckets;\n    explicit_atomic<mask_t> _mask;\n#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16\n    explicit_atomic<uintptr_t> _maskAndBuckets;\n    mask_t _mask_unused;\n\n    ...其他全局变量\n\n#if __LP64__\n    uint16_t _flags;\n#endif\n    uint16_t _occupied;\n\n    ...其他方法\n```\n`cache_t`结构体计算：`explicit_atomic<uintptr_t> _maskAndBuckets;` long类型 8字节； `mask_t  _mask_unused;` int类型 4字节； `uint16_t _flags;` short类型 2字节；`uint16_t _occupied;` short类型 2字节。根据内存对齐原则`cache_t`大小为16字节。故为了取到`class_data_bits_t bits;`，需要在结构体`struct objc_class`对首地址进行偏移**32字节**。\n\n探索流程：\n```\n//获取LSPerson类首地址\n(lldb) p/x LSPerson.class\n(Class) $0 = 0x00000001000021c8 LSPerson\n\n//获取类isa中对内存信息\n(lldb) x/4gx 0x00000001000021c8\n(lldb) x/4gx 0x00000001000021c8\n0x1000021c8: 0x00000001000021a0 0x00007fff944ae118\n0x1000021d8: 0x00007fff6cd18140 0x0000801000000000\n\n//根据地址偏移0x1000021c8 -> 0x1000021d8 获取bits信息\n(lldb) p (class_data_bits_t *)0x1000021d8\n(class_data_bits_t *) $1 = 0x00000001000021e8\n\n//根据struct objc_class中data()函数获取class_rw_t\n(lldb) p $1->data()\n(class_rw_t *) $2 = 0x00000001010224b0\n\n(lldb) p *($2)\n(class_rw_t) $4 = {\n  flags = 2148007936\n  witness = 0\n  ro_or_rw_ext = {\n    std::__1::atomic<unsigned long> = 4294975744\n  }\n  firstSubclass = nil\n  nextSiblingClass = NSUUID\n}\n\n(lldb) p $4.methods()      //打印出对象方法列表\n(lldb) p $4.properties()    //打印出属性列表\n(lldb) p $4.protocols()     //打印出协议列表\n```\n\nclass_rw_t源码\n```\nstruct class_rw_t {\n    // Be warned that Symbolication knows the layout of this structure.\n    uint32_t flags;\n    uint16_t witness;\n#if SUPPORT_INDEXED_ISA\n    uint16_t index;\n#endif\n\n    explicit_atomic<uintptr_t> ro_or_rw_ext;\n\n    Class firstSubclass;\n    Class nextSiblingClass;\n\nprivate: \n    ...省去其他函数\n\npublic: \n    ...省去其他函数\n    const class_ro_t *ro() const {\n        auto v = get_ro_or_rwe();\n        if (slowpath(v.is<class_rw_ext_t *>())) {\n            return v.get<class_rw_ext_t *>()->ro;\n        }\n        return v.get<const class_ro_t *>();\n    } \n\n    const method_array_t methods() const {\n        auto v = get_ro_or_rwe();\n        if (v.is<class_rw_ext_t *>()) {\n            return v.get<class_rw_ext_t *>()->methods;\n        } else {\n            return method_array_t{v.get<const class_ro_t *>()->baseMethods()};\n        }\n    }\n\n    const property_array_t properties() const {\n        auto v = get_ro_or_rwe();\n        if (v.is<class_rw_ext_t *>()) {\n            return v.get<class_rw_ext_t *>()->properties;\n        } else {\n            return property_array_t{v.get<const class_ro_t *>()->baseProperties};\n        }\n    }\n\n    const protocol_array_t protocols() const {\n        auto v = get_ro_or_rwe();\n        if (v.is<class_rw_ext_t *>()) {\n            return v.get<class_rw_ext_t *>()->protocols;\n        } else {\n            return protocol_array_t{v.get<const class_ro_t *>()->baseProtocols};\n        }\n    }\n};\n```\n\n根据已获取的class_rw_t，调用结构体内部函数`methods()`、`properties()`、`protocols()`即可获取类的方法列表，属性列表以及协议列表。","slug":"2020-09-13-iOS 类的结构分析","published":1,"updated":"2021-06-19T03:46:24.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbpw001kbjrj31ocent4","content":"<h4 id=\"1-类的初探\"><a href=\"#1-类的初探\" class=\"headerlink\" title=\"1. 类的初探\"></a>1. 类的初探</h4><p>在<a href=\"\">isa结构解析</a>中，自定义<code>LSPerson</code> 类继承自<code>NSObject</code>,重写成C++代码如下</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LSPerson_IMPL</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NSObject_IMPL</span> <span class=\"title\">NSObject_IVARS</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>struct NSObject_IMPL</code>结构体定义如下</p>\n<figure class=\"highlight capnproto\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NSObject_IMPL</span> </span>&#123;</span><br><span class=\"line\">\tClass isa;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>typedef struct objc_class *Class;</code><br>Class为指向 结构体<code>struct objc_class</code>的指针，所以继承自<code>NSObject</code>的对象中都有isa成员变量。那么<code>NSObject</code>的isa来自何处呢？</p>\n<p><code>objc_class</code>源码如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_class</span> :</span> objc_object &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Class ISA;</span></span><br><span class=\"line\">    Class superclass;</span><br><span class=\"line\">    <span class=\"keyword\">cache_t</span> cache;             <span class=\"comment\">// formerly cache pointer and vtable</span></span><br><span class=\"line\">    <span class=\"keyword\">class_data_bits_t</span> bits;    <span class=\"comment\">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">class_rw_t</span> *<span class=\"title\">data</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bits.data();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...省略的函数</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由此可以知道<code>struct objc_class</code>继承自<code>struct objc_object</code></p>\n<p><code>struct objc_object</code>源码如下</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">struct</span> <span class=\"selector-tag\">objc_object</span> &#123;</span><br><span class=\"line\"><span class=\"attribute\">private</span>:</span><br><span class=\"line\">    isa_t isa;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">public</span>:</span><br><span class=\"line\">    ...省略的函数</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结：在OC层，对象的isa指向对象的类，对象的类继承自<code>NSObject</code>，<code>NSObject</code>是以结构体<code>struct objc_class</code>为模版创建的；在C++层，<code>struct objc_class</code>继承自<code>struct objc_object</code>，<code>struct objc_object</code>内部有isa成员变量。</p>\n<h4 id=\"2-类的结构分析\"><a href=\"#2-类的结构分析\" class=\"headerlink\" title=\"2. 类的结构分析\"></a>2. 类的结构分析</h4><p>由结构体<code>struct objc_class</code>源码可知，类的信息存储在<code>class_data_bits_t bits;</code>中。<br>为了取到<code>class_data_bits_t bits;</code>，需要在结构体<code>struct objc_class</code>进行地址偏移计算。</p>\n<ol>\n<li> Class ISA; //结构体指针类型 8字节</li>\n<li> Class superclass;//结构体指针类型 8字节</li>\n<li> cache_t cache; </li>\n</ol>\n<p>cache_t源码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cache_t</span> &#123;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_OUTLINED</span></span><br><span class=\"line\">    explicit_atomic&lt;<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bucket_t</span> *&gt;</span> _buckets;</span><br><span class=\"line\">    explicit_atomic&lt;<span class=\"keyword\">mask_t</span>&gt; _mask;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">elif</span> CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16</span></span><br><span class=\"line\">    explicit_atomic&lt;<span class=\"keyword\">uintptr_t</span>&gt; _maskAndBuckets;</span><br><span class=\"line\">    <span class=\"keyword\">mask_t</span> _mask_unused;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...其他全局变量</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> __LP64__</span></span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> _flags;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> _occupied;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...其他方法</span><br></pre></td></tr></table></figure>\n<p><code>cache_t</code>结构体计算：<code>explicit_atomic&lt;uintptr_t&gt; _maskAndBuckets;</code> long类型 8字节； <code>mask_t  _mask_unused;</code> int类型 4字节； <code>uint16_t _flags;</code> short类型 2字节；<code>uint16_t _occupied;</code> short类型 2字节。根据内存对齐原则<code>cache_t</code>大小为16字节。故为了取到<code>class_data_bits_t bits;</code>，需要在结构体<code>struct objc_class</code>对首地址进行偏移<strong>32字节</strong>。</p>\n<p>探索流程：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span>获取LSPerson类首地址</span><br><span class=\"line\">(lldb) p/x LSPerson.class</span><br><span class=\"line\">(Class) <span class=\"variable\">$0</span> = <span class=\"number\">0</span>x00000001000021c8 LSPerson</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span>获取类isa中对内存信息</span><br><span class=\"line\">(lldb) x/<span class=\"number\">4</span>gx <span class=\"number\">0</span>x00000001000021c8</span><br><span class=\"line\">(lldb) x/<span class=\"number\">4</span>gx <span class=\"number\">0</span>x00000001000021c8</span><br><span class=\"line\"><span class=\"number\">0</span>x1000021c8: <span class=\"number\">0</span>x00000001000021a0 <span class=\"number\">0</span>x00007fff944ae118</span><br><span class=\"line\"><span class=\"number\">0</span>x1000021d8: <span class=\"number\">0</span>x00007fff6cd18140 <span class=\"number\">0</span>x0000801000000000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span>根据地址偏移<span class=\"number\">0</span>x1000021c8 -&gt; <span class=\"number\">0</span>x1000021d8 获取bits信息</span><br><span class=\"line\">(lldb) p (class_data_bits_t *)<span class=\"number\">0</span>x1000021d8</span><br><span class=\"line\">(class_data_bits_t *) <span class=\"variable\">$1</span> = <span class=\"number\">0</span>x00000001000021e8</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span>根据struct objc_class中data()函数获取class_rw_t</span><br><span class=\"line\">(lldb) p <span class=\"variable\">$1</span>-&gt;data()</span><br><span class=\"line\">(class_rw_t *) <span class=\"variable\">$2</span> = <span class=\"number\">0</span>x00000001010224b0</span><br><span class=\"line\"></span><br><span class=\"line\">(lldb) p *(<span class=\"variable\">$2</span>)</span><br><span class=\"line\">(class_rw_t) <span class=\"variable\">$4</span> = &#123;</span><br><span class=\"line\">  flags = <span class=\"number\">2148007936</span></span><br><span class=\"line\">  witness = <span class=\"number\">0</span></span><br><span class=\"line\">  ro_or_rw_ext = &#123;</span><br><span class=\"line\">    std::__1::atomic&lt;unsigned long&gt; = <span class=\"number\">4294975744</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  firstSubclass = nil</span><br><span class=\"line\">  nextSiblingClass = NSUUID</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(lldb) p <span class=\"variable\">$4</span>.methods()      <span class=\"regexp\">//</span>打印出对象方法列表</span><br><span class=\"line\">(lldb) p <span class=\"variable\">$4</span>.properties()    <span class=\"regexp\">//</span>打印出属性列表</span><br><span class=\"line\">(lldb) p <span class=\"variable\">$4</span>.protocols()     <span class=\"regexp\">//</span>打印出协议列表</span><br></pre></td></tr></table></figure>\n\n<p>class_rw_t源码</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">class_rw_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> flags;</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> witness;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> index;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    explicit_atomic&lt;<span class=\"keyword\">uintptr_t</span>&gt; ro_or_rw_ext;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class firstSubclass;</span><br><span class=\"line\">    Class nextSiblingClass;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>: </span><br><span class=\"line\">    ...省去其他函数</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>: </span><br><span class=\"line\">    ...省去其他函数</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">class_ro_t</span> *<span class=\"title\">ro</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> v = get_ro_or_rwe();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowpath(v.is&lt;<span class=\"keyword\">class_rw_ext_t</span> *&gt;())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> v.<span class=\"built_in\">get</span>&lt;<span class=\"keyword\">class_rw_ext_t</span> *&gt;()-&gt;ro;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v.<span class=\"built_in\">get</span>&lt;<span class=\"keyword\">const</span> <span class=\"keyword\">class_ro_t</span> *&gt;();</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">method_array_t</span> <span class=\"title\">methods</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> v = get_ro_or_rwe();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v.is&lt;<span class=\"keyword\">class_rw_ext_t</span> *&gt;()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> v.<span class=\"built_in\">get</span>&lt;<span class=\"keyword\">class_rw_ext_t</span> *&gt;()-&gt;methods;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">method_array_t</span>&#123;v.<span class=\"built_in\">get</span>&lt;<span class=\"keyword\">const</span> <span class=\"keyword\">class_ro_t</span> *&gt;()-&gt;baseMethods()&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">property_array_t</span> <span class=\"title\">properties</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> v = get_ro_or_rwe();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v.is&lt;<span class=\"keyword\">class_rw_ext_t</span> *&gt;()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> v.<span class=\"built_in\">get</span>&lt;<span class=\"keyword\">class_rw_ext_t</span> *&gt;()-&gt;properties;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">property_array_t</span>&#123;v.<span class=\"built_in\">get</span>&lt;<span class=\"keyword\">const</span> <span class=\"keyword\">class_ro_t</span> *&gt;()-&gt;baseProperties&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">protocol_array_t</span> <span class=\"title\">protocols</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> v = get_ro_or_rwe();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v.is&lt;<span class=\"keyword\">class_rw_ext_t</span> *&gt;()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> v.<span class=\"built_in\">get</span>&lt;<span class=\"keyword\">class_rw_ext_t</span> *&gt;()-&gt;protocols;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">protocol_array_t</span>&#123;v.<span class=\"built_in\">get</span>&lt;<span class=\"keyword\">const</span> <span class=\"keyword\">class_ro_t</span> *&gt;()-&gt;baseProtocols&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>根据已获取的class_rw_t，调用结构体内部函数<code>methods()</code>、<code>properties()</code>、<code>protocols()</code>即可获取类的方法列表，属性列表以及协议列表。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1-类的初探\"><a href=\"#1-类的初探\" class=\"headerlink\" title=\"1. 类的初探\"></a>1. 类的初探</h4><p>在<a href=\"\">isa结构解析</a>中，自定义<code>LSPerson</code> 类继承自<code>NSObject</code>,重写成C++代码如下</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LSPerson_IMPL</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NSObject_IMPL</span> <span class=\"title\">NSObject_IVARS</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>struct NSObject_IMPL</code>结构体定义如下</p>\n<figure class=\"highlight capnproto\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NSObject_IMPL</span> </span>&#123;</span><br><span class=\"line\">\tClass isa;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>typedef struct objc_class *Class;</code><br>Class为指向 结构体<code>struct objc_class</code>的指针，所以继承自<code>NSObject</code>的对象中都有isa成员变量。那么<code>NSObject</code>的isa来自何处呢？</p>\n<p><code>objc_class</code>源码如下</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_class</span> :</span> objc_object &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Class ISA;</span></span><br><span class=\"line\">    Class superclass;</span><br><span class=\"line\">    <span class=\"keyword\">cache_t</span> cache;             <span class=\"comment\">// formerly cache pointer and vtable</span></span><br><span class=\"line\">    <span class=\"keyword\">class_data_bits_t</span> bits;    <span class=\"comment\">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">class_rw_t</span> *<span class=\"title\">data</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bits.data();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...省略的函数</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由此可以知道<code>struct objc_class</code>继承自<code>struct objc_object</code></p>\n<p><code>struct objc_object</code>源码如下</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">struct</span> <span class=\"selector-tag\">objc_object</span> &#123;</span><br><span class=\"line\"><span class=\"attribute\">private</span>:</span><br><span class=\"line\">    isa_t isa;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">public</span>:</span><br><span class=\"line\">    ...省略的函数</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结：在OC层，对象的isa指向对象的类，对象的类继承自<code>NSObject</code>，<code>NSObject</code>是以结构体<code>struct objc_class</code>为模版创建的；在C++层，<code>struct objc_class</code>继承自<code>struct objc_object</code>，<code>struct objc_object</code>内部有isa成员变量。</p>\n<h4 id=\"2-类的结构分析\"><a href=\"#2-类的结构分析\" class=\"headerlink\" title=\"2. 类的结构分析\"></a>2. 类的结构分析</h4><p>由结构体<code>struct objc_class</code>源码可知，类的信息存储在<code>class_data_bits_t bits;</code>中。<br>为了取到<code>class_data_bits_t bits;</code>，需要在结构体<code>struct objc_class</code>进行地址偏移计算。</p>\n<ol>\n<li> Class ISA; //结构体指针类型 8字节</li>\n<li> Class superclass;//结构体指针类型 8字节</li>\n<li> cache_t cache; </li>\n</ol>\n<p>cache_t源码</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cache_t</span> &#123;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_OUTLINED</span></span><br><span class=\"line\">    explicit_atomic&lt;<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bucket_t</span> *&gt;</span> _buckets;</span><br><span class=\"line\">    explicit_atomic&lt;<span class=\"keyword\">mask_t</span>&gt; _mask;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">elif</span> CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16</span></span><br><span class=\"line\">    explicit_atomic&lt;<span class=\"keyword\">uintptr_t</span>&gt; _maskAndBuckets;</span><br><span class=\"line\">    <span class=\"keyword\">mask_t</span> _mask_unused;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...其他全局变量</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> __LP64__</span></span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> _flags;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> _occupied;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...其他方法</span><br></pre></td></tr></table></figure>\n<p><code>cache_t</code>结构体计算：<code>explicit_atomic&lt;uintptr_t&gt; _maskAndBuckets;</code> long类型 8字节； <code>mask_t  _mask_unused;</code> int类型 4字节； <code>uint16_t _flags;</code> short类型 2字节；<code>uint16_t _occupied;</code> short类型 2字节。根据内存对齐原则<code>cache_t</code>大小为16字节。故为了取到<code>class_data_bits_t bits;</code>，需要在结构体<code>struct objc_class</code>对首地址进行偏移<strong>32字节</strong>。</p>\n<p>探索流程：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span>获取LSPerson类首地址</span><br><span class=\"line\">(lldb) p/x LSPerson.class</span><br><span class=\"line\">(Class) <span class=\"variable\">$0</span> = <span class=\"number\">0</span>x00000001000021c8 LSPerson</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span>获取类isa中对内存信息</span><br><span class=\"line\">(lldb) x/<span class=\"number\">4</span>gx <span class=\"number\">0</span>x00000001000021c8</span><br><span class=\"line\">(lldb) x/<span class=\"number\">4</span>gx <span class=\"number\">0</span>x00000001000021c8</span><br><span class=\"line\"><span class=\"number\">0</span>x1000021c8: <span class=\"number\">0</span>x00000001000021a0 <span class=\"number\">0</span>x00007fff944ae118</span><br><span class=\"line\"><span class=\"number\">0</span>x1000021d8: <span class=\"number\">0</span>x00007fff6cd18140 <span class=\"number\">0</span>x0000801000000000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span>根据地址偏移<span class=\"number\">0</span>x1000021c8 -&gt; <span class=\"number\">0</span>x1000021d8 获取bits信息</span><br><span class=\"line\">(lldb) p (class_data_bits_t *)<span class=\"number\">0</span>x1000021d8</span><br><span class=\"line\">(class_data_bits_t *) <span class=\"variable\">$1</span> = <span class=\"number\">0</span>x00000001000021e8</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span>根据struct objc_class中data()函数获取class_rw_t</span><br><span class=\"line\">(lldb) p <span class=\"variable\">$1</span>-&gt;data()</span><br><span class=\"line\">(class_rw_t *) <span class=\"variable\">$2</span> = <span class=\"number\">0</span>x00000001010224b0</span><br><span class=\"line\"></span><br><span class=\"line\">(lldb) p *(<span class=\"variable\">$2</span>)</span><br><span class=\"line\">(class_rw_t) <span class=\"variable\">$4</span> = &#123;</span><br><span class=\"line\">  flags = <span class=\"number\">2148007936</span></span><br><span class=\"line\">  witness = <span class=\"number\">0</span></span><br><span class=\"line\">  ro_or_rw_ext = &#123;</span><br><span class=\"line\">    std::__1::atomic&lt;unsigned long&gt; = <span class=\"number\">4294975744</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  firstSubclass = nil</span><br><span class=\"line\">  nextSiblingClass = NSUUID</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(lldb) p <span class=\"variable\">$4</span>.methods()      <span class=\"regexp\">//</span>打印出对象方法列表</span><br><span class=\"line\">(lldb) p <span class=\"variable\">$4</span>.properties()    <span class=\"regexp\">//</span>打印出属性列表</span><br><span class=\"line\">(lldb) p <span class=\"variable\">$4</span>.protocols()     <span class=\"regexp\">//</span>打印出协议列表</span><br></pre></td></tr></table></figure>\n\n<p>class_rw_t源码</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">class_rw_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> flags;</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> witness;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> index;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    explicit_atomic&lt;<span class=\"keyword\">uintptr_t</span>&gt; ro_or_rw_ext;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class firstSubclass;</span><br><span class=\"line\">    Class nextSiblingClass;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>: </span><br><span class=\"line\">    ...省去其他函数</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>: </span><br><span class=\"line\">    ...省去其他函数</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">class_ro_t</span> *<span class=\"title\">ro</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> v = get_ro_or_rwe();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowpath(v.is&lt;<span class=\"keyword\">class_rw_ext_t</span> *&gt;())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> v.<span class=\"built_in\">get</span>&lt;<span class=\"keyword\">class_rw_ext_t</span> *&gt;()-&gt;ro;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v.<span class=\"built_in\">get</span>&lt;<span class=\"keyword\">const</span> <span class=\"keyword\">class_ro_t</span> *&gt;();</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">method_array_t</span> <span class=\"title\">methods</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> v = get_ro_or_rwe();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v.is&lt;<span class=\"keyword\">class_rw_ext_t</span> *&gt;()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> v.<span class=\"built_in\">get</span>&lt;<span class=\"keyword\">class_rw_ext_t</span> *&gt;()-&gt;methods;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">method_array_t</span>&#123;v.<span class=\"built_in\">get</span>&lt;<span class=\"keyword\">const</span> <span class=\"keyword\">class_ro_t</span> *&gt;()-&gt;baseMethods()&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">property_array_t</span> <span class=\"title\">properties</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> v = get_ro_or_rwe();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v.is&lt;<span class=\"keyword\">class_rw_ext_t</span> *&gt;()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> v.<span class=\"built_in\">get</span>&lt;<span class=\"keyword\">class_rw_ext_t</span> *&gt;()-&gt;properties;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">property_array_t</span>&#123;v.<span class=\"built_in\">get</span>&lt;<span class=\"keyword\">const</span> <span class=\"keyword\">class_ro_t</span> *&gt;()-&gt;baseProperties&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">protocol_array_t</span> <span class=\"title\">protocols</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> v = get_ro_or_rwe();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v.is&lt;<span class=\"keyword\">class_rw_ext_t</span> *&gt;()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> v.<span class=\"built_in\">get</span>&lt;<span class=\"keyword\">class_rw_ext_t</span> *&gt;()-&gt;protocols;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">protocol_array_t</span>&#123;v.<span class=\"built_in\">get</span>&lt;<span class=\"keyword\">const</span> <span class=\"keyword\">class_ro_t</span> *&gt;()-&gt;baseProtocols&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>根据已获取的class_rw_t，调用结构体内部函数<code>methods()</code>、<code>properties()</code>、<code>protocols()</code>即可获取类的方法列表，属性列表以及协议列表。</p>\n"},{"title":"iOS 类的结构分析(二)","date":"2020-09-14T16:00:00.000Z","_content":"\n#### 1. 类对象获取\n```\nLSPerson *person = [[LSPerson alloc] init];\nNSLog(@\"[person class] = %@, isMetaClass=%d\", [person class], class_isMetaClass([person class]));\nNSLog(@\"[LSPerson class] = %@, isMetaClass=%d\", [LSPerson class], class_isMetaClass([LSPerson class]));\n\noutput:\n//[person class] = LSPerson, isMetaClass=0\n//[LSPerson class] = LSPerson, isMetaClass=0\n```\n根据以上代码可以看到不管是对象调用`class`方法还是类调用`class`方法，得到的都是类对象，且不是元类对象，那么`class`底层是如何实现的呢？\n\n`class`源码\n```\n+ (Class)class {\n    return self;\n}\n\n- (Class)class {\n    return object_getClass(self);\n}\n```\n可以看到`class`的类方法直接返回调用类的类对象；实例方法调用`object_getClass`且参数为实例对象。\n\n`object_getClass`源码\n```\nClass object_getClass(id obj)\n{\n    if (obj) return obj->getIsa();\n    else return Nil;\n}\n```\n获取当前对象的isa并返回，之前已经分析过对象的isa指向当前的类对象。\n> 总结：不管是对象调用`class`方法还是类调用`class`方法，返回的都是类对象。\n\n#### 2. 获取元类对象\n那么如何获取元类对象呢？在runtime中有`objc_getMetaClass(const char * _Nonnull name)`，参数是类名称的c语言字符串\n```\nconst char *className = [NSStringFromClass([LSPerson class]) UTF8String];\nClass metaClass = objc_getMetaClass(className);\n        \nNSLog(@\"LSPerson metaClass = %@, isMetaClass=%d\", metaClass, class_isMetaClass(metaClass));\n\noutput:\n//LSPerson metaClass = LSPerson, isMetaClass=1\n```\n`objc_getMetaClass`源码\n```\nClass objc_getMetaClass(const char *aClassName)\n{\n    Class cls;\n\n    if (!aClassName) return Nil;\n\n    //根据类对象名称字符串获取类对象\n    cls = objc_getClass (aClassName);\n    if (!cls)\n    {\n        _objc_inform (\"class `%s' not linked into application\", aClassName);\n        return Nil;\n    }\n\n    //返回类对象的isa指针指向 即元类对象\n    return cls->ISA();\n}\n```\n\n`objc_getClass`源码 根据字符串获取类\n```\nClass objc_getClass(const char *aClassName)\n{\n    if (!aClassName) return Nil;\n\n    // NO unconnected, YES class handler\n    return look_up_class(aClassName, NO, YES);\n}\n```\n\n#### 3. isKindOfClass和isMemberOfClass\n`isKindOfClass`的对象方法 和 类方法\n```\n- (BOOL)isKindOfClass:(Class)cls {\n    for (Class tcls = [self class]; tcls; tcls = tcls->superclass) {\n        if (tcls == cls) return YES;\n    }\n    return NO;\n}\n\n+ (BOOL)isKindOfClass:(Class)cls {\n    for (Class tcls = self->ISA(); tcls; tcls = tcls->superclass) {\n        if (tcls == cls) return YES;\n    }\n    return NO;\n}\n```\n> 分析：\n`- (BOOL)isKindOfClass:(Class)cls`对象方法,首先获取对象的类对象`tcls`和要比较的对象`cls`进行比较，如果不想等则递归比较`tcls`的父类。\n`+ (BOOL)isKindOfClass:(Class)cls`类方法，首先获取类的isa指针的指向，即元类`tcls`与要比较的`cls`进行比较，如果不想等，则递归查找`tcls`的父类进行比较\n\n`isMemberOfClass`的对象方法 和 类方法\n```\n- (BOOL)isMemberOfClass:(Class)cls {\n    return [self class] == cls;\n}\n\n+ (BOOL)isMemberOfClass:(Class)cls {\n    return self->ISA() == cls;\n}\n```\n> 分析：\n`- (BOOL)isMemberOfClass:(Class)cls`对象方法，比较对象的类对象和`cls`是否想等。\n`+ (BOOL)isMemberOfClass:(Class)cls`类方法，获取类对象的元类和`cls`比较是否想等。\n\n题目解析：\n```\n//---类方法调用\nBOOL re1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];\n//获取[NSObject class]的元类和[NSObject class]进行比较，不相等，则 \n//查找[NSObject class]的元类的父类，根元类的父类指向根类，都为 \n//[NSObject class]所以相等，结果为1\n\nBOOL re2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];     \n//获取[NSObject class]的元类和[NSObject class]比较，不相等，结果为0\n\nBOOL re3 = [(id)[LSPerson class] isKindOfClass:[LSPerson class]];  \n//获取[LSPerson class]的元类和[LSPerson class]进行比较，不相等\n//则查找[LSPerson class]的元类的父类为根元类，和[LSPerson class]进行比较，不相等\n//根元类的父类指向根类，和[LSPerson class]进行比较，不相等\n//根类的父类指向nil，结果为0\n\nBOOL re4 = [(id)[LSPerson class] isMemberOfClass:[LSPerson class]];       \n//获取[LSPerson class]的元类和[LSPerson class]比较，不相等，结果为0\n\n//---实例方法调用\nBOOL re5 = [(id)[NSObject alloc] isKindOfClass:[NSObject class]];\n//获取[NSObject alloc]的类对象[[NSObject alloc] class] 和 [NSObject class]比较相等，结果为1\n\nBOOL re6 = [(id)[NSObject alloc] isMemberOfClass:[NSObject class]];     \n//比较[NSObject alloc]的类对象[[NSObject alloc] class] 和 [NSObject class]相等，结果为1\n\nBOOL re7 = [(id)[LSPerson alloc] isKindOfClass:[LSPerson class]];\n//比较[LSPerson alloc]的类对象[[LSPerson alloc] class] 和 [LSPerson class]相等，结果为1\n\nBOOL re8 = [(id)[LSPerson alloc] isMemberOfClass:[LSPerson class]];       \n//比较[LSPerson alloc]的类对象[[LSPerson alloc] class] 和 [LSPerson class]相等，结果为1\n```\n> 注意：\n不管是根据断点源码还是根据查看汇编，在调用`isKindOfClass`时并没有走到`NSObject.mm`中的`isKindOfClass`对象方法和类方法，反而走的是`objc_opt_isKindOfClass`，这是因为llvm对一些不经常重写的方法进行了优化，如果重写了，则进行msgSend消息发送流程。\n\nllvm中对部分方法进行转发\n```\n// This is the table of ObjC \"accelerated dispatch\" functions.  They are a set\n// of objc methods that are \"seldom overridden\" and so the compiler replaces the\n// objc_msgSend with a call to one of the dispatch functions.  That will check\n// whether the method has been overridden, and directly call the Foundation \n// implementation if not.  \n// This table is supposed to be complete.  If ones get added in the future, we\n// will have to add them to the table.\nconst char *AppleObjCTrampolineHandler::g_opt_dispatch_names[] = {\n    \"objc_alloc\",\n    \"objc_autorelease\",\n    \"objc_release\",\n    \"objc_retain\",\n    \"objc_alloc_init\",\n    \"objc_allocWithZone\",\n    \"objc_opt_class\",\n    \"objc_opt_isKindOfClass\",\n    \"objc_opt_new\",\n    \"objc_opt_respondsToSelector\",\n    \"objc_opt_self\",\n};\n```\n\n`objc_opt_isKindOfClass`源码\n```\n// Calls [obj isKindOfClass]\nBOOL\nobjc_opt_isKindOfClass(id obj, Class otherClass)\n{\n#if __OBJC2__\n    printf(\"objc_opt_isKindOfClass(id obj, Class otherClass)\");\n    if (slowpath(!obj)) return NO;\n    Class cls = obj->getIsa();\n    if (fastpath(!cls->hasCustomCore())) {\n        for (Class tcls = cls; tcls; tcls = tcls->superclass) {\n            if (tcls == otherClass) return YES;\n        }\n        return NO;\n    }\n#endif\n    return ((BOOL(*)(id, SEL, Class))objc_msgSend)(obj, @selector(isKindOfClass:), otherClass);\n}\n```\n分析：如果是objc2，则根据传入对象的isa获取到`Class cls`，此处如果传入实例对象则获取类对象，如果传入类对象，则获取元类，然后递归`cls`及其父类，和`otherClass`进行比较。\n\n#### 4. `class_getClassMethod`底层实现\n```\nMethod class_getClassMethod(Class cls, SEL sel)\n{\n    if (!cls  ||  !sel) return nil;\n\n    return class_getInstanceMethod(cls->getMeta(), sel);\n}\n\nClass getMeta() {\n        if (isMetaClass()) return (Class)this;\n        else return this->ISA();\n    }\n```\n可以看到，获取类方法其实是根据类找到元类，然后去元类中找实例方法，从而侧面证明了，在OC中区分的对象方法和类方法，其实在C和C++层面并没有区分，都是方法，只是存储的位置不一样。\n\n`class_getInstanceMethod`源码\n```\nMethod class_getInstanceMethod(Class cls, SEL sel)\n{\n    if (!cls  ||  !sel) return nil;\n\n    // This deliberately avoids +initialize because it historically did so.\n\n    // This implementation is a bit weird because it's the only place that \n    // wants a Method instead of an IMP.\n\n#warning fixme build and search caches\n        \n    // Search method lists, try method resolver, etc.\n    lookUpImpOrForward(nil, sel, cls, LOOKUP_RESOLVER);\n\n#warning fixme build and search caches\n\n    return _class_getMethod(cls, sel);\n}\n\nstatic Method _class_getMethod(Class cls, SEL sel)\n{\n    mutex_locker_t lock(runtimeLock);\n    return getMethod_nolock(cls, sel);\n}\n\nstatic method_t *\ngetMethod_nolock(Class cls, SEL sel)\n{\n    method_t *m = nil;\n\n    runtimeLock.assertLocked();\n\n    // fixme nil cls?\n    // fixme nil sel?\n\n    ASSERT(cls->isRealized());\n    \n    while (cls  &&  ((m = getMethodNoSuper_nolock(cls, sel))) == nil) {\n        cls = cls->superclass;\n    }\n\n    return m;\n}\n```\n> 注意：while循环是从cls开始，递归其父类进行查找，所以如果在元类中查找类方法，直到根元类仍没有找到，则因为根元类的父类为根类即`NSObject`，如果在`NSObject`中实现了同名的对象方法，仍然不会报错。\n\n![image.png](https://upload-images.jianshu.io/upload_images/1395687-c5cdd8e3563b0fb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如上图所示，如果调用`[LSStudent  sleep];`,并不会报`unrecognized selector sent to class`的错误，反而会调用根类中的`- (void)sleep`实例方法。\n\n\n","source":"_posts/2020-09-15-iOS 类的结构分析(二).md","raw":"---\ntitle:      \"iOS 类的结构分析(二)\" \ndate:       2020-09-15\ntags:\n    - iOS底层原理\ncategories:\n    - iOS底层原理\n---\n\n#### 1. 类对象获取\n```\nLSPerson *person = [[LSPerson alloc] init];\nNSLog(@\"[person class] = %@, isMetaClass=%d\", [person class], class_isMetaClass([person class]));\nNSLog(@\"[LSPerson class] = %@, isMetaClass=%d\", [LSPerson class], class_isMetaClass([LSPerson class]));\n\noutput:\n//[person class] = LSPerson, isMetaClass=0\n//[LSPerson class] = LSPerson, isMetaClass=0\n```\n根据以上代码可以看到不管是对象调用`class`方法还是类调用`class`方法，得到的都是类对象，且不是元类对象，那么`class`底层是如何实现的呢？\n\n`class`源码\n```\n+ (Class)class {\n    return self;\n}\n\n- (Class)class {\n    return object_getClass(self);\n}\n```\n可以看到`class`的类方法直接返回调用类的类对象；实例方法调用`object_getClass`且参数为实例对象。\n\n`object_getClass`源码\n```\nClass object_getClass(id obj)\n{\n    if (obj) return obj->getIsa();\n    else return Nil;\n}\n```\n获取当前对象的isa并返回，之前已经分析过对象的isa指向当前的类对象。\n> 总结：不管是对象调用`class`方法还是类调用`class`方法，返回的都是类对象。\n\n#### 2. 获取元类对象\n那么如何获取元类对象呢？在runtime中有`objc_getMetaClass(const char * _Nonnull name)`，参数是类名称的c语言字符串\n```\nconst char *className = [NSStringFromClass([LSPerson class]) UTF8String];\nClass metaClass = objc_getMetaClass(className);\n        \nNSLog(@\"LSPerson metaClass = %@, isMetaClass=%d\", metaClass, class_isMetaClass(metaClass));\n\noutput:\n//LSPerson metaClass = LSPerson, isMetaClass=1\n```\n`objc_getMetaClass`源码\n```\nClass objc_getMetaClass(const char *aClassName)\n{\n    Class cls;\n\n    if (!aClassName) return Nil;\n\n    //根据类对象名称字符串获取类对象\n    cls = objc_getClass (aClassName);\n    if (!cls)\n    {\n        _objc_inform (\"class `%s' not linked into application\", aClassName);\n        return Nil;\n    }\n\n    //返回类对象的isa指针指向 即元类对象\n    return cls->ISA();\n}\n```\n\n`objc_getClass`源码 根据字符串获取类\n```\nClass objc_getClass(const char *aClassName)\n{\n    if (!aClassName) return Nil;\n\n    // NO unconnected, YES class handler\n    return look_up_class(aClassName, NO, YES);\n}\n```\n\n#### 3. isKindOfClass和isMemberOfClass\n`isKindOfClass`的对象方法 和 类方法\n```\n- (BOOL)isKindOfClass:(Class)cls {\n    for (Class tcls = [self class]; tcls; tcls = tcls->superclass) {\n        if (tcls == cls) return YES;\n    }\n    return NO;\n}\n\n+ (BOOL)isKindOfClass:(Class)cls {\n    for (Class tcls = self->ISA(); tcls; tcls = tcls->superclass) {\n        if (tcls == cls) return YES;\n    }\n    return NO;\n}\n```\n> 分析：\n`- (BOOL)isKindOfClass:(Class)cls`对象方法,首先获取对象的类对象`tcls`和要比较的对象`cls`进行比较，如果不想等则递归比较`tcls`的父类。\n`+ (BOOL)isKindOfClass:(Class)cls`类方法，首先获取类的isa指针的指向，即元类`tcls`与要比较的`cls`进行比较，如果不想等，则递归查找`tcls`的父类进行比较\n\n`isMemberOfClass`的对象方法 和 类方法\n```\n- (BOOL)isMemberOfClass:(Class)cls {\n    return [self class] == cls;\n}\n\n+ (BOOL)isMemberOfClass:(Class)cls {\n    return self->ISA() == cls;\n}\n```\n> 分析：\n`- (BOOL)isMemberOfClass:(Class)cls`对象方法，比较对象的类对象和`cls`是否想等。\n`+ (BOOL)isMemberOfClass:(Class)cls`类方法，获取类对象的元类和`cls`比较是否想等。\n\n题目解析：\n```\n//---类方法调用\nBOOL re1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];\n//获取[NSObject class]的元类和[NSObject class]进行比较，不相等，则 \n//查找[NSObject class]的元类的父类，根元类的父类指向根类，都为 \n//[NSObject class]所以相等，结果为1\n\nBOOL re2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];     \n//获取[NSObject class]的元类和[NSObject class]比较，不相等，结果为0\n\nBOOL re3 = [(id)[LSPerson class] isKindOfClass:[LSPerson class]];  \n//获取[LSPerson class]的元类和[LSPerson class]进行比较，不相等\n//则查找[LSPerson class]的元类的父类为根元类，和[LSPerson class]进行比较，不相等\n//根元类的父类指向根类，和[LSPerson class]进行比较，不相等\n//根类的父类指向nil，结果为0\n\nBOOL re4 = [(id)[LSPerson class] isMemberOfClass:[LSPerson class]];       \n//获取[LSPerson class]的元类和[LSPerson class]比较，不相等，结果为0\n\n//---实例方法调用\nBOOL re5 = [(id)[NSObject alloc] isKindOfClass:[NSObject class]];\n//获取[NSObject alloc]的类对象[[NSObject alloc] class] 和 [NSObject class]比较相等，结果为1\n\nBOOL re6 = [(id)[NSObject alloc] isMemberOfClass:[NSObject class]];     \n//比较[NSObject alloc]的类对象[[NSObject alloc] class] 和 [NSObject class]相等，结果为1\n\nBOOL re7 = [(id)[LSPerson alloc] isKindOfClass:[LSPerson class]];\n//比较[LSPerson alloc]的类对象[[LSPerson alloc] class] 和 [LSPerson class]相等，结果为1\n\nBOOL re8 = [(id)[LSPerson alloc] isMemberOfClass:[LSPerson class]];       \n//比较[LSPerson alloc]的类对象[[LSPerson alloc] class] 和 [LSPerson class]相等，结果为1\n```\n> 注意：\n不管是根据断点源码还是根据查看汇编，在调用`isKindOfClass`时并没有走到`NSObject.mm`中的`isKindOfClass`对象方法和类方法，反而走的是`objc_opt_isKindOfClass`，这是因为llvm对一些不经常重写的方法进行了优化，如果重写了，则进行msgSend消息发送流程。\n\nllvm中对部分方法进行转发\n```\n// This is the table of ObjC \"accelerated dispatch\" functions.  They are a set\n// of objc methods that are \"seldom overridden\" and so the compiler replaces the\n// objc_msgSend with a call to one of the dispatch functions.  That will check\n// whether the method has been overridden, and directly call the Foundation \n// implementation if not.  \n// This table is supposed to be complete.  If ones get added in the future, we\n// will have to add them to the table.\nconst char *AppleObjCTrampolineHandler::g_opt_dispatch_names[] = {\n    \"objc_alloc\",\n    \"objc_autorelease\",\n    \"objc_release\",\n    \"objc_retain\",\n    \"objc_alloc_init\",\n    \"objc_allocWithZone\",\n    \"objc_opt_class\",\n    \"objc_opt_isKindOfClass\",\n    \"objc_opt_new\",\n    \"objc_opt_respondsToSelector\",\n    \"objc_opt_self\",\n};\n```\n\n`objc_opt_isKindOfClass`源码\n```\n// Calls [obj isKindOfClass]\nBOOL\nobjc_opt_isKindOfClass(id obj, Class otherClass)\n{\n#if __OBJC2__\n    printf(\"objc_opt_isKindOfClass(id obj, Class otherClass)\");\n    if (slowpath(!obj)) return NO;\n    Class cls = obj->getIsa();\n    if (fastpath(!cls->hasCustomCore())) {\n        for (Class tcls = cls; tcls; tcls = tcls->superclass) {\n            if (tcls == otherClass) return YES;\n        }\n        return NO;\n    }\n#endif\n    return ((BOOL(*)(id, SEL, Class))objc_msgSend)(obj, @selector(isKindOfClass:), otherClass);\n}\n```\n分析：如果是objc2，则根据传入对象的isa获取到`Class cls`，此处如果传入实例对象则获取类对象，如果传入类对象，则获取元类，然后递归`cls`及其父类，和`otherClass`进行比较。\n\n#### 4. `class_getClassMethod`底层实现\n```\nMethod class_getClassMethod(Class cls, SEL sel)\n{\n    if (!cls  ||  !sel) return nil;\n\n    return class_getInstanceMethod(cls->getMeta(), sel);\n}\n\nClass getMeta() {\n        if (isMetaClass()) return (Class)this;\n        else return this->ISA();\n    }\n```\n可以看到，获取类方法其实是根据类找到元类，然后去元类中找实例方法，从而侧面证明了，在OC中区分的对象方法和类方法，其实在C和C++层面并没有区分，都是方法，只是存储的位置不一样。\n\n`class_getInstanceMethod`源码\n```\nMethod class_getInstanceMethod(Class cls, SEL sel)\n{\n    if (!cls  ||  !sel) return nil;\n\n    // This deliberately avoids +initialize because it historically did so.\n\n    // This implementation is a bit weird because it's the only place that \n    // wants a Method instead of an IMP.\n\n#warning fixme build and search caches\n        \n    // Search method lists, try method resolver, etc.\n    lookUpImpOrForward(nil, sel, cls, LOOKUP_RESOLVER);\n\n#warning fixme build and search caches\n\n    return _class_getMethod(cls, sel);\n}\n\nstatic Method _class_getMethod(Class cls, SEL sel)\n{\n    mutex_locker_t lock(runtimeLock);\n    return getMethod_nolock(cls, sel);\n}\n\nstatic method_t *\ngetMethod_nolock(Class cls, SEL sel)\n{\n    method_t *m = nil;\n\n    runtimeLock.assertLocked();\n\n    // fixme nil cls?\n    // fixme nil sel?\n\n    ASSERT(cls->isRealized());\n    \n    while (cls  &&  ((m = getMethodNoSuper_nolock(cls, sel))) == nil) {\n        cls = cls->superclass;\n    }\n\n    return m;\n}\n```\n> 注意：while循环是从cls开始，递归其父类进行查找，所以如果在元类中查找类方法，直到根元类仍没有找到，则因为根元类的父类为根类即`NSObject`，如果在`NSObject`中实现了同名的对象方法，仍然不会报错。\n\n![image.png](https://upload-images.jianshu.io/upload_images/1395687-c5cdd8e3563b0fb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如上图所示，如果调用`[LSStudent  sleep];`,并不会报`unrecognized selector sent to class`的错误，反而会调用根类中的`- (void)sleep`实例方法。\n\n\n","slug":"2020-09-15-iOS 类的结构分析(二)","published":1,"updated":"2021-06-19T03:46:24.087Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbpx001pbjrj4cj346b0","content":"<h4 id=\"1-类对象获取\"><a href=\"#1-类对象获取\" class=\"headerlink\" title=\"1. 类对象获取\"></a>1. 类对象获取</h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LSPerson *person = [[LSPerson alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">NSLog(@<span class=\"string\">&quot;[person class] = %@, isMetaClass=%d&quot;</span>, [person <span class=\"class\"><span class=\"keyword\">class</span>], <span class=\"type\">class_isMetaClass</span></span>([person <span class=\"class\"><span class=\"keyword\">class</span>]));</span></span><br><span class=\"line\">NSLog(@<span class=\"string\">&quot;[LSPerson class] = %@, isMetaClass=%d&quot;</span>, [LSPerson <span class=\"class\"><span class=\"keyword\">class</span>], <span class=\"type\">class_isMetaClass</span></span>([LSPerson <span class=\"class\"><span class=\"keyword\">class</span>]));</span></span><br><span class=\"line\"></span><br><span class=\"line\">output:</span><br><span class=\"line\"><span class=\"comment\">//[person class] = LSPerson, isMetaClass=0</span></span><br><span class=\"line\"><span class=\"comment\">//[LSPerson class] = LSPerson, isMetaClass=0</span></span><br></pre></td></tr></table></figure>\n<p>根据以上代码可以看到不管是对象调用<code>class</code>方法还是类调用<code>class</code>方法，得到的都是类对象，且不是元类对象，那么<code>class</code>底层是如何实现的呢？</p>\n<p><code>class</code>源码</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (Class)<span class=\"class\"><span class=\"keyword\">class</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (Class)<span class=\"class\"><span class=\"keyword\">class</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> object_getClass(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到<code>class</code>的类方法直接返回调用类的类对象；实例方法调用<code>object_getClass</code>且参数为实例对象。</p>\n<p><code>object_getClass</code>源码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class object_getClass(id obj)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) <span class=\"keyword\">return</span> obj-&gt;getIsa();</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> Nil;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取当前对象的isa并返回，之前已经分析过对象的isa指向当前的类对象。</p>\n<blockquote>\n<p>总结：不管是对象调用<code>class</code>方法还是类调用<code>class</code>方法，返回的都是类对象。</p>\n</blockquote>\n<h4 id=\"2-获取元类对象\"><a href=\"#2-获取元类对象\" class=\"headerlink\" title=\"2. 获取元类对象\"></a>2. 获取元类对象</h4><p>那么如何获取元类对象呢？在runtime中有<code>objc_getMetaClass(const char * _Nonnull name)</code>，参数是类名称的c语言字符串</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const <span class=\"built_in\">char</span> *className = <span class=\"literal\">[NSS<span class=\"identifier\">tringFromClass</span>([LSP<span class=\"identifier\">erson</span> <span class=\"identifier\">class</span>]</span>) UTF8String];</span><br><span class=\"line\">Class metaClass = objc<span class=\"constructor\">_getMetaClass(<span class=\"params\">className</span>)</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"constructor\">NSLog(@<span class=\"string\">&quot;LSPerson metaClass = %@, isMetaClass=%d&quot;</span>, <span class=\"params\">metaClass</span>, <span class=\"params\">class_isMetaClass</span>(<span class=\"params\">metaClass</span>)</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">output:</span><br><span class=\"line\"><span class=\"comment\">//LSPerson metaClass = LSPerson, isMetaClass=1</span></span><br></pre></td></tr></table></figure>\n<p><code>objc_getMetaClass</code>源码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class objc_getMetaClass(<span class=\"keyword\">const</span> char *aClassName)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Class cls;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!aClassName) <span class=\"keyword\">return</span> Nil;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//根据类对象名称字符串获取类对象</span></span><br><span class=\"line\">    cls = objc_getClass (aClassName);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cls)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _objc_inform (<span class=\"string\">&quot;class `%s&#x27; not linked into application&quot;</span>, aClassName);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//返回类对象的isa指针指向 即元类对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cls-&gt;ISA();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>objc_getClass</code>源码 根据字符串获取类</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Class</span> objc_getClass(const <span class=\"type\">char</span> *aClassName)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!aClassName) <span class=\"keyword\">return</span> Nil;</span><br><span class=\"line\"></span><br><span class=\"line\">    // <span class=\"keyword\">NO</span> unconnected, YES <span class=\"keyword\">class</span> <span class=\"keyword\">handler</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> look_up_class(aClassName, <span class=\"keyword\">NO</span>, YES);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-isKindOfClass和isMemberOfClass\"><a href=\"#3-isKindOfClass和isMemberOfClass\" class=\"headerlink\" title=\"3. isKindOfClass和isMemberOfClass\"></a>3. isKindOfClass和isMemberOfClass</h4><p><code>isKindOfClass</code>的对象方法 和 类方法</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Class tcls = [<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tcls == cls) <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Class tcls = <span class=\"keyword\">self</span>-&gt;ISA(); tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tcls == cls) <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>分析：<br><code>- (BOOL)isKindOfClass:(Class)cls</code>对象方法,首先获取对象的类对象<code>tcls</code>和要比较的对象<code>cls</code>进行比较，如果不想等则递归比较<code>tcls</code>的父类。<br><code>+ (BOOL)isKindOfClass:(Class)cls</code>类方法，首先获取类的isa指针的指向，即元类<code>tcls</code>与要比较的<code>cls</code>进行比较，如果不想等，则递归查找<code>tcls</code>的父类进行比较</p>\n</blockquote>\n<p><code>isMemberOfClass</code>的对象方法 和 类方法</p>\n<figure class=\"highlight monkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)isMemberOfClass:(<span class=\"class\"><span class=\"keyword\">Class</span>)<span class=\"title\">cls</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">self</span> <span class=\"class\"><span class=\"keyword\">class</span>] == <span class=\"title\">cls</span>;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (BOOL)isMemberOfClass:(<span class=\"class\"><span class=\"keyword\">Class</span>)<span class=\"title\">cls</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">self</span>-&gt;ISA() == cls;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>分析：<br><code>- (BOOL)isMemberOfClass:(Class)cls</code>对象方法，比较对象的类对象和<code>cls</code>是否想等。<br><code>+ (BOOL)isMemberOfClass:(Class)cls</code>类方法，获取类对象的元类和<code>cls</code>比较是否想等。</p>\n</blockquote>\n<p>题目解析：</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//---类方法调用</span><br><span class=\"line\">BOOL re1 = <span class=\"comment\">[(id)<span class=\"comment\">[NSObject class]</span> isKindOfClass:<span class=\"comment\">[NSObject class]</span>]</span>;</span><br><span class=\"line\">//获取<span class=\"comment\">[NSObject class]</span>的元类和<span class=\"comment\">[NSObject class]</span>进行比较，不相等，则 </span><br><span class=\"line\">//查找<span class=\"comment\">[NSObject class]</span>的元类的父类，根元类的父类指向根类，都为 </span><br><span class=\"line\">//<span class=\"comment\">[NSObject class]</span>所以相等，结果为1</span><br><span class=\"line\"></span><br><span class=\"line\">BOOL re2 = <span class=\"comment\">[(id)<span class=\"comment\">[NSObject class]</span> isMemberOfClass:<span class=\"comment\">[NSObject class]</span>]</span>;     </span><br><span class=\"line\">//获取<span class=\"comment\">[NSObject class]</span>的元类和<span class=\"comment\">[NSObject class]</span>比较，不相等，结果为0</span><br><span class=\"line\"></span><br><span class=\"line\">BOOL re3 = <span class=\"comment\">[(id)<span class=\"comment\">[LSPerson class]</span> isKindOfClass:<span class=\"comment\">[LSPerson class]</span>]</span>;  </span><br><span class=\"line\">//获取<span class=\"comment\">[LSPerson class]</span>的元类和<span class=\"comment\">[LSPerson class]</span>进行比较，不相等</span><br><span class=\"line\">//则查找<span class=\"comment\">[LSPerson class]</span>的元类的父类为根元类，和<span class=\"comment\">[LSPerson class]</span>进行比较，不相等</span><br><span class=\"line\">//根元类的父类指向根类，和<span class=\"comment\">[LSPerson class]</span>进行比较，不相等</span><br><span class=\"line\">//根类的父类指向nil，结果为0</span><br><span class=\"line\"></span><br><span class=\"line\">BOOL re4 = <span class=\"comment\">[(id)<span class=\"comment\">[LSPerson class]</span> isMemberOfClass:<span class=\"comment\">[LSPerson class]</span>]</span>;       </span><br><span class=\"line\">//获取<span class=\"comment\">[LSPerson class]</span>的元类和<span class=\"comment\">[LSPerson class]</span>比较，不相等，结果为0</span><br><span class=\"line\"></span><br><span class=\"line\">//---实例方法调用</span><br><span class=\"line\">BOOL re5 = <span class=\"comment\">[(id)<span class=\"comment\">[NSObject alloc]</span> isKindOfClass:<span class=\"comment\">[NSObject class]</span>]</span>;</span><br><span class=\"line\">//获取<span class=\"comment\">[NSObject alloc]</span>的类对象<span class=\"comment\">[<span class=\"comment\">[NSObject alloc]</span> class]</span> 和 <span class=\"comment\">[NSObject class]</span>比较相等，结果为1</span><br><span class=\"line\"></span><br><span class=\"line\">BOOL re6 = <span class=\"comment\">[(id)<span class=\"comment\">[NSObject alloc]</span> isMemberOfClass:<span class=\"comment\">[NSObject class]</span>]</span>;     </span><br><span class=\"line\">//比较<span class=\"comment\">[NSObject alloc]</span>的类对象<span class=\"comment\">[<span class=\"comment\">[NSObject alloc]</span> class]</span> 和 <span class=\"comment\">[NSObject class]</span>相等，结果为1</span><br><span class=\"line\"></span><br><span class=\"line\">BOOL re7 = <span class=\"comment\">[(id)<span class=\"comment\">[LSPerson alloc]</span> isKindOfClass:<span class=\"comment\">[LSPerson class]</span>]</span>;</span><br><span class=\"line\">//比较<span class=\"comment\">[LSPerson alloc]</span>的类对象<span class=\"comment\">[<span class=\"comment\">[LSPerson alloc]</span> class]</span> 和 <span class=\"comment\">[LSPerson class]</span>相等，结果为1</span><br><span class=\"line\"></span><br><span class=\"line\">BOOL re8 = <span class=\"comment\">[(id)<span class=\"comment\">[LSPerson alloc]</span> isMemberOfClass:<span class=\"comment\">[LSPerson class]</span>]</span>;       </span><br><span class=\"line\">//比较<span class=\"comment\">[LSPerson alloc]</span>的类对象<span class=\"comment\">[<span class=\"comment\">[LSPerson alloc]</span> class]</span> 和 <span class=\"comment\">[LSPerson class]</span>相等，结果为1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：<br>不管是根据断点源码还是根据查看汇编，在调用<code>isKindOfClass</code>时并没有走到<code>NSObject.mm</code>中的<code>isKindOfClass</code>对象方法和类方法，反而走的是<code>objc_opt_isKindOfClass</code>，这是因为llvm对一些不经常重写的方法进行了优化，如果重写了，则进行msgSend消息发送流程。</p>\n</blockquote>\n<p>llvm中对部分方法进行转发</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// This is the table of ObjC &quot;accelerated dispatch&quot; functions.  They are a set</span></span><br><span class=\"line\"><span class=\"comment\">// of objc methods that are &quot;seldom overridden&quot; and so the compiler replaces the</span></span><br><span class=\"line\"><span class=\"comment\">// objc_msgSend with a call to one of the dispatch functions.  That will check</span></span><br><span class=\"line\"><span class=\"comment\">// whether the method has been overridden, and directly call the Foundation </span></span><br><span class=\"line\"><span class=\"comment\">// implementation if not.  </span></span><br><span class=\"line\"><span class=\"comment\">// This table is supposed to be complete.  If ones get added in the future, we</span></span><br><span class=\"line\"><span class=\"comment\">// will have to add them to the table.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *AppleObjCTrampolineHandler::g_opt_dispatch_names[] = &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;objc_alloc&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;objc_autorelease&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;objc_release&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;objc_retain&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;objc_alloc_init&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;objc_allocWithZone&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;objc_opt_class&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;objc_opt_isKindOfClass&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;objc_opt_new&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;objc_opt_respondsToSelector&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;objc_opt_self&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>objc_opt_isKindOfClass</code>源码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Calls [obj isKindOfClass]</span></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span></span><br><span class=\"line\">objc_opt_isKindOfClass(<span class=\"keyword\">id</span> obj, Class otherClass)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> __OBJC2__</span></span><br><span class=\"line\">    printf(<span class=\"string\">&quot;objc_opt_isKindOfClass(id obj, Class otherClass)&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(!obj)) <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    Class cls = obj-&gt;getIsa();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fastpath(!cls-&gt;hasCustomCore())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Class tcls = cls; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tcls == otherClass) <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((<span class=\"built_in\">BOOL</span>(*)(<span class=\"keyword\">id</span>, SEL, Class))objc_msgSend)(obj, <span class=\"keyword\">@selector</span>(isKindOfClass:), otherClass);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析：如果是objc2，则根据传入对象的isa获取到<code>Class cls</code>，此处如果传入实例对象则获取类对象，如果传入类对象，则获取元类，然后递归<code>cls</code>及其父类，和<code>otherClass</code>进行比较。</p>\n<h4 id=\"4-class-getClassMethod底层实现\"><a href=\"#4-class-getClassMethod底层实现\" class=\"headerlink\" title=\"4. class_getClassMethod底层实现\"></a>4. <code>class_getClassMethod</code>底层实现</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method class_getClassMethod(Class cls, SEL sel)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cls  ||  !sel) <span class=\"keyword\">return</span> nil;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> class_getInstanceMethod(cls-&gt;getMeta(), sel);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Class <span class=\"function\"><span class=\"title\">getMeta</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isMetaClass()) <span class=\"keyword\">return</span> (Class)<span class=\"built_in\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>-&gt;ISA();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，获取类方法其实是根据类找到元类，然后去元类中找实例方法，从而侧面证明了，在OC中区分的对象方法和类方法，其实在C和C++层面并没有区分，都是方法，只是存储的位置不一样。</p>\n<p><code>class_getInstanceMethod</code>源码</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method <span class=\"keyword\">class</span><span class=\"constructor\">_getInstanceMethod(Class <span class=\"params\">cls</span>, SEL <span class=\"params\">sel</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cls<span class=\"operator\">  ||  </span>!sel) return nil;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// This deliberately avoids +initialize because it historically did so.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// This implementation is a bit weird because it&#x27;s the only place that </span></span><br><span class=\"line\">    <span class=\"comment\">// wants a Method instead of an IMP.</span></span><br><span class=\"line\"></span><br><span class=\"line\">#warning fixme build <span class=\"keyword\">and</span> search caches</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">// Search method lists, try method resolver, etc.</span></span><br><span class=\"line\">    look<span class=\"constructor\">UpImpOrForward(<span class=\"params\">nil</span>, <span class=\"params\">sel</span>, <span class=\"params\">cls</span>, LOOKUP_RESOLVER)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#warning fixme build <span class=\"keyword\">and</span> search caches</span><br><span class=\"line\"></span><br><span class=\"line\">    return <span class=\"constructor\">_class_getMethod(<span class=\"params\">cls</span>, <span class=\"params\">sel</span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static Method <span class=\"constructor\">_class_getMethod(Class <span class=\"params\">cls</span>, SEL <span class=\"params\">sel</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    mutex_locker_t lock(runtimeLock);</span><br><span class=\"line\">    return get<span class=\"constructor\">Method_nolock(<span class=\"params\">cls</span>, <span class=\"params\">sel</span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static method_t *</span><br><span class=\"line\">get<span class=\"constructor\">Method_nolock(Class <span class=\"params\">cls</span>, SEL <span class=\"params\">sel</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    method_t *m = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">    runtimeLock.<span class=\"keyword\">assert</span><span class=\"constructor\">Locked()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// fixme nil cls?</span></span><br><span class=\"line\">    <span class=\"comment\">// fixme nil sel?</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"constructor\">ASSERT(<span class=\"params\">cls</span>-&gt;<span class=\"params\">isRealized</span>()</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cls<span class=\"operator\">  &amp;&amp;  </span>((m = get<span class=\"constructor\">MethodNoSuper_nolock(<span class=\"params\">cls</span>, <span class=\"params\">sel</span>)</span>))<span class=\"operator\"> == </span>nil) &#123;</span><br><span class=\"line\">        cls = cls-&gt;superclass;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return m;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：while循环是从cls开始，递归其父类进行查找，所以如果在元类中查找类方法，直到根元类仍没有找到，则因为根元类的父类为根类即<code>NSObject</code>，如果在<code>NSObject</code>中实现了同名的对象方法，仍然不会报错。</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-c5cdd8e3563b0fb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>如上图所示，如果调用<code>[LSStudent  sleep];</code>,并不会报<code>unrecognized selector sent to class</code>的错误，反而会调用根类中的<code>- (void)sleep</code>实例方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1-类对象获取\"><a href=\"#1-类对象获取\" class=\"headerlink\" title=\"1. 类对象获取\"></a>1. 类对象获取</h4><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LSPerson *person = [[LSPerson alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">NSLog(@<span class=\"string\">&quot;[person class] = %@, isMetaClass=%d&quot;</span>, [person <span class=\"class\"><span class=\"keyword\">class</span>], <span class=\"type\">class_isMetaClass</span></span>([person <span class=\"class\"><span class=\"keyword\">class</span>]));</span></span><br><span class=\"line\">NSLog(@<span class=\"string\">&quot;[LSPerson class] = %@, isMetaClass=%d&quot;</span>, [LSPerson <span class=\"class\"><span class=\"keyword\">class</span>], <span class=\"type\">class_isMetaClass</span></span>([LSPerson <span class=\"class\"><span class=\"keyword\">class</span>]));</span></span><br><span class=\"line\"></span><br><span class=\"line\">output:</span><br><span class=\"line\"><span class=\"comment\">//[person class] = LSPerson, isMetaClass=0</span></span><br><span class=\"line\"><span class=\"comment\">//[LSPerson class] = LSPerson, isMetaClass=0</span></span><br></pre></td></tr></table></figure>\n<p>根据以上代码可以看到不管是对象调用<code>class</code>方法还是类调用<code>class</code>方法，得到的都是类对象，且不是元类对象，那么<code>class</code>底层是如何实现的呢？</p>\n<p><code>class</code>源码</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (Class)<span class=\"class\"><span class=\"keyword\">class</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (Class)<span class=\"class\"><span class=\"keyword\">class</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> object_getClass(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到<code>class</code>的类方法直接返回调用类的类对象；实例方法调用<code>object_getClass</code>且参数为实例对象。</p>\n<p><code>object_getClass</code>源码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class object_getClass(id obj)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) <span class=\"keyword\">return</span> obj-&gt;getIsa();</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> Nil;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取当前对象的isa并返回，之前已经分析过对象的isa指向当前的类对象。</p>\n<blockquote>\n<p>总结：不管是对象调用<code>class</code>方法还是类调用<code>class</code>方法，返回的都是类对象。</p>\n</blockquote>\n<h4 id=\"2-获取元类对象\"><a href=\"#2-获取元类对象\" class=\"headerlink\" title=\"2. 获取元类对象\"></a>2. 获取元类对象</h4><p>那么如何获取元类对象呢？在runtime中有<code>objc_getMetaClass(const char * _Nonnull name)</code>，参数是类名称的c语言字符串</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const <span class=\"built_in\">char</span> *className = <span class=\"literal\">[NSS<span class=\"identifier\">tringFromClass</span>([LSP<span class=\"identifier\">erson</span> <span class=\"identifier\">class</span>]</span>) UTF8String];</span><br><span class=\"line\">Class metaClass = objc<span class=\"constructor\">_getMetaClass(<span class=\"params\">className</span>)</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"constructor\">NSLog(@<span class=\"string\">&quot;LSPerson metaClass = %@, isMetaClass=%d&quot;</span>, <span class=\"params\">metaClass</span>, <span class=\"params\">class_isMetaClass</span>(<span class=\"params\">metaClass</span>)</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">output:</span><br><span class=\"line\"><span class=\"comment\">//LSPerson metaClass = LSPerson, isMetaClass=1</span></span><br></pre></td></tr></table></figure>\n<p><code>objc_getMetaClass</code>源码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class objc_getMetaClass(<span class=\"keyword\">const</span> char *aClassName)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Class cls;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!aClassName) <span class=\"keyword\">return</span> Nil;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//根据类对象名称字符串获取类对象</span></span><br><span class=\"line\">    cls = objc_getClass (aClassName);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cls)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        _objc_inform (<span class=\"string\">&quot;class `%s&#x27; not linked into application&quot;</span>, aClassName);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//返回类对象的isa指针指向 即元类对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cls-&gt;ISA();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>objc_getClass</code>源码 根据字符串获取类</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Class</span> objc_getClass(const <span class=\"type\">char</span> *aClassName)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!aClassName) <span class=\"keyword\">return</span> Nil;</span><br><span class=\"line\"></span><br><span class=\"line\">    // <span class=\"keyword\">NO</span> unconnected, YES <span class=\"keyword\">class</span> <span class=\"keyword\">handler</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> look_up_class(aClassName, <span class=\"keyword\">NO</span>, YES);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-isKindOfClass和isMemberOfClass\"><a href=\"#3-isKindOfClass和isMemberOfClass\" class=\"headerlink\" title=\"3. isKindOfClass和isMemberOfClass\"></a>3. isKindOfClass和isMemberOfClass</h4><p><code>isKindOfClass</code>的对象方法 和 类方法</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Class tcls = [<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tcls == cls) <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Class tcls = <span class=\"keyword\">self</span>-&gt;ISA(); tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tcls == cls) <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>分析：<br><code>- (BOOL)isKindOfClass:(Class)cls</code>对象方法,首先获取对象的类对象<code>tcls</code>和要比较的对象<code>cls</code>进行比较，如果不想等则递归比较<code>tcls</code>的父类。<br><code>+ (BOOL)isKindOfClass:(Class)cls</code>类方法，首先获取类的isa指针的指向，即元类<code>tcls</code>与要比较的<code>cls</code>进行比较，如果不想等，则递归查找<code>tcls</code>的父类进行比较</p>\n</blockquote>\n<p><code>isMemberOfClass</code>的对象方法 和 类方法</p>\n<figure class=\"highlight monkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)isMemberOfClass:(<span class=\"class\"><span class=\"keyword\">Class</span>)<span class=\"title\">cls</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">self</span> <span class=\"class\"><span class=\"keyword\">class</span>] == <span class=\"title\">cls</span>;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (BOOL)isMemberOfClass:(<span class=\"class\"><span class=\"keyword\">Class</span>)<span class=\"title\">cls</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">self</span>-&gt;ISA() == cls;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>分析：<br><code>- (BOOL)isMemberOfClass:(Class)cls</code>对象方法，比较对象的类对象和<code>cls</code>是否想等。<br><code>+ (BOOL)isMemberOfClass:(Class)cls</code>类方法，获取类对象的元类和<code>cls</code>比较是否想等。</p>\n</blockquote>\n<p>题目解析：</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//---类方法调用</span><br><span class=\"line\">BOOL re1 = <span class=\"comment\">[(id)<span class=\"comment\">[NSObject class]</span> isKindOfClass:<span class=\"comment\">[NSObject class]</span>]</span>;</span><br><span class=\"line\">//获取<span class=\"comment\">[NSObject class]</span>的元类和<span class=\"comment\">[NSObject class]</span>进行比较，不相等，则 </span><br><span class=\"line\">//查找<span class=\"comment\">[NSObject class]</span>的元类的父类，根元类的父类指向根类，都为 </span><br><span class=\"line\">//<span class=\"comment\">[NSObject class]</span>所以相等，结果为1</span><br><span class=\"line\"></span><br><span class=\"line\">BOOL re2 = <span class=\"comment\">[(id)<span class=\"comment\">[NSObject class]</span> isMemberOfClass:<span class=\"comment\">[NSObject class]</span>]</span>;     </span><br><span class=\"line\">//获取<span class=\"comment\">[NSObject class]</span>的元类和<span class=\"comment\">[NSObject class]</span>比较，不相等，结果为0</span><br><span class=\"line\"></span><br><span class=\"line\">BOOL re3 = <span class=\"comment\">[(id)<span class=\"comment\">[LSPerson class]</span> isKindOfClass:<span class=\"comment\">[LSPerson class]</span>]</span>;  </span><br><span class=\"line\">//获取<span class=\"comment\">[LSPerson class]</span>的元类和<span class=\"comment\">[LSPerson class]</span>进行比较，不相等</span><br><span class=\"line\">//则查找<span class=\"comment\">[LSPerson class]</span>的元类的父类为根元类，和<span class=\"comment\">[LSPerson class]</span>进行比较，不相等</span><br><span class=\"line\">//根元类的父类指向根类，和<span class=\"comment\">[LSPerson class]</span>进行比较，不相等</span><br><span class=\"line\">//根类的父类指向nil，结果为0</span><br><span class=\"line\"></span><br><span class=\"line\">BOOL re4 = <span class=\"comment\">[(id)<span class=\"comment\">[LSPerson class]</span> isMemberOfClass:<span class=\"comment\">[LSPerson class]</span>]</span>;       </span><br><span class=\"line\">//获取<span class=\"comment\">[LSPerson class]</span>的元类和<span class=\"comment\">[LSPerson class]</span>比较，不相等，结果为0</span><br><span class=\"line\"></span><br><span class=\"line\">//---实例方法调用</span><br><span class=\"line\">BOOL re5 = <span class=\"comment\">[(id)<span class=\"comment\">[NSObject alloc]</span> isKindOfClass:<span class=\"comment\">[NSObject class]</span>]</span>;</span><br><span class=\"line\">//获取<span class=\"comment\">[NSObject alloc]</span>的类对象<span class=\"comment\">[<span class=\"comment\">[NSObject alloc]</span> class]</span> 和 <span class=\"comment\">[NSObject class]</span>比较相等，结果为1</span><br><span class=\"line\"></span><br><span class=\"line\">BOOL re6 = <span class=\"comment\">[(id)<span class=\"comment\">[NSObject alloc]</span> isMemberOfClass:<span class=\"comment\">[NSObject class]</span>]</span>;     </span><br><span class=\"line\">//比较<span class=\"comment\">[NSObject alloc]</span>的类对象<span class=\"comment\">[<span class=\"comment\">[NSObject alloc]</span> class]</span> 和 <span class=\"comment\">[NSObject class]</span>相等，结果为1</span><br><span class=\"line\"></span><br><span class=\"line\">BOOL re7 = <span class=\"comment\">[(id)<span class=\"comment\">[LSPerson alloc]</span> isKindOfClass:<span class=\"comment\">[LSPerson class]</span>]</span>;</span><br><span class=\"line\">//比较<span class=\"comment\">[LSPerson alloc]</span>的类对象<span class=\"comment\">[<span class=\"comment\">[LSPerson alloc]</span> class]</span> 和 <span class=\"comment\">[LSPerson class]</span>相等，结果为1</span><br><span class=\"line\"></span><br><span class=\"line\">BOOL re8 = <span class=\"comment\">[(id)<span class=\"comment\">[LSPerson alloc]</span> isMemberOfClass:<span class=\"comment\">[LSPerson class]</span>]</span>;       </span><br><span class=\"line\">//比较<span class=\"comment\">[LSPerson alloc]</span>的类对象<span class=\"comment\">[<span class=\"comment\">[LSPerson alloc]</span> class]</span> 和 <span class=\"comment\">[LSPerson class]</span>相等，结果为1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：<br>不管是根据断点源码还是根据查看汇编，在调用<code>isKindOfClass</code>时并没有走到<code>NSObject.mm</code>中的<code>isKindOfClass</code>对象方法和类方法，反而走的是<code>objc_opt_isKindOfClass</code>，这是因为llvm对一些不经常重写的方法进行了优化，如果重写了，则进行msgSend消息发送流程。</p>\n</blockquote>\n<p>llvm中对部分方法进行转发</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// This is the table of ObjC &quot;accelerated dispatch&quot; functions.  They are a set</span></span><br><span class=\"line\"><span class=\"comment\">// of objc methods that are &quot;seldom overridden&quot; and so the compiler replaces the</span></span><br><span class=\"line\"><span class=\"comment\">// objc_msgSend with a call to one of the dispatch functions.  That will check</span></span><br><span class=\"line\"><span class=\"comment\">// whether the method has been overridden, and directly call the Foundation </span></span><br><span class=\"line\"><span class=\"comment\">// implementation if not.  </span></span><br><span class=\"line\"><span class=\"comment\">// This table is supposed to be complete.  If ones get added in the future, we</span></span><br><span class=\"line\"><span class=\"comment\">// will have to add them to the table.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *AppleObjCTrampolineHandler::g_opt_dispatch_names[] = &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;objc_alloc&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;objc_autorelease&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;objc_release&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;objc_retain&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;objc_alloc_init&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;objc_allocWithZone&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;objc_opt_class&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;objc_opt_isKindOfClass&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;objc_opt_new&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;objc_opt_respondsToSelector&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;objc_opt_self&quot;</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>objc_opt_isKindOfClass</code>源码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Calls [obj isKindOfClass]</span></span><br><span class=\"line\"><span class=\"built_in\">BOOL</span></span><br><span class=\"line\">objc_opt_isKindOfClass(<span class=\"keyword\">id</span> obj, Class otherClass)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> __OBJC2__</span></span><br><span class=\"line\">    printf(<span class=\"string\">&quot;objc_opt_isKindOfClass(id obj, Class otherClass)&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(!obj)) <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    Class cls = obj-&gt;getIsa();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fastpath(!cls-&gt;hasCustomCore())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Class tcls = cls; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tcls == otherClass) <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((<span class=\"built_in\">BOOL</span>(*)(<span class=\"keyword\">id</span>, SEL, Class))objc_msgSend)(obj, <span class=\"keyword\">@selector</span>(isKindOfClass:), otherClass);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析：如果是objc2，则根据传入对象的isa获取到<code>Class cls</code>，此处如果传入实例对象则获取类对象，如果传入类对象，则获取元类，然后递归<code>cls</code>及其父类，和<code>otherClass</code>进行比较。</p>\n<h4 id=\"4-class-getClassMethod底层实现\"><a href=\"#4-class-getClassMethod底层实现\" class=\"headerlink\" title=\"4. class_getClassMethod底层实现\"></a>4. <code>class_getClassMethod</code>底层实现</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method class_getClassMethod(Class cls, SEL sel)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cls  ||  !sel) <span class=\"keyword\">return</span> nil;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> class_getInstanceMethod(cls-&gt;getMeta(), sel);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Class <span class=\"function\"><span class=\"title\">getMeta</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isMetaClass()) <span class=\"keyword\">return</span> (Class)<span class=\"built_in\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>-&gt;ISA();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，获取类方法其实是根据类找到元类，然后去元类中找实例方法，从而侧面证明了，在OC中区分的对象方法和类方法，其实在C和C++层面并没有区分，都是方法，只是存储的位置不一样。</p>\n<p><code>class_getInstanceMethod</code>源码</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method <span class=\"keyword\">class</span><span class=\"constructor\">_getInstanceMethod(Class <span class=\"params\">cls</span>, SEL <span class=\"params\">sel</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cls<span class=\"operator\">  ||  </span>!sel) return nil;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// This deliberately avoids +initialize because it historically did so.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// This implementation is a bit weird because it&#x27;s the only place that </span></span><br><span class=\"line\">    <span class=\"comment\">// wants a Method instead of an IMP.</span></span><br><span class=\"line\"></span><br><span class=\"line\">#warning fixme build <span class=\"keyword\">and</span> search caches</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">// Search method lists, try method resolver, etc.</span></span><br><span class=\"line\">    look<span class=\"constructor\">UpImpOrForward(<span class=\"params\">nil</span>, <span class=\"params\">sel</span>, <span class=\"params\">cls</span>, LOOKUP_RESOLVER)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#warning fixme build <span class=\"keyword\">and</span> search caches</span><br><span class=\"line\"></span><br><span class=\"line\">    return <span class=\"constructor\">_class_getMethod(<span class=\"params\">cls</span>, <span class=\"params\">sel</span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static Method <span class=\"constructor\">_class_getMethod(Class <span class=\"params\">cls</span>, SEL <span class=\"params\">sel</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    mutex_locker_t lock(runtimeLock);</span><br><span class=\"line\">    return get<span class=\"constructor\">Method_nolock(<span class=\"params\">cls</span>, <span class=\"params\">sel</span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static method_t *</span><br><span class=\"line\">get<span class=\"constructor\">Method_nolock(Class <span class=\"params\">cls</span>, SEL <span class=\"params\">sel</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    method_t *m = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">    runtimeLock.<span class=\"keyword\">assert</span><span class=\"constructor\">Locked()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// fixme nil cls?</span></span><br><span class=\"line\">    <span class=\"comment\">// fixme nil sel?</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"constructor\">ASSERT(<span class=\"params\">cls</span>-&gt;<span class=\"params\">isRealized</span>()</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cls<span class=\"operator\">  &amp;&amp;  </span>((m = get<span class=\"constructor\">MethodNoSuper_nolock(<span class=\"params\">cls</span>, <span class=\"params\">sel</span>)</span>))<span class=\"operator\"> == </span>nil) &#123;</span><br><span class=\"line\">        cls = cls-&gt;superclass;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return m;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：while循环是从cls开始，递归其父类进行查找，所以如果在元类中查找类方法，直到根元类仍没有找到，则因为根元类的父类为根类即<code>NSObject</code>，如果在<code>NSObject</code>中实现了同名的对象方法，仍然不会报错。</p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-c5cdd8e3563b0fb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>如上图所示，如果调用<code>[LSStudent  sleep];</code>,并不会报<code>unrecognized selector sent to class</code>的错误，反而会调用根类中的<code>- (void)sleep</code>实例方法。</p>\n"},{"title":"iOS cache_t结构分析","date":"2020-09-17T16:00:00.000Z","_content":"\n#### 1. `cache_t`源码结构  \n\n精简后的`cache_t`源码如下：\n```OBJC\nstruct cache_t {\n#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_OUTLINED\n    // MAC\n    struct bucket_t * _buckets;\n    uint32_t _mask;\n#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16\n    //真机\n    uintptr_t _maskAndBuckets;\n    mask_t _mask_unused;\n    \n    static constexpr uintptr_t maskShift = 48;\n    static constexpr uintptr_t maskZeroBits = 4;\n    static constexpr uintptr_t maxMask = ((uintptr_t)1 << (64 - maskShift)) - 1;\n    static constexpr uintptr_t bucketsMask = ((uintptr_t)1 << (maskShift - maskZeroBits)) - 1;\n#else\n#error Unknown cache mask storage type.\n#endif\n    \n    uint16_t _flags;\n    uint16_t _occupied;//占用的个数\n\npublic:\n    static bucket_t *emptyBuckets();\n    struct bucket_t *buckets();\n    uint32_t mask();\n    uint32_t occupied();\n    void incrementOccupied();\n    void setBucketsAndMask(struct bucket_t *newBuckets, uint32_t newMask);\n    void initializeToEmpty();\n\n    unsigned capacity();\n    bool isConstantEmptyCache();\n    bool canBeFreed();\n};\n```\n```\nvoid cache_t::incrementOccupied() \n{\n    _occupied++;\n}\n```\n\n可以看到有个重要的函数`void incrementOccupied();`，字面意思增加占用的个数，该函数只对内部成员变量加1操作。在源码中全局搜索调用，即可看到在`cache_t::insert`函数中调用。\n\n```\nALWAYS_INLINE\nvoid cache_t::insert(Class cls, SEL sel, IMP imp, id receiver)\n{ \n    // Use the cache as-is if it is less than 3/4 full\n    //occupied() 获取_occupied变量\n    mask_t newOccupied = occupied() + 1;//因为要新增一个缓存，所以+1\n    unsigned oldCapacity = capacity(), capacity = oldCapacity;\n    if (slowpath(isConstantEmptyCache())) {\n        // Cache is read-only. Replace it.\n        //如果之前没有缓存，开辟大小为4的内存\n        if (!capacity) capacity = INIT_CACHE_SIZE;\n        reallocate(oldCapacity, capacity, /* freeOld */false);\n    }\n    else if (fastpath(newOccupied + CACHE_END_MARKER <= capacity / 4 * 3)) {\n        // Cache is less than 3/4 full. Use it as-is.\n        //如果新的占用个数加1  小于等于  capacity的四分之三 则继续\n    }\n    else {\n        capacity = capacity ? capacity * 2 : INIT_CACHE_SIZE;\n        //否则进行扩容到 capacity的二倍\n        if (capacity > MAX_CACHE_SIZE) {\n            capacity = MAX_CACHE_SIZE;\n        }\n        reallocate(oldCapacity, capacity, true);\n    }\n\n    bucket_t *b = buckets();\n    mask_t m = capacity - 1;\n    mask_t begin = cache_hash(sel, m);//通过hash计算出要存放的index\n    mask_t i = begin;\n\n    // Scan for the first unused slot and insert there.\n    // There is guaranteed to be an empty slot because the\n    // minimum size is 4 and we resized at 3/4 full.\n    //确保计算出存放的index没有被占用，否则继续计算index\n    do {\n        if (fastpath(b[i].sel() == 0)) {\n            incrementOccupied();\n            b[i].set<Atomic, Encoded>(sel, imp, cls);\n            return;\n        }\n        if (b[i].sel() == sel) {\n            // The entry was added to the cache by some other thread\n            // before we grabbed the cacheUpdateLock.\n            return;\n        }\n    } while (fastpath((i = cache_next(i, m)) != begin));\n\n    cache_t::bad_cache(receiver, (SEL)sel, cls);\n}\n```\n\n#### 2. 模仿cache_t结构，进行探索\n```\ntypedef uint32_t mask_t;  // x86_64 & arm64 asm are less efficient with 16-bits\n\nstruct bucket_t {\n    SEL _sel;\n    IMP _imp;\n};\n\nstruct ls_cache_t {\n    struct bucket_t * _buckets;\n    mask_t _mask;\n    uint16_t _flags;\n    uint16_t _occupied;\n};\n\n//不影响cache_t获取，所以写个空结构体类型\nstruct ls_class_data_bits_t {\n\n};\n\nstruct ls_objc_class {\n    Class ISA;\n    Class superclass;\n    struct ls_cache_t cache;             // formerly cache pointer and vtable\n    struct ls_class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\n};\n\nvoid printCachet(Class pClass) {\n    struct ls_objc_class *ls_class = (__bridge struct ls_objc_class *)(pClass);\n    \n    uint16_t occupied = ls_class->cache._occupied;\n    mask_t mask = ls_class->cache._mask;\n    \n    printf(\"cache_t._occupied = %d cache_t._mask = %d \\n\", occupied, mask);\n    for (int i = 0; i < mask; i++) {\n        struct bucket_t bucket = ls_class->cache._buckets[i];\n        printf(\"sel=%s  imp=%p\\n\", [NSStringFromSelector(bucket._sel) UTF8String], bucket._imp);\n    }\n    printf(\"----------------------------------\\n\");\n}\n\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        \n        LSPerson *person = [LSPerson alloc];\n        \n        Class pClass = [LSPerson class];\n        \n        printCachet(pClass);\n        [person eat];\n        [person run];\n        printCachet(pClass);\n        [person sleep];\n        [person smile];\n        printCachet(pClass);\n        \n\n    }\n    return 0;\n}\n```\n\n```\n//output\n//不调用方法时，_occupied = 0， _mask = 0\ncache_t._occupied = 0 cache_t._mask = 0 \n----------------------------------\n2020-09-17 17:43:11.080167+0800 Cache_t_Analyze[64281:11027140] -[LSPerson eat]\n2020-09-17 17:43:11.080673+0800 Cache_t_Analyze[64281:11027140] -[LSPerson run]\n//调用2个方法后 _occupied = 2，_mask = 4 - 1\ncache_t._occupied = 2 cache_t._mask = 3 \nsel=run  imp=0x2c90\nsel=(null)  imp=0x0\nsel=eat  imp=0x2ce0\n----------------------------------\n2020-09-17 17:43:11.080923+0800 Cache_t_Analyze[64281:11027140] -[LSPerson sleep]\n2020-09-17 17:43:11.080973+0800 Cache_t_Analyze[64281:11027140] -[LSPerson smile]\n//调用4个方法，由于在调用第三个方法时触发了扩容，清空之前的缓存，所以只缓存了调用的第三个和第四个方法，但容量扩容到了8\n//所以 _occupied = 2  _mask = 8 - 1\ncache_t._occupied = 2 cache_t._mask = 7 \nsel=smile  imp=0x2c70\nsel=(null)  imp=0x0\nsel=(null)  imp=0x0\nsel=(null)  imp=0x0\nsel=(null)  imp=0x0\nsel=(null)  imp=0x0\nsel=sleep  imp=0x2c40\n----------------------------------\nProgram ended with exit code: 0\n```","source":"_posts/2020-09-18-iOS cache_t结构分析.md","raw":"---\ntitle:      \"iOS cache_t结构分析\" \ndate:       2020-09-18\ntags:\n    - iOS底层原理\ncategories:\n    - iOS底层原理\n---\n\n#### 1. `cache_t`源码结构  \n\n精简后的`cache_t`源码如下：\n```OBJC\nstruct cache_t {\n#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_OUTLINED\n    // MAC\n    struct bucket_t * _buckets;\n    uint32_t _mask;\n#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16\n    //真机\n    uintptr_t _maskAndBuckets;\n    mask_t _mask_unused;\n    \n    static constexpr uintptr_t maskShift = 48;\n    static constexpr uintptr_t maskZeroBits = 4;\n    static constexpr uintptr_t maxMask = ((uintptr_t)1 << (64 - maskShift)) - 1;\n    static constexpr uintptr_t bucketsMask = ((uintptr_t)1 << (maskShift - maskZeroBits)) - 1;\n#else\n#error Unknown cache mask storage type.\n#endif\n    \n    uint16_t _flags;\n    uint16_t _occupied;//占用的个数\n\npublic:\n    static bucket_t *emptyBuckets();\n    struct bucket_t *buckets();\n    uint32_t mask();\n    uint32_t occupied();\n    void incrementOccupied();\n    void setBucketsAndMask(struct bucket_t *newBuckets, uint32_t newMask);\n    void initializeToEmpty();\n\n    unsigned capacity();\n    bool isConstantEmptyCache();\n    bool canBeFreed();\n};\n```\n```\nvoid cache_t::incrementOccupied() \n{\n    _occupied++;\n}\n```\n\n可以看到有个重要的函数`void incrementOccupied();`，字面意思增加占用的个数，该函数只对内部成员变量加1操作。在源码中全局搜索调用，即可看到在`cache_t::insert`函数中调用。\n\n```\nALWAYS_INLINE\nvoid cache_t::insert(Class cls, SEL sel, IMP imp, id receiver)\n{ \n    // Use the cache as-is if it is less than 3/4 full\n    //occupied() 获取_occupied变量\n    mask_t newOccupied = occupied() + 1;//因为要新增一个缓存，所以+1\n    unsigned oldCapacity = capacity(), capacity = oldCapacity;\n    if (slowpath(isConstantEmptyCache())) {\n        // Cache is read-only. Replace it.\n        //如果之前没有缓存，开辟大小为4的内存\n        if (!capacity) capacity = INIT_CACHE_SIZE;\n        reallocate(oldCapacity, capacity, /* freeOld */false);\n    }\n    else if (fastpath(newOccupied + CACHE_END_MARKER <= capacity / 4 * 3)) {\n        // Cache is less than 3/4 full. Use it as-is.\n        //如果新的占用个数加1  小于等于  capacity的四分之三 则继续\n    }\n    else {\n        capacity = capacity ? capacity * 2 : INIT_CACHE_SIZE;\n        //否则进行扩容到 capacity的二倍\n        if (capacity > MAX_CACHE_SIZE) {\n            capacity = MAX_CACHE_SIZE;\n        }\n        reallocate(oldCapacity, capacity, true);\n    }\n\n    bucket_t *b = buckets();\n    mask_t m = capacity - 1;\n    mask_t begin = cache_hash(sel, m);//通过hash计算出要存放的index\n    mask_t i = begin;\n\n    // Scan for the first unused slot and insert there.\n    // There is guaranteed to be an empty slot because the\n    // minimum size is 4 and we resized at 3/4 full.\n    //确保计算出存放的index没有被占用，否则继续计算index\n    do {\n        if (fastpath(b[i].sel() == 0)) {\n            incrementOccupied();\n            b[i].set<Atomic, Encoded>(sel, imp, cls);\n            return;\n        }\n        if (b[i].sel() == sel) {\n            // The entry was added to the cache by some other thread\n            // before we grabbed the cacheUpdateLock.\n            return;\n        }\n    } while (fastpath((i = cache_next(i, m)) != begin));\n\n    cache_t::bad_cache(receiver, (SEL)sel, cls);\n}\n```\n\n#### 2. 模仿cache_t结构，进行探索\n```\ntypedef uint32_t mask_t;  // x86_64 & arm64 asm are less efficient with 16-bits\n\nstruct bucket_t {\n    SEL _sel;\n    IMP _imp;\n};\n\nstruct ls_cache_t {\n    struct bucket_t * _buckets;\n    mask_t _mask;\n    uint16_t _flags;\n    uint16_t _occupied;\n};\n\n//不影响cache_t获取，所以写个空结构体类型\nstruct ls_class_data_bits_t {\n\n};\n\nstruct ls_objc_class {\n    Class ISA;\n    Class superclass;\n    struct ls_cache_t cache;             // formerly cache pointer and vtable\n    struct ls_class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags\n};\n\nvoid printCachet(Class pClass) {\n    struct ls_objc_class *ls_class = (__bridge struct ls_objc_class *)(pClass);\n    \n    uint16_t occupied = ls_class->cache._occupied;\n    mask_t mask = ls_class->cache._mask;\n    \n    printf(\"cache_t._occupied = %d cache_t._mask = %d \\n\", occupied, mask);\n    for (int i = 0; i < mask; i++) {\n        struct bucket_t bucket = ls_class->cache._buckets[i];\n        printf(\"sel=%s  imp=%p\\n\", [NSStringFromSelector(bucket._sel) UTF8String], bucket._imp);\n    }\n    printf(\"----------------------------------\\n\");\n}\n\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        \n        LSPerson *person = [LSPerson alloc];\n        \n        Class pClass = [LSPerson class];\n        \n        printCachet(pClass);\n        [person eat];\n        [person run];\n        printCachet(pClass);\n        [person sleep];\n        [person smile];\n        printCachet(pClass);\n        \n\n    }\n    return 0;\n}\n```\n\n```\n//output\n//不调用方法时，_occupied = 0， _mask = 0\ncache_t._occupied = 0 cache_t._mask = 0 \n----------------------------------\n2020-09-17 17:43:11.080167+0800 Cache_t_Analyze[64281:11027140] -[LSPerson eat]\n2020-09-17 17:43:11.080673+0800 Cache_t_Analyze[64281:11027140] -[LSPerson run]\n//调用2个方法后 _occupied = 2，_mask = 4 - 1\ncache_t._occupied = 2 cache_t._mask = 3 \nsel=run  imp=0x2c90\nsel=(null)  imp=0x0\nsel=eat  imp=0x2ce0\n----------------------------------\n2020-09-17 17:43:11.080923+0800 Cache_t_Analyze[64281:11027140] -[LSPerson sleep]\n2020-09-17 17:43:11.080973+0800 Cache_t_Analyze[64281:11027140] -[LSPerson smile]\n//调用4个方法，由于在调用第三个方法时触发了扩容，清空之前的缓存，所以只缓存了调用的第三个和第四个方法，但容量扩容到了8\n//所以 _occupied = 2  _mask = 8 - 1\ncache_t._occupied = 2 cache_t._mask = 7 \nsel=smile  imp=0x2c70\nsel=(null)  imp=0x0\nsel=(null)  imp=0x0\nsel=(null)  imp=0x0\nsel=(null)  imp=0x0\nsel=(null)  imp=0x0\nsel=sleep  imp=0x2c40\n----------------------------------\nProgram ended with exit code: 0\n```","slug":"2020-09-18-iOS cache_t结构分析","published":1,"updated":"2021-06-19T03:46:24.087Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbpy001qbjrj0vf0f2re","content":"<h4 id=\"1-cache-t源码结构\"><a href=\"#1-cache-t源码结构\" class=\"headerlink\" title=\"1. cache_t源码结构\"></a>1. <code>cache_t</code>源码结构</h4><p>精简后的<code>cache_t</code>源码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> cache_t &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_OUTLINED</span></span><br><span class=\"line\">    <span class=\"comment\">// MAC</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> bucket_t * _buckets;</span><br><span class=\"line\">    uint32_t _mask;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">elif</span> CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16</span></span><br><span class=\"line\">    <span class=\"comment\">//真机</span></span><br><span class=\"line\">    uintptr_t _maskAndBuckets;</span><br><span class=\"line\">    mask_t _mask_unused;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> constexpr uintptr_t maskShift = <span class=\"number\">48</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> constexpr uintptr_t maskZeroBits = <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> constexpr uintptr_t maxMask = ((uintptr_t)<span class=\"number\">1</span> &lt;&lt; (<span class=\"number\">64</span> - maskShift)) - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> constexpr uintptr_t bucketsMask = ((uintptr_t)<span class=\"number\">1</span> &lt;&lt; (maskShift - maskZeroBits)) - <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">error</span> Unknown cache mask storage type.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    uint16_t _flags;</span><br><span class=\"line\">    uint16_t _occupied;<span class=\"comment\">//占用的个数</span></span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> bucket_t *emptyBuckets();</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> bucket_t *buckets();</span><br><span class=\"line\">    uint32_t mask();</span><br><span class=\"line\">    uint32_t occupied();</span><br><span class=\"line\">    <span class=\"keyword\">void</span> incrementOccupied();</span><br><span class=\"line\">    <span class=\"keyword\">void</span> setBucketsAndMask(<span class=\"keyword\">struct</span> bucket_t *newBuckets, uint32_t newMask);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> initializeToEmpty();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> capacity();</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isConstantEmptyCache();</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> canBeFreed();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> cache_t::incrementOccupied() </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _occupied++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到有个重要的函数<code>void incrementOccupied();</code>，字面意思增加占用的个数，该函数只对内部成员变量加1操作。在源码中全局搜索调用，即可看到在<code>cache_t::insert</code>函数中调用。</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALWAYS_INLINE</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cache_t::insert</span><span class=\"params\">(Class cls, SEL sel, IMP imp, id receiver)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// Use the cache as-is if it is less than 3/4 full</span></span><br><span class=\"line\">    <span class=\"comment\">//occupied() 获取_occupied变量</span></span><br><span class=\"line\">    <span class=\"keyword\">mask_t</span> newOccupied = occupied() + <span class=\"number\">1</span>;<span class=\"comment\">//因为要新增一个缓存，所以+1</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> oldCapacity = capacity(), capacity = oldCapacity;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(isConstantEmptyCache())) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Cache is read-only. Replace it.</span></span><br><span class=\"line\">        <span class=\"comment\">//如果之前没有缓存，开辟大小为4的内存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!capacity) capacity = INIT_CACHE_SIZE;</span><br><span class=\"line\">        reallocate(oldCapacity, capacity, <span class=\"comment\">/* freeOld */</span><span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fastpath(newOccupied + CACHE_END_MARKER &lt;= capacity / <span class=\"number\">4</span> * <span class=\"number\">3</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Cache is less than 3/4 full. Use it as-is.</span></span><br><span class=\"line\">        <span class=\"comment\">//如果新的占用个数加1  小于等于  capacity的四分之三 则继续</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        capacity = capacity ? capacity * <span class=\"number\">2</span> : INIT_CACHE_SIZE;</span><br><span class=\"line\">        <span class=\"comment\">//否则进行扩容到 capacity的二倍</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class=\"line\">            capacity = MAX_CACHE_SIZE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reallocate(oldCapacity, capacity, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">bucket_t</span> *b = buckets();</span><br><span class=\"line\">    <span class=\"keyword\">mask_t</span> m = capacity - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">mask_t</span> <span class=\"built_in\">begin</span> = cache_hash(sel, m);<span class=\"comment\">//通过hash计算出要存放的index</span></span><br><span class=\"line\">    <span class=\"keyword\">mask_t</span> i = <span class=\"built_in\">begin</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Scan for the first unused slot and insert there.</span></span><br><span class=\"line\">    <span class=\"comment\">// There is guaranteed to be an empty slot because the</span></span><br><span class=\"line\">    <span class=\"comment\">// minimum size is 4 and we resized at 3/4 full.</span></span><br><span class=\"line\">    <span class=\"comment\">//确保计算出存放的index没有被占用，否则继续计算index</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fastpath(b[i].sel() == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            incrementOccupied();</span><br><span class=\"line\">            b[i].<span class=\"built_in\">set</span>&lt;Atomic, Encoded&gt;(sel, imp, cls);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[i].sel() == sel) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// The entry was added to the cache by some other thread</span></span><br><span class=\"line\">            <span class=\"comment\">// before we grabbed the cacheUpdateLock.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (fastpath((i = cache_next(i, m)) != <span class=\"built_in\">begin</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">cache_t</span>::bad_cache(receiver, (SEL)sel, cls);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-模仿cache-t结构，进行探索\"><a href=\"#2-模仿cache-t结构，进行探索\" class=\"headerlink\" title=\"2. 模仿cache_t结构，进行探索\"></a>2. 模仿cache_t结构，进行探索</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">uint32_t</span> <span class=\"keyword\">mask_t</span>;  <span class=\"comment\">// x86_64 &amp; arm64 asm are less efficient with 16-bits</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bucket_t</span> &#123;</span></span><br><span class=\"line\">    SEL _sel;</span><br><span class=\"line\">    IMP _imp;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ls_cache_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bucket_t</span> * _<span class=\"title\">buckets</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">mask_t</span> _mask;</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> _flags;</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> _occupied;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//不影响cache_t获取，所以写个空结构体类型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ls_class_data_bits_t</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ls_objc_class</span> &#123;</span></span><br><span class=\"line\">    Class ISA;</span><br><span class=\"line\">    Class superclass;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ls_cache_t</span> <span class=\"title\">cache</span>;</span>             <span class=\"comment\">// formerly cache pointer and vtable</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ls_class_data_bits_t</span> <span class=\"title\">bits</span>;</span>    <span class=\"comment\">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printCachet</span><span class=\"params\">(Class pClass)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ls_objc_class</span> *<span class=\"title\">ls_class</span> =</span> (__bridge struct ls_objc_class *)(pClass);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> occupied = ls_class-&gt;cache._occupied;</span><br><span class=\"line\">    <span class=\"keyword\">mask_t</span> mask = ls_class-&gt;cache._mask;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;cache_t._occupied = %d cache_t._mask = %d \\n&quot;</span>, occupied, mask);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mask; i++) &#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bucket_t</span> <span class=\"title\">bucket</span> =</span> ls_class-&gt;cache._buckets[i];</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;sel=%s  imp=%p\\n&quot;</span>, [NSStringFromSelector(bucket._sel) UTF8String], bucket._imp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;----------------------------------\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[])</span> </span>&#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        LSPerson *person = [LSPerson alloc];</span><br><span class=\"line\">        </span><br><span class=\"line\">        Class pClass = [LSPerson class];</span><br><span class=\"line\">        </span><br><span class=\"line\">        printCachet(pClass);</span><br><span class=\"line\">        [person eat];</span><br><span class=\"line\">        [person <span class=\"built_in\">run</span>];</span><br><span class=\"line\">        printCachet(pClass);</span><br><span class=\"line\">        [person sleep];</span><br><span class=\"line\">        [person smile];</span><br><span class=\"line\">        printCachet(pClass);</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//output</span><br><span class=\"line\">//不调用方法时，<span class=\"attr\">_occupied</span> = <span class=\"number\">0</span>， <span class=\"attr\">_mask</span> = <span class=\"number\">0</span></span><br><span class=\"line\">cache_t.<span class=\"attr\">_occupied</span> = <span class=\"number\">0</span> cache_t.<span class=\"attr\">_mask</span> = <span class=\"number\">0</span> </span><br><span class=\"line\">----------------------------------</span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">09</span>-<span class=\"number\">17</span> <span class=\"number\">17</span>:<span class=\"number\">43</span>:<span class=\"number\">11.080167</span>+<span class=\"number\">0800</span> Cache_t_Analyze[<span class=\"number\">64281</span>:<span class=\"number\">11027140</span>] -[LSPerson eat]</span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">09</span>-<span class=\"number\">17</span> <span class=\"number\">17</span>:<span class=\"number\">43</span>:<span class=\"number\">11.080673</span>+<span class=\"number\">0800</span> Cache_t_Analyze[<span class=\"number\">64281</span>:<span class=\"number\">11027140</span>] -[LSPerson run]</span><br><span class=\"line\">//调用<span class=\"number\">2</span>个方法后 <span class=\"attr\">_occupied</span> = <span class=\"number\">2</span>，<span class=\"attr\">_mask</span> = <span class=\"number\">4</span> - <span class=\"number\">1</span></span><br><span class=\"line\">cache_t.<span class=\"attr\">_occupied</span> = <span class=\"number\">2</span> cache_t.<span class=\"attr\">_mask</span> = <span class=\"number\">3</span> </span><br><span class=\"line\"><span class=\"attr\">sel=run</span>  <span class=\"attr\">imp=0x2c90</span></span><br><span class=\"line\"><span class=\"attr\">sel=(null)</span>  <span class=\"attr\">imp=0x0</span></span><br><span class=\"line\"><span class=\"attr\">sel=eat</span>  <span class=\"attr\">imp=0x2ce0</span></span><br><span class=\"line\">----------------------------------</span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">09</span>-<span class=\"number\">17</span> <span class=\"number\">17</span>:<span class=\"number\">43</span>:<span class=\"number\">11.080923</span>+<span class=\"number\">0800</span> Cache_t_Analyze[<span class=\"number\">64281</span>:<span class=\"number\">11027140</span>] -[LSPerson sleep]</span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">09</span>-<span class=\"number\">17</span> <span class=\"number\">17</span>:<span class=\"number\">43</span>:<span class=\"number\">11.080973</span>+<span class=\"number\">0800</span> Cache_t_Analyze[<span class=\"number\">64281</span>:<span class=\"number\">11027140</span>] -[LSPerson smile]</span><br><span class=\"line\">//调用<span class=\"number\">4</span>个方法，由于在调用第三个方法时触发了扩容，清空之前的缓存，所以只缓存了调用的第三个和第四个方法，但容量扩容到了<span class=\"number\">8</span></span><br><span class=\"line\">//所以 <span class=\"attr\">_occupied</span> = <span class=\"number\">2</span>  <span class=\"attr\">_mask</span> = <span class=\"number\">8</span> - <span class=\"number\">1</span></span><br><span class=\"line\">cache_t.<span class=\"attr\">_occupied</span> = <span class=\"number\">2</span> cache_t.<span class=\"attr\">_mask</span> = <span class=\"number\">7</span> </span><br><span class=\"line\"><span class=\"attr\">sel=smile</span>  <span class=\"attr\">imp=0x2c70</span></span><br><span class=\"line\"><span class=\"attr\">sel=(null)</span>  <span class=\"attr\">imp=0x0</span></span><br><span class=\"line\"><span class=\"attr\">sel=(null)</span>  <span class=\"attr\">imp=0x0</span></span><br><span class=\"line\"><span class=\"attr\">sel=(null)</span>  <span class=\"attr\">imp=0x0</span></span><br><span class=\"line\"><span class=\"attr\">sel=(null)</span>  <span class=\"attr\">imp=0x0</span></span><br><span class=\"line\"><span class=\"attr\">sel=(null)</span>  <span class=\"attr\">imp=0x0</span></span><br><span class=\"line\"><span class=\"attr\">sel=sleep</span>  <span class=\"attr\">imp=0x2c40</span></span><br><span class=\"line\">----------------------------------</span><br><span class=\"line\">Program ended <span class=\"keyword\">with</span> exit code: <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1-cache-t源码结构\"><a href=\"#1-cache-t源码结构\" class=\"headerlink\" title=\"1. cache_t源码结构\"></a>1. <code>cache_t</code>源码结构</h4><p>精简后的<code>cache_t</code>源码如下：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> cache_t &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_OUTLINED</span></span><br><span class=\"line\">    <span class=\"comment\">// MAC</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> bucket_t * _buckets;</span><br><span class=\"line\">    uint32_t _mask;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">elif</span> CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16</span></span><br><span class=\"line\">    <span class=\"comment\">//真机</span></span><br><span class=\"line\">    uintptr_t _maskAndBuckets;</span><br><span class=\"line\">    mask_t _mask_unused;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> constexpr uintptr_t maskShift = <span class=\"number\">48</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> constexpr uintptr_t maskZeroBits = <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> constexpr uintptr_t maxMask = ((uintptr_t)<span class=\"number\">1</span> &lt;&lt; (<span class=\"number\">64</span> - maskShift)) - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> constexpr uintptr_t bucketsMask = ((uintptr_t)<span class=\"number\">1</span> &lt;&lt; (maskShift - maskZeroBits)) - <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">error</span> Unknown cache mask storage type.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    uint16_t _flags;</span><br><span class=\"line\">    uint16_t _occupied;<span class=\"comment\">//占用的个数</span></span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> bucket_t *emptyBuckets();</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> bucket_t *buckets();</span><br><span class=\"line\">    uint32_t mask();</span><br><span class=\"line\">    uint32_t occupied();</span><br><span class=\"line\">    <span class=\"keyword\">void</span> incrementOccupied();</span><br><span class=\"line\">    <span class=\"keyword\">void</span> setBucketsAndMask(<span class=\"keyword\">struct</span> bucket_t *newBuckets, uint32_t newMask);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> initializeToEmpty();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> capacity();</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isConstantEmptyCache();</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> canBeFreed();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> cache_t::incrementOccupied() </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _occupied++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到有个重要的函数<code>void incrementOccupied();</code>，字面意思增加占用的个数，该函数只对内部成员变量加1操作。在源码中全局搜索调用，即可看到在<code>cache_t::insert</code>函数中调用。</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALWAYS_INLINE</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cache_t::insert</span><span class=\"params\">(Class cls, SEL sel, IMP imp, id receiver)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// Use the cache as-is if it is less than 3/4 full</span></span><br><span class=\"line\">    <span class=\"comment\">//occupied() 获取_occupied变量</span></span><br><span class=\"line\">    <span class=\"keyword\">mask_t</span> newOccupied = occupied() + <span class=\"number\">1</span>;<span class=\"comment\">//因为要新增一个缓存，所以+1</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> oldCapacity = capacity(), capacity = oldCapacity;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(isConstantEmptyCache())) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Cache is read-only. Replace it.</span></span><br><span class=\"line\">        <span class=\"comment\">//如果之前没有缓存，开辟大小为4的内存</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!capacity) capacity = INIT_CACHE_SIZE;</span><br><span class=\"line\">        reallocate(oldCapacity, capacity, <span class=\"comment\">/* freeOld */</span><span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fastpath(newOccupied + CACHE_END_MARKER &lt;= capacity / <span class=\"number\">4</span> * <span class=\"number\">3</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Cache is less than 3/4 full. Use it as-is.</span></span><br><span class=\"line\">        <span class=\"comment\">//如果新的占用个数加1  小于等于  capacity的四分之三 则继续</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        capacity = capacity ? capacity * <span class=\"number\">2</span> : INIT_CACHE_SIZE;</span><br><span class=\"line\">        <span class=\"comment\">//否则进行扩容到 capacity的二倍</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class=\"line\">            capacity = MAX_CACHE_SIZE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reallocate(oldCapacity, capacity, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">bucket_t</span> *b = buckets();</span><br><span class=\"line\">    <span class=\"keyword\">mask_t</span> m = capacity - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">mask_t</span> <span class=\"built_in\">begin</span> = cache_hash(sel, m);<span class=\"comment\">//通过hash计算出要存放的index</span></span><br><span class=\"line\">    <span class=\"keyword\">mask_t</span> i = <span class=\"built_in\">begin</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Scan for the first unused slot and insert there.</span></span><br><span class=\"line\">    <span class=\"comment\">// There is guaranteed to be an empty slot because the</span></span><br><span class=\"line\">    <span class=\"comment\">// minimum size is 4 and we resized at 3/4 full.</span></span><br><span class=\"line\">    <span class=\"comment\">//确保计算出存放的index没有被占用，否则继续计算index</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fastpath(b[i].sel() == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            incrementOccupied();</span><br><span class=\"line\">            b[i].<span class=\"built_in\">set</span>&lt;Atomic, Encoded&gt;(sel, imp, cls);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[i].sel() == sel) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// The entry was added to the cache by some other thread</span></span><br><span class=\"line\">            <span class=\"comment\">// before we grabbed the cacheUpdateLock.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (fastpath((i = cache_next(i, m)) != <span class=\"built_in\">begin</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">cache_t</span>::bad_cache(receiver, (SEL)sel, cls);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-模仿cache-t结构，进行探索\"><a href=\"#2-模仿cache-t结构，进行探索\" class=\"headerlink\" title=\"2. 模仿cache_t结构，进行探索\"></a>2. 模仿cache_t结构，进行探索</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">uint32_t</span> <span class=\"keyword\">mask_t</span>;  <span class=\"comment\">// x86_64 &amp; arm64 asm are less efficient with 16-bits</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bucket_t</span> &#123;</span></span><br><span class=\"line\">    SEL _sel;</span><br><span class=\"line\">    IMP _imp;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ls_cache_t</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bucket_t</span> * _<span class=\"title\">buckets</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">mask_t</span> _mask;</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> _flags;</span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> _occupied;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//不影响cache_t获取，所以写个空结构体类型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ls_class_data_bits_t</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ls_objc_class</span> &#123;</span></span><br><span class=\"line\">    Class ISA;</span><br><span class=\"line\">    Class superclass;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ls_cache_t</span> <span class=\"title\">cache</span>;</span>             <span class=\"comment\">// formerly cache pointer and vtable</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ls_class_data_bits_t</span> <span class=\"title\">bits</span>;</span>    <span class=\"comment\">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printCachet</span><span class=\"params\">(Class pClass)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ls_objc_class</span> *<span class=\"title\">ls_class</span> =</span> (__bridge struct ls_objc_class *)(pClass);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">uint16_t</span> occupied = ls_class-&gt;cache._occupied;</span><br><span class=\"line\">    <span class=\"keyword\">mask_t</span> mask = ls_class-&gt;cache._mask;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;cache_t._occupied = %d cache_t._mask = %d \\n&quot;</span>, occupied, mask);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; mask; i++) &#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bucket_t</span> <span class=\"title\">bucket</span> =</span> ls_class-&gt;cache._buckets[i];</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;sel=%s  imp=%p\\n&quot;</span>, [NSStringFromSelector(bucket._sel) UTF8String], bucket._imp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;----------------------------------\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[])</span> </span>&#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        LSPerson *person = [LSPerson alloc];</span><br><span class=\"line\">        </span><br><span class=\"line\">        Class pClass = [LSPerson class];</span><br><span class=\"line\">        </span><br><span class=\"line\">        printCachet(pClass);</span><br><span class=\"line\">        [person eat];</span><br><span class=\"line\">        [person <span class=\"built_in\">run</span>];</span><br><span class=\"line\">        printCachet(pClass);</span><br><span class=\"line\">        [person sleep];</span><br><span class=\"line\">        [person smile];</span><br><span class=\"line\">        printCachet(pClass);</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//output</span><br><span class=\"line\">//不调用方法时，<span class=\"attr\">_occupied</span> = <span class=\"number\">0</span>， <span class=\"attr\">_mask</span> = <span class=\"number\">0</span></span><br><span class=\"line\">cache_t.<span class=\"attr\">_occupied</span> = <span class=\"number\">0</span> cache_t.<span class=\"attr\">_mask</span> = <span class=\"number\">0</span> </span><br><span class=\"line\">----------------------------------</span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">09</span>-<span class=\"number\">17</span> <span class=\"number\">17</span>:<span class=\"number\">43</span>:<span class=\"number\">11.080167</span>+<span class=\"number\">0800</span> Cache_t_Analyze[<span class=\"number\">64281</span>:<span class=\"number\">11027140</span>] -[LSPerson eat]</span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">09</span>-<span class=\"number\">17</span> <span class=\"number\">17</span>:<span class=\"number\">43</span>:<span class=\"number\">11.080673</span>+<span class=\"number\">0800</span> Cache_t_Analyze[<span class=\"number\">64281</span>:<span class=\"number\">11027140</span>] -[LSPerson run]</span><br><span class=\"line\">//调用<span class=\"number\">2</span>个方法后 <span class=\"attr\">_occupied</span> = <span class=\"number\">2</span>，<span class=\"attr\">_mask</span> = <span class=\"number\">4</span> - <span class=\"number\">1</span></span><br><span class=\"line\">cache_t.<span class=\"attr\">_occupied</span> = <span class=\"number\">2</span> cache_t.<span class=\"attr\">_mask</span> = <span class=\"number\">3</span> </span><br><span class=\"line\"><span class=\"attr\">sel=run</span>  <span class=\"attr\">imp=0x2c90</span></span><br><span class=\"line\"><span class=\"attr\">sel=(null)</span>  <span class=\"attr\">imp=0x0</span></span><br><span class=\"line\"><span class=\"attr\">sel=eat</span>  <span class=\"attr\">imp=0x2ce0</span></span><br><span class=\"line\">----------------------------------</span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">09</span>-<span class=\"number\">17</span> <span class=\"number\">17</span>:<span class=\"number\">43</span>:<span class=\"number\">11.080923</span>+<span class=\"number\">0800</span> Cache_t_Analyze[<span class=\"number\">64281</span>:<span class=\"number\">11027140</span>] -[LSPerson sleep]</span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">09</span>-<span class=\"number\">17</span> <span class=\"number\">17</span>:<span class=\"number\">43</span>:<span class=\"number\">11.080973</span>+<span class=\"number\">0800</span> Cache_t_Analyze[<span class=\"number\">64281</span>:<span class=\"number\">11027140</span>] -[LSPerson smile]</span><br><span class=\"line\">//调用<span class=\"number\">4</span>个方法，由于在调用第三个方法时触发了扩容，清空之前的缓存，所以只缓存了调用的第三个和第四个方法，但容量扩容到了<span class=\"number\">8</span></span><br><span class=\"line\">//所以 <span class=\"attr\">_occupied</span> = <span class=\"number\">2</span>  <span class=\"attr\">_mask</span> = <span class=\"number\">8</span> - <span class=\"number\">1</span></span><br><span class=\"line\">cache_t.<span class=\"attr\">_occupied</span> = <span class=\"number\">2</span> cache_t.<span class=\"attr\">_mask</span> = <span class=\"number\">7</span> </span><br><span class=\"line\"><span class=\"attr\">sel=smile</span>  <span class=\"attr\">imp=0x2c70</span></span><br><span class=\"line\"><span class=\"attr\">sel=(null)</span>  <span class=\"attr\">imp=0x0</span></span><br><span class=\"line\"><span class=\"attr\">sel=(null)</span>  <span class=\"attr\">imp=0x0</span></span><br><span class=\"line\"><span class=\"attr\">sel=(null)</span>  <span class=\"attr\">imp=0x0</span></span><br><span class=\"line\"><span class=\"attr\">sel=(null)</span>  <span class=\"attr\">imp=0x0</span></span><br><span class=\"line\"><span class=\"attr\">sel=(null)</span>  <span class=\"attr\">imp=0x0</span></span><br><span class=\"line\"><span class=\"attr\">sel=sleep</span>  <span class=\"attr\">imp=0x2c40</span></span><br><span class=\"line\">----------------------------------</span><br><span class=\"line\">Program ended <span class=\"keyword\">with</span> exit code: <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>"},{"title":"objc_msgSend源码解析(一)","date":"2020-09-19T16:00:00.000Z","_content":"\n[objc_msgSend源码解析(一)](https://www.jianshu.com/p/55daf526120d)\n[objc_msgSend源码解析(二)](https://www.jianshu.com/p/7128dac1f0e8)\n\n#### 1. `objc_msgSend`源码解析\n在 objc4源码中全局搜索`objc_msgSend`可知该方法由汇编实现，在iOS平台下实现是在`objc-msg-arm64.s`文件中。\n\n```\nENTRY _objc_msgSend \n//进入objc_msgSend流程\n\ncmp\tp0, #0\t\t\t// nil check and tagged pointer check\n//p0为第一个参数消息接收者，判断消息接收者是否为nil或者为taggedPointer类型\n\n#if SUPPORT_TAGGED_POINTERS\n\tb.le\tLNilOrTagged\t\t//  (MSB tagged pointer looks negative)\n    //如果为taggedPointer 则跳转到LNilOrTagged\n#else\n\tb.eq\tLReturnZero\n    //如果为nil 则跳转到LReturnZero\n#endif\n\nldr\tp13, [x0]\t\t// p13 = isa\n//取出消息接收者的isa\n\n\tGetClassFromIsa_p16 p13\t\t// p16 = class\n//获取isa指向的class\n\nLGetIsaDone:\n\t// calls imp or objc_msgSend_uncached\n\tCacheLookup NORMAL, _objc_msgSend\n//调用CacheLookup的NORMAL模式\n\n#if SUPPORT_TAGGED_POINTERS\nLNilOrTagged:\n\tb.eq\tLReturnZero\t\t// nil check\n    //taggedPointer作为消息接收者第一步同样也是跳转到LReturnZero\n\n\t// tagged 为taggedPointer的特殊处理\n\tadrp\tx10, _objc_debug_taggedpointer_classes@PAGE\n\tadd\tx10, x10, _objc_debug_taggedpointer_classes@PAGEOFF\n\tubfx\tx11, x0, #60, #4\n\tldr\tx16, [x10, x11, LSL #3]\n\tadrp\tx10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGE\n\tadd\tx10, x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGEOFF\n\tcmp\tx10, x16\n\tb.ne\tLGetIsaDone\n\n\t// ext tagged\n\tadrp\tx10, _objc_debug_taggedpointer_ext_classes@PAGE\n\tadd\tx10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF\n\tubfx\tx11, x0, #52, #8\n\tldr\tx16, [x10, x11, LSL #3]\n\tb\tLGetIsaDone\n// SUPPORT_TAGGED_POINTERS\n#endif\n\nLReturnZero:\n    //消息接收者为nil或者taggedPointer类型都是直接return\n\t// x0 is already zero\n\tmov\tx1, #0\n\tmovi\td0, #0\n\tmovi\td1, #0\n\tmovi\td2, #0\n\tmovi\td3, #0\n\tret\n\n\tEND_ENTRY _objc_msgSend\n```\n> 分析：\n> 1. p0为第一个参数消息接收者，判断消息接收者是否为nil或者为taggedPointer类型\n> 2. 如果为nil或者taggedPointer 则跳转到LReturnZero，直接return\n> 3. 如果不为nil或taggedPointer，则将消息接收者第一个地址的isa取出，赋值给p13\n> 4. 将p13即消息接收者的isa作为参数，调用`GetClassFromIsa_p16`，获取isa指向的类或者元类\n> 5. 然后调用`CacheLookup`函数的NORMAL模式\n\n![objc_msgSend.png](https://upload-images.jianshu.io/upload_images/1395687-d6d9b57eee1f2ee3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n#### 2. `GetClassFromIsa_p16`源码解析\n```\n.macro GetClassFromIsa_p16 /* src */\n\n#if SUPPORT_INDEXED_ISA\n\t// Indexed isa\n\tmov\tp16, $0\t\t\t// optimistically set dst = src\n\ttbz\tp16, #ISA_INDEX_IS_NPI_BIT, 1f\t// done if not non-pointer isa\n\t// isa in p16 is indexed\n\tadrp\tx10, _objc_indexed_classes@PAGE\n\tadd\tx10, x10, _objc_indexed_classes@PAGEOFF\n\tubfx\tp16, p16, #ISA_INDEX_SHIFT, #ISA_INDEX_BITS  // extract index\n\tldr\tp16, [x10, p16, UXTP #PTRSHIFT]\t// load class from array\n1:\n\n//在64位下根据传入的第一个参数 即 isa & ISA_MASK 取出class\n#elif __LP64__\n\t// 64-bit packed isa\n\tand\tp16, $0, #ISA_MASK\n\n#else\n\t// 32-bit raw isa\n\tmov\tp16, $0\n\n#endif\n\n.endmacro\n```\n> 分析： 在64位下根据传入的第一个参数 即 isa & ISA_MASK 取出class\n\n#### 3. `CacheLookup`源码解析\n```\n#define PTRSHIFT 3  // 1<<PTRSHIFT == PTRSIZE\n\n.macro CacheLookup\n\nLLookupStart$1:\n\n\t// p1 = SEL, p16 = isa\n\tldr\tp11, [x16, #CACHE]\t\t\t\t// p11 = mask|buckets\n//获取isa指向class中的cache_t cache结构中的mask|buckets\n\n//在iOS下走以下分支\n#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16\n//将p11中存的mask|buckets & 0x0000ffffffffffff，获取低48位的为buckets\n\tand\tp10, p11, #0x0000ffffffffffff\t// p10 = buckets\n\n//将p11中存的mask|buckets 逻辑右移48位，即将buckets顶出去，留下16位的mask；然后将获取到的mask & p1(_cmd)，获取到buckets数组中要查找的index，即index = _cmd & mask\n\tand\tp12, p1, p11, LSR #48\t\t// x12 = _cmd & mask\n#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4\n\tand\tp10, p11, #~0xf\t\t\t// p10 = buckets\n\tand\tp11, p11, #0xf\t\t\t// p11 = maskShift\n\tmov\tp12, #0xffff\n\tlsr\tp11, p12, p11\t\t\t\t// p11 = mask = 0xffff >> p11\n\tand\tp12, p1, p11\t\t\t\t// x12 = _cmd & mask\n#else\n#error Unsupported cache mask storage for ARM64.\n#endif\n\n\n\tadd\tp12, p10, p12, LSL #(1+PTRSHIFT)\n\t\t             // p12 = buckets + ((_cmd & mask) << (1+PTRSHIFT))\n//(1+PTRSHIFT) = (1+3) = 4，由于一个bucket结构包含 IMP _imp，SEL _sel，即16位，所以((_cmd & mask) << (1+PTRSHIFT))含义为index * 16，buckets + ((_cmd & mask) << (1+PTRSHIFT))含义为获取到index位置bucket的首地址赋值到p12\n\n\tldp\tp17, p9, [x12]\t\t// {imp, sel} = *bucket\n//在iOS下bucket结构为{imp, sel}，mac下为{sel, imp}\n\n1:\tcmp\tp9, p1\t\t\t// if (bucket->sel != _cmd)\n//比较bucket的sel和所需查找的_cmd是否相等\n\n\tb.ne\t2f\t\t\t//     scan more\n//如果不相等 跳转到2\n\n\tCacheHit $0\t\t\t// call or return imp\n//如果缓存命中，则直接返回imp\n\t\n2:\t// not hit: p12 = not-hit bucket\n\tCheckMiss $0\t\t\t// miss if bucket->sel == 0\n//首先检查bucket的_sel是否等于0，如果等于0，跳转到CheckMiss\n\n\tcmp\tp12, p10\t\t// wrap if bucket == buckets\n//判断获取的bucket是否是buckets中的第一个\n\n\tb.eq\t3f\n//如果遍历到数组的首个元素，则跳转到3，之后不会返回来继续，否则形成死循环\n\n\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// {imp, sel} = *--bucket\n//如果不是数组首个元素，则取得前一个bucket的imp和sel，继续进行比较\n\n\tb\t1b\t\t\t// loop\n\n3:\t// wrap: p12 = first bucket, w11 = mask\n#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16\n\tadd\tp12, p12, p11, LSR #(48 - (1+PTRSHIFT))\n\t\t\t\t\t// p12 = buckets + (mask << 1+PTRSHIFT)\n//mask为数组个数capacity减一，(mask << 1+PTRSHIFT)为mask * 16，即获取数组最后一个bucket赋值给p12\n\n#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4\n\tadd\tp12, p12, p11, LSL #(1+PTRSHIFT)\n\t\t\t\t\t// p12 = buckets + (mask << 1+PTRSHIFT)\n#else\n#error Unsupported cache mask storage for ARM64.\n#endif\n\n\t// Clone scanning loop to miss instead of hang when cache is corrupt.\n\t// The slow path may detect any corruption and halt later.\n\n\tldp\tp17, p9, [x12]\t\t// {imp, sel} = *bucket\n1:\tcmp\tp9, p1\t\t\t// if (bucket->sel != _cmd)\n\tb.ne\t2f\t\t\t//     scan more\n\tCacheHit $0\t\t\t// call or return imp\n\t\n2:\t// not hit: p12 = not-hit bucket\n\tCheckMiss $0\t\t\t// miss if bucket->sel == 0\n\tcmp\tp12, p10\t\t// wrap if bucket == buckets\n\tb.eq\t3f\n\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// {imp, sel} = *--bucket\n\tb\t1b\t\t\t// loop\n\nLLookupEnd$1:\nLLookupRecover$1:\n3:\t// double wrap\n\tJumpMiss $0\n\n.endmacro\n```\n> 分析：\n> 1. 找到isa指向的类，偏移16字节后取到cache_t cache元素的首地址，首地址在iOS下为`_maskAndBuckets`赋值到p11\n> 2. p11 & 0x0000ffffffffffff，得到低48位的buckets\n> 3. p11逻辑右移48位，得到mask，mask & _cmd得到数组buckets起始查找位置的index\n> 4. index << 4，即index * 16字节，获取到index所指向bucket的首地址p12\n> 5. p17, p9 分别为imp，sel\n>  ///第一步\n> 6. 比较p9和p1(即传入的第二个参数，所要查找的SEL _cmp)\n> 7. 如果不想等，则跳转到2f，如果相等则缓存命中，返回sel所对应的函数指针地址imp\n> ///第二步\n> 8. 首先检查bucket的sel是否等于0，如果等于0则跳转到`CheckMiss`\n> 9. 如果bucket的sel不等于0，判断bucket是否为数组第一个元素，如果是，则跳转到第三步，之后不会走下一步，而是直接走第三步之后的代码，否则形成死循环\n> 10. 如果bucket不是数组第一个元素，则获取前一个bucket，将新的imp和sel赋值到p17和p9，并跳转到第一步进行循环\n\n> ///第三步\n> 11. mask为数组buckets元素个数(capacity-1)，mask << 4，即获取数组最后一个元素bucket的首地址，赋值给p12\n\n> 12.之后的第一步和上面第一步一样，第二步如果走到数组buckets的第一个元素仍然没有找到，则直接跳转到第三步即`JumpMiss`\n\n![cachelookup.png](https://upload-images.jianshu.io/upload_images/1395687-45650706f1f09463.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 4. `CheckMiss`源码分析\n```\n.macro CheckMiss\n\t// miss if bucket->sel == 0\n.if $0 == GETIMP\n\tcbz\tp9, LGetImpMiss\n.elseif $0 == NORMAL\n\tcbz\tp9, __objc_msgSend_uncached\n.elseif $0 == LOOKUP\n\tcbz\tp9, __objc_msgLookup_uncached\n.else\n.abort oops\n.endif\n.endmacro\n```\n> 分析：此时为NORMAL模式，则进入`__objc_msgSend_uncached`流程\n\n#### 5. `__objc_msgSend_uncached`源码分析\n```\nSTATIC_ENTRY __objc_msgSend_uncached\n\tUNWIND __objc_msgSend_uncached, FrameWithNoSaves\n\n\t// THIS IS NOT A CALLABLE C FUNCTION\n\t// Out-of-band p16 is the class to search\n\t\n\tMethodTableLookup\n\tTailCallFunctionPointer x17\n\n\tEND_ENTRY __objc_msgSend_uncached\n```\n> 分析：此时快速缓存查找没有找到对应imp，调用`MethodTableLookup`函数中调用`_lookUpImpOrForward`，进入对应类或元类的methodlist查找流程","source":"_posts/2020-09-20-objc_msgSend源码解析(一).md","raw":"---\ntitle:      \"objc_msgSend源码解析(一)\" \ndate:       2020-09-20\ntags:\n    - iOS底层原理\ncategories:\n    - iOS底层原理\n---\n\n[objc_msgSend源码解析(一)](https://www.jianshu.com/p/55daf526120d)\n[objc_msgSend源码解析(二)](https://www.jianshu.com/p/7128dac1f0e8)\n\n#### 1. `objc_msgSend`源码解析\n在 objc4源码中全局搜索`objc_msgSend`可知该方法由汇编实现，在iOS平台下实现是在`objc-msg-arm64.s`文件中。\n\n```\nENTRY _objc_msgSend \n//进入objc_msgSend流程\n\ncmp\tp0, #0\t\t\t// nil check and tagged pointer check\n//p0为第一个参数消息接收者，判断消息接收者是否为nil或者为taggedPointer类型\n\n#if SUPPORT_TAGGED_POINTERS\n\tb.le\tLNilOrTagged\t\t//  (MSB tagged pointer looks negative)\n    //如果为taggedPointer 则跳转到LNilOrTagged\n#else\n\tb.eq\tLReturnZero\n    //如果为nil 则跳转到LReturnZero\n#endif\n\nldr\tp13, [x0]\t\t// p13 = isa\n//取出消息接收者的isa\n\n\tGetClassFromIsa_p16 p13\t\t// p16 = class\n//获取isa指向的class\n\nLGetIsaDone:\n\t// calls imp or objc_msgSend_uncached\n\tCacheLookup NORMAL, _objc_msgSend\n//调用CacheLookup的NORMAL模式\n\n#if SUPPORT_TAGGED_POINTERS\nLNilOrTagged:\n\tb.eq\tLReturnZero\t\t// nil check\n    //taggedPointer作为消息接收者第一步同样也是跳转到LReturnZero\n\n\t// tagged 为taggedPointer的特殊处理\n\tadrp\tx10, _objc_debug_taggedpointer_classes@PAGE\n\tadd\tx10, x10, _objc_debug_taggedpointer_classes@PAGEOFF\n\tubfx\tx11, x0, #60, #4\n\tldr\tx16, [x10, x11, LSL #3]\n\tadrp\tx10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGE\n\tadd\tx10, x10, _OBJC_CLASS_$___NSUnrecognizedTaggedPointer@PAGEOFF\n\tcmp\tx10, x16\n\tb.ne\tLGetIsaDone\n\n\t// ext tagged\n\tadrp\tx10, _objc_debug_taggedpointer_ext_classes@PAGE\n\tadd\tx10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF\n\tubfx\tx11, x0, #52, #8\n\tldr\tx16, [x10, x11, LSL #3]\n\tb\tLGetIsaDone\n// SUPPORT_TAGGED_POINTERS\n#endif\n\nLReturnZero:\n    //消息接收者为nil或者taggedPointer类型都是直接return\n\t// x0 is already zero\n\tmov\tx1, #0\n\tmovi\td0, #0\n\tmovi\td1, #0\n\tmovi\td2, #0\n\tmovi\td3, #0\n\tret\n\n\tEND_ENTRY _objc_msgSend\n```\n> 分析：\n> 1. p0为第一个参数消息接收者，判断消息接收者是否为nil或者为taggedPointer类型\n> 2. 如果为nil或者taggedPointer 则跳转到LReturnZero，直接return\n> 3. 如果不为nil或taggedPointer，则将消息接收者第一个地址的isa取出，赋值给p13\n> 4. 将p13即消息接收者的isa作为参数，调用`GetClassFromIsa_p16`，获取isa指向的类或者元类\n> 5. 然后调用`CacheLookup`函数的NORMAL模式\n\n![objc_msgSend.png](https://upload-images.jianshu.io/upload_images/1395687-d6d9b57eee1f2ee3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n#### 2. `GetClassFromIsa_p16`源码解析\n```\n.macro GetClassFromIsa_p16 /* src */\n\n#if SUPPORT_INDEXED_ISA\n\t// Indexed isa\n\tmov\tp16, $0\t\t\t// optimistically set dst = src\n\ttbz\tp16, #ISA_INDEX_IS_NPI_BIT, 1f\t// done if not non-pointer isa\n\t// isa in p16 is indexed\n\tadrp\tx10, _objc_indexed_classes@PAGE\n\tadd\tx10, x10, _objc_indexed_classes@PAGEOFF\n\tubfx\tp16, p16, #ISA_INDEX_SHIFT, #ISA_INDEX_BITS  // extract index\n\tldr\tp16, [x10, p16, UXTP #PTRSHIFT]\t// load class from array\n1:\n\n//在64位下根据传入的第一个参数 即 isa & ISA_MASK 取出class\n#elif __LP64__\n\t// 64-bit packed isa\n\tand\tp16, $0, #ISA_MASK\n\n#else\n\t// 32-bit raw isa\n\tmov\tp16, $0\n\n#endif\n\n.endmacro\n```\n> 分析： 在64位下根据传入的第一个参数 即 isa & ISA_MASK 取出class\n\n#### 3. `CacheLookup`源码解析\n```\n#define PTRSHIFT 3  // 1<<PTRSHIFT == PTRSIZE\n\n.macro CacheLookup\n\nLLookupStart$1:\n\n\t// p1 = SEL, p16 = isa\n\tldr\tp11, [x16, #CACHE]\t\t\t\t// p11 = mask|buckets\n//获取isa指向class中的cache_t cache结构中的mask|buckets\n\n//在iOS下走以下分支\n#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16\n//将p11中存的mask|buckets & 0x0000ffffffffffff，获取低48位的为buckets\n\tand\tp10, p11, #0x0000ffffffffffff\t// p10 = buckets\n\n//将p11中存的mask|buckets 逻辑右移48位，即将buckets顶出去，留下16位的mask；然后将获取到的mask & p1(_cmd)，获取到buckets数组中要查找的index，即index = _cmd & mask\n\tand\tp12, p1, p11, LSR #48\t\t// x12 = _cmd & mask\n#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4\n\tand\tp10, p11, #~0xf\t\t\t// p10 = buckets\n\tand\tp11, p11, #0xf\t\t\t// p11 = maskShift\n\tmov\tp12, #0xffff\n\tlsr\tp11, p12, p11\t\t\t\t// p11 = mask = 0xffff >> p11\n\tand\tp12, p1, p11\t\t\t\t// x12 = _cmd & mask\n#else\n#error Unsupported cache mask storage for ARM64.\n#endif\n\n\n\tadd\tp12, p10, p12, LSL #(1+PTRSHIFT)\n\t\t             // p12 = buckets + ((_cmd & mask) << (1+PTRSHIFT))\n//(1+PTRSHIFT) = (1+3) = 4，由于一个bucket结构包含 IMP _imp，SEL _sel，即16位，所以((_cmd & mask) << (1+PTRSHIFT))含义为index * 16，buckets + ((_cmd & mask) << (1+PTRSHIFT))含义为获取到index位置bucket的首地址赋值到p12\n\n\tldp\tp17, p9, [x12]\t\t// {imp, sel} = *bucket\n//在iOS下bucket结构为{imp, sel}，mac下为{sel, imp}\n\n1:\tcmp\tp9, p1\t\t\t// if (bucket->sel != _cmd)\n//比较bucket的sel和所需查找的_cmd是否相等\n\n\tb.ne\t2f\t\t\t//     scan more\n//如果不相等 跳转到2\n\n\tCacheHit $0\t\t\t// call or return imp\n//如果缓存命中，则直接返回imp\n\t\n2:\t// not hit: p12 = not-hit bucket\n\tCheckMiss $0\t\t\t// miss if bucket->sel == 0\n//首先检查bucket的_sel是否等于0，如果等于0，跳转到CheckMiss\n\n\tcmp\tp12, p10\t\t// wrap if bucket == buckets\n//判断获取的bucket是否是buckets中的第一个\n\n\tb.eq\t3f\n//如果遍历到数组的首个元素，则跳转到3，之后不会返回来继续，否则形成死循环\n\n\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// {imp, sel} = *--bucket\n//如果不是数组首个元素，则取得前一个bucket的imp和sel，继续进行比较\n\n\tb\t1b\t\t\t// loop\n\n3:\t// wrap: p12 = first bucket, w11 = mask\n#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16\n\tadd\tp12, p12, p11, LSR #(48 - (1+PTRSHIFT))\n\t\t\t\t\t// p12 = buckets + (mask << 1+PTRSHIFT)\n//mask为数组个数capacity减一，(mask << 1+PTRSHIFT)为mask * 16，即获取数组最后一个bucket赋值给p12\n\n#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4\n\tadd\tp12, p12, p11, LSL #(1+PTRSHIFT)\n\t\t\t\t\t// p12 = buckets + (mask << 1+PTRSHIFT)\n#else\n#error Unsupported cache mask storage for ARM64.\n#endif\n\n\t// Clone scanning loop to miss instead of hang when cache is corrupt.\n\t// The slow path may detect any corruption and halt later.\n\n\tldp\tp17, p9, [x12]\t\t// {imp, sel} = *bucket\n1:\tcmp\tp9, p1\t\t\t// if (bucket->sel != _cmd)\n\tb.ne\t2f\t\t\t//     scan more\n\tCacheHit $0\t\t\t// call or return imp\n\t\n2:\t// not hit: p12 = not-hit bucket\n\tCheckMiss $0\t\t\t// miss if bucket->sel == 0\n\tcmp\tp12, p10\t\t// wrap if bucket == buckets\n\tb.eq\t3f\n\tldp\tp17, p9, [x12, #-BUCKET_SIZE]!\t// {imp, sel} = *--bucket\n\tb\t1b\t\t\t// loop\n\nLLookupEnd$1:\nLLookupRecover$1:\n3:\t// double wrap\n\tJumpMiss $0\n\n.endmacro\n```\n> 分析：\n> 1. 找到isa指向的类，偏移16字节后取到cache_t cache元素的首地址，首地址在iOS下为`_maskAndBuckets`赋值到p11\n> 2. p11 & 0x0000ffffffffffff，得到低48位的buckets\n> 3. p11逻辑右移48位，得到mask，mask & _cmd得到数组buckets起始查找位置的index\n> 4. index << 4，即index * 16字节，获取到index所指向bucket的首地址p12\n> 5. p17, p9 分别为imp，sel\n>  ///第一步\n> 6. 比较p9和p1(即传入的第二个参数，所要查找的SEL _cmp)\n> 7. 如果不想等，则跳转到2f，如果相等则缓存命中，返回sel所对应的函数指针地址imp\n> ///第二步\n> 8. 首先检查bucket的sel是否等于0，如果等于0则跳转到`CheckMiss`\n> 9. 如果bucket的sel不等于0，判断bucket是否为数组第一个元素，如果是，则跳转到第三步，之后不会走下一步，而是直接走第三步之后的代码，否则形成死循环\n> 10. 如果bucket不是数组第一个元素，则获取前一个bucket，将新的imp和sel赋值到p17和p9，并跳转到第一步进行循环\n\n> ///第三步\n> 11. mask为数组buckets元素个数(capacity-1)，mask << 4，即获取数组最后一个元素bucket的首地址，赋值给p12\n\n> 12.之后的第一步和上面第一步一样，第二步如果走到数组buckets的第一个元素仍然没有找到，则直接跳转到第三步即`JumpMiss`\n\n![cachelookup.png](https://upload-images.jianshu.io/upload_images/1395687-45650706f1f09463.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 4. `CheckMiss`源码分析\n```\n.macro CheckMiss\n\t// miss if bucket->sel == 0\n.if $0 == GETIMP\n\tcbz\tp9, LGetImpMiss\n.elseif $0 == NORMAL\n\tcbz\tp9, __objc_msgSend_uncached\n.elseif $0 == LOOKUP\n\tcbz\tp9, __objc_msgLookup_uncached\n.else\n.abort oops\n.endif\n.endmacro\n```\n> 分析：此时为NORMAL模式，则进入`__objc_msgSend_uncached`流程\n\n#### 5. `__objc_msgSend_uncached`源码分析\n```\nSTATIC_ENTRY __objc_msgSend_uncached\n\tUNWIND __objc_msgSend_uncached, FrameWithNoSaves\n\n\t// THIS IS NOT A CALLABLE C FUNCTION\n\t// Out-of-band p16 is the class to search\n\t\n\tMethodTableLookup\n\tTailCallFunctionPointer x17\n\n\tEND_ENTRY __objc_msgSend_uncached\n```\n> 分析：此时快速缓存查找没有找到对应imp，调用`MethodTableLookup`函数中调用`_lookUpImpOrForward`，进入对应类或元类的methodlist查找流程","slug":"2020-09-20-objc_msgSend源码解析(一)","published":1,"updated":"2021-06-19T03:46:24.087Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbq0001vbjrj0cdm53h3","content":"<p><a href=\"https://www.jianshu.com/p/55daf526120d\">objc_msgSend源码解析(一)</a><br><a href=\"https://www.jianshu.com/p/7128dac1f0e8\">objc_msgSend源码解析(二)</a></p>\n<h4 id=\"1-objc-msgSend源码解析\"><a href=\"#1-objc-msgSend源码解析\" class=\"headerlink\" title=\"1. objc_msgSend源码解析\"></a>1. <code>objc_msgSend</code>源码解析</h4><p>在 objc4源码中全局搜索<code>objc_msgSend</code>可知该方法由汇编实现，在iOS平台下实现是在<code>objc-msg-arm64.s</code>文件中。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENTRY _objc_msgSend </span><br><span class=\"line\"><span class=\"regexp\">//</span>进入objc_msgSend流程</span><br><span class=\"line\"></span><br><span class=\"line\">cmp\tp0, <span class=\"comment\">#0\t\t\t// nil check and tagged pointer check</span></span><br><span class=\"line\"><span class=\"regexp\">//</span>p0为第一个参数消息接收者，判断消息接收者是否为nil或者为taggedPointer类型</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#if SUPPORT_TAGGED_POINTERS</span></span><br><span class=\"line\">\tb.le\tLNilOrTagged\t\t<span class=\"regexp\">//</span>  (MSB tagged pointer looks negative)</span><br><span class=\"line\">    <span class=\"regexp\">//</span>如果为taggedPointer 则跳转到LNilOrTagged</span><br><span class=\"line\"><span class=\"comment\">#else</span></span><br><span class=\"line\">\tb.eq\tLReturnZero</span><br><span class=\"line\">    <span class=\"regexp\">//</span>如果为nil 则跳转到LReturnZero</span><br><span class=\"line\"><span class=\"comment\">#endif</span></span><br><span class=\"line\"></span><br><span class=\"line\">ldr\tp13, [x0]\t\t<span class=\"regexp\">//</span> p13 = isa</span><br><span class=\"line\"><span class=\"regexp\">//</span>取出消息接收者的isa</span><br><span class=\"line\"></span><br><span class=\"line\">\tGetClassFromIsa_p16 p13\t\t<span class=\"regexp\">//</span> p16 = class</span><br><span class=\"line\"><span class=\"regexp\">//</span>获取isa指向的class</span><br><span class=\"line\"></span><br><span class=\"line\">LGetIsaDone:</span><br><span class=\"line\">\t<span class=\"regexp\">//</span> calls imp or objc_msgSend_uncached</span><br><span class=\"line\">\tCacheLookup NORMAL, _objc_msgSend</span><br><span class=\"line\"><span class=\"regexp\">//</span>调用CacheLookup的NORMAL模式</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#if SUPPORT_TAGGED_POINTERS</span></span><br><span class=\"line\">LNilOrTagged:</span><br><span class=\"line\">\tb.eq\tLReturnZero\t\t<span class=\"regexp\">//</span> nil check</span><br><span class=\"line\">    <span class=\"regexp\">//</span>taggedPointer作为消息接收者第一步同样也是跳转到LReturnZero</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"regexp\">//</span> tagged 为taggedPointer的特殊处理</span><br><span class=\"line\">\tadrp\tx10, _objc_debug_taggedpointer_classes@PAGE</span><br><span class=\"line\">\tadd\tx10, x10, _objc_debug_taggedpointer_classes@PAGEOFF</span><br><span class=\"line\">\tubfx\tx11, x0, <span class=\"comment\">#60, #4</span></span><br><span class=\"line\">\tldr\tx16, [x10, x11, LSL <span class=\"comment\">#3]</span></span><br><span class=\"line\">\tadrp\tx10, _OBJC_CLASS_<span class=\"variable\">$___NSUnrecognizedTaggedPointer</span>@PAGE</span><br><span class=\"line\">\tadd\tx10, x10, _OBJC_CLASS_<span class=\"variable\">$___NSUnrecognizedTaggedPointer</span>@PAGEOFF</span><br><span class=\"line\">\tcmp\tx10, x16</span><br><span class=\"line\">\tb.ne\tLGetIsaDone</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"regexp\">//</span> ext tagged</span><br><span class=\"line\">\tadrp\tx10, _objc_debug_taggedpointer_ext_classes@PAGE</span><br><span class=\"line\">\tadd\tx10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF</span><br><span class=\"line\">\tubfx\tx11, x0, <span class=\"comment\">#52, #8</span></span><br><span class=\"line\">\tldr\tx16, [x10, x11, LSL <span class=\"comment\">#3]</span></span><br><span class=\"line\">\tb\tLGetIsaDone</span><br><span class=\"line\"><span class=\"regexp\">//</span> SUPPORT_TAGGED_POINTERS</span><br><span class=\"line\"><span class=\"comment\">#endif</span></span><br><span class=\"line\"></span><br><span class=\"line\">LReturnZero:</span><br><span class=\"line\">    <span class=\"regexp\">//</span>消息接收者为nil或者taggedPointer类型都是直接return</span><br><span class=\"line\">\t<span class=\"regexp\">//</span> x0 is already zero</span><br><span class=\"line\">\tmov\tx1, <span class=\"comment\">#0</span></span><br><span class=\"line\">\tmovi\td0, <span class=\"comment\">#0</span></span><br><span class=\"line\">\tmovi\td1, <span class=\"comment\">#0</span></span><br><span class=\"line\">\tmovi\td2, <span class=\"comment\">#0</span></span><br><span class=\"line\">\tmovi\td3, <span class=\"comment\">#0</span></span><br><span class=\"line\">\tret</span><br><span class=\"line\"></span><br><span class=\"line\">\tEND_ENTRY _objc_msgSend</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>分析：</p>\n<ol>\n<li>p0为第一个参数消息接收者，判断消息接收者是否为nil或者为taggedPointer类型</li>\n<li>如果为nil或者taggedPointer 则跳转到LReturnZero，直接return</li>\n<li>如果不为nil或taggedPointer，则将消息接收者第一个地址的isa取出，赋值给p13</li>\n<li>将p13即消息接收者的isa作为参数，调用<code>GetClassFromIsa_p16</code>，获取isa指向的类或者元类</li>\n<li>然后调用<code>CacheLookup</code>函数的NORMAL模式</li>\n</ol>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-d6d9b57eee1f2ee3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"objc_msgSend.png\"></p>\n<h4 id=\"2-GetClassFromIsa-p16源码解析\"><a href=\"#2-GetClassFromIsa-p16源码解析\" class=\"headerlink\" title=\"2. GetClassFromIsa_p16源码解析\"></a>2. <code>GetClassFromIsa_p16</code>源码解析</h4><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.macro GetClassFromIsa_p16 <span class=\"regexp\">/* src */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#if SUPPORT_INDEXED_ISA</span></span><br><span class=\"line\">\t<span class=\"regexp\">//</span> Indexed isa</span><br><span class=\"line\">\tmov\tp16, <span class=\"variable\">$0</span>\t\t\t<span class=\"regexp\">//</span> optimistically set dst = src</span><br><span class=\"line\">\ttbz\tp16, <span class=\"comment\">#ISA_INDEX_IS_NPI_BIT, 1f\t// done if not non-pointer isa</span></span><br><span class=\"line\">\t<span class=\"regexp\">//</span> isa <span class=\"keyword\">in</span> p16 is indexed</span><br><span class=\"line\">\tadrp\tx10, _objc_indexed_classes@PAGE</span><br><span class=\"line\">\tadd\tx10, x10, _objc_indexed_classes@PAGEOFF</span><br><span class=\"line\">\tubfx\tp16, p16, <span class=\"comment\">#ISA_INDEX_SHIFT, #ISA_INDEX_BITS  // extract index</span></span><br><span class=\"line\">\tldr\tp16, [x10, p16, UXTP <span class=\"comment\">#PTRSHIFT]\t// load class from array</span></span><br><span class=\"line\"><span class=\"number\">1</span>:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span>在<span class=\"number\">64</span>位下根据传入的第一个参数 即 isa &amp; ISA_MASK 取出class</span><br><span class=\"line\"><span class=\"comment\">#elif __LP64__</span></span><br><span class=\"line\">\t<span class=\"regexp\">//</span> <span class=\"number\">64</span>-bit packed isa</span><br><span class=\"line\">\tand\tp16, <span class=\"variable\">$0</span>, <span class=\"comment\">#ISA_MASK</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#else</span></span><br><span class=\"line\">\t<span class=\"regexp\">//</span> <span class=\"number\">32</span>-bit raw isa</span><br><span class=\"line\">\tmov\tp16, <span class=\"variable\">$0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#endif</span></span><br><span class=\"line\"></span><br><span class=\"line\">.endmacro</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>分析： 在64位下根据传入的第一个参数 即 isa &amp; ISA_MASK 取出class</p>\n</blockquote>\n<h4 id=\"3-CacheLookup源码解析\"><a href=\"#3-CacheLookup源码解析\" class=\"headerlink\" title=\"3. CacheLookup源码解析\"></a>3. <code>CacheLookup</code>源码解析</h4><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#define PTRSHIFT 3  // 1&lt;&lt;PTRSHIFT == PTRSIZE</span></span><br><span class=\"line\"></span><br><span class=\"line\">.macro CacheLookup</span><br><span class=\"line\"></span><br><span class=\"line\">LLookupStart<span class=\"variable\">$1</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"regexp\">//</span> p1 = SEL, p16 = isa</span><br><span class=\"line\">\tldr\tp11, [x16, <span class=\"comment\">#CACHE]\t\t\t\t// p11 = mask|buckets</span></span><br><span class=\"line\"><span class=\"regexp\">//</span>获取isa指向class中的cache_t cache结构中的mask|buckets</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span>在iOS下走以下分支</span><br><span class=\"line\"><span class=\"comment\">#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16</span></span><br><span class=\"line\"><span class=\"regexp\">//</span>将p11中存的mask|buckets &amp; <span class=\"number\">0</span>x0000ffffffffffff，获取低<span class=\"number\">48</span>位的为buckets</span><br><span class=\"line\">\tand\tp10, p11, <span class=\"comment\">#0x0000ffffffffffff\t// p10 = buckets</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span>将p11中存的mask|buckets 逻辑右移<span class=\"number\">48</span>位，即将buckets顶出去，留下<span class=\"number\">16</span>位的mask；然后将获取到的mask &amp; p1(_cmd)，获取到buckets数组中要查找的index，即index = _cmd &amp; mask</span><br><span class=\"line\">\tand\tp12, p1, p11, LSR <span class=\"comment\">#48\t\t// x12 = _cmd &amp; mask</span></span><br><span class=\"line\"><span class=\"comment\">#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4</span></span><br><span class=\"line\">\tand\tp10, p11, <span class=\"comment\">#~0xf\t\t\t// p10 = buckets</span></span><br><span class=\"line\">\tand\tp11, p11, <span class=\"comment\">#0xf\t\t\t// p11 = maskShift</span></span><br><span class=\"line\">\tmov\tp12, <span class=\"comment\">#0xffff</span></span><br><span class=\"line\">\tlsr\tp11, p12, p11\t\t\t\t<span class=\"regexp\">//</span> p11 = mask = <span class=\"number\">0</span>xffff &gt;&gt; p11</span><br><span class=\"line\">\tand\tp12, p1, p11\t\t\t\t<span class=\"regexp\">//</span> x12 = _cmd &amp; mask</span><br><span class=\"line\"><span class=\"comment\">#else</span></span><br><span class=\"line\"><span class=\"comment\">#error Unsupported cache mask storage for ARM64.</span></span><br><span class=\"line\"><span class=\"comment\">#endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\tadd\tp12, p10, p12, LSL <span class=\"comment\">#(1+PTRSHIFT)</span></span><br><span class=\"line\">\t\t             <span class=\"regexp\">//</span> p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (<span class=\"number\">1</span>+PTRSHIFT))</span><br><span class=\"line\"><span class=\"regexp\">//</span>(<span class=\"number\">1</span>+PTRSHIFT) = (<span class=\"number\">1</span>+<span class=\"number\">3</span>) = <span class=\"number\">4</span>，由于一个bucket结构包含 IMP _imp，SEL _sel，即<span class=\"number\">16</span>位，所以((_cmd &amp; mask) &lt;&lt; (<span class=\"number\">1</span>+PTRSHIFT))含义为index * <span class=\"number\">16</span>，buckets + ((_cmd &amp; mask) &lt;&lt; (<span class=\"number\">1</span>+PTRSHIFT))含义为获取到index位置bucket的首地址赋值到p12</span><br><span class=\"line\"></span><br><span class=\"line\">\tldp\tp17, p9, [x12]\t\t<span class=\"regexp\">//</span> &#123;imp, sel&#125; = *bucket</span><br><span class=\"line\"><span class=\"regexp\">//</span>在iOS下bucket结构为&#123;imp, sel&#125;，mac下为&#123;sel, imp&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>:\tcmp\tp9, p1\t\t\t<span class=\"regexp\">//</span> <span class=\"keyword\">if</span> (bucket-&gt;sel != _cmd)</span><br><span class=\"line\"><span class=\"regexp\">//</span>比较bucket的sel和所需查找的_cmd是否相等</span><br><span class=\"line\"></span><br><span class=\"line\">\tb.ne\t<span class=\"number\">2</span>f\t\t\t<span class=\"regexp\">//</span>     scan more</span><br><span class=\"line\"><span class=\"regexp\">//</span>如果不相等 跳转到<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tCacheHit <span class=\"variable\">$0</span>\t\t\t<span class=\"regexp\">//</span> call or return imp</span><br><span class=\"line\"><span class=\"regexp\">//</span>如果缓存命中，则直接返回imp</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"number\">2</span>:\t<span class=\"regexp\">//</span> not hit: p12 = not-hit bucket</span><br><span class=\"line\">\tCheckMiss <span class=\"variable\">$0</span>\t\t\t<span class=\"regexp\">//</span> miss <span class=\"keyword\">if</span> bucket-&gt;sel == <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"regexp\">//</span>首先检查bucket的_sel是否等于<span class=\"number\">0</span>，如果等于<span class=\"number\">0</span>，跳转到CheckMiss</span><br><span class=\"line\"></span><br><span class=\"line\">\tcmp\tp12, p10\t\t<span class=\"regexp\">//</span> wrap <span class=\"keyword\">if</span> bucket == buckets</span><br><span class=\"line\"><span class=\"regexp\">//</span>判断获取的bucket是否是buckets中的第一个</span><br><span class=\"line\"></span><br><span class=\"line\">\tb.eq\t<span class=\"number\">3</span>f</span><br><span class=\"line\"><span class=\"regexp\">//</span>如果遍历到数组的首个元素，则跳转到<span class=\"number\">3</span>，之后不会返回来继续，否则形成死循环</span><br><span class=\"line\"></span><br><span class=\"line\">\tldp\tp17, p9, [x12, <span class=\"comment\">#-BUCKET_SIZE]!\t// &#123;imp, sel&#125; = *--bucket</span></span><br><span class=\"line\"><span class=\"regexp\">//</span>如果不是数组首个元素，则取得前一个bucket的imp和sel，继续进行比较</span><br><span class=\"line\"></span><br><span class=\"line\">\tb\t<span class=\"number\">1</span>b\t\t\t<span class=\"regexp\">//</span> loop</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3</span>:\t<span class=\"regexp\">//</span> wrap: p12 = first bucket, w11 = mask</span><br><span class=\"line\"><span class=\"comment\">#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16</span></span><br><span class=\"line\">\tadd\tp12, p12, p11, LSR <span class=\"comment\">#(48 - (1+PTRSHIFT))</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"regexp\">//</span> p12 = buckets + (mask &lt;&lt; <span class=\"number\">1</span>+PTRSHIFT)</span><br><span class=\"line\"><span class=\"regexp\">//m</span>ask为数组个数capacity减一，(mask &lt;&lt; <span class=\"number\">1</span>+PTRSHIFT)为mask * <span class=\"number\">16</span>，即获取数组最后一个bucket赋值给p12</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4</span></span><br><span class=\"line\">\tadd\tp12, p12, p11, LSL <span class=\"comment\">#(1+PTRSHIFT)</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"regexp\">//</span> p12 = buckets + (mask &lt;&lt; <span class=\"number\">1</span>+PTRSHIFT)</span><br><span class=\"line\"><span class=\"comment\">#else</span></span><br><span class=\"line\"><span class=\"comment\">#error Unsupported cache mask storage for ARM64.</span></span><br><span class=\"line\"><span class=\"comment\">#endif</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"regexp\">//</span> Clone scanning loop to miss instead of hang when cache is corrupt.</span><br><span class=\"line\">\t<span class=\"regexp\">//</span> The slow path may detect any corruption and halt later.</span><br><span class=\"line\"></span><br><span class=\"line\">\tldp\tp17, p9, [x12]\t\t<span class=\"regexp\">//</span> &#123;imp, sel&#125; = *bucket</span><br><span class=\"line\"><span class=\"number\">1</span>:\tcmp\tp9, p1\t\t\t<span class=\"regexp\">//</span> <span class=\"keyword\">if</span> (bucket-&gt;sel != _cmd)</span><br><span class=\"line\">\tb.ne\t<span class=\"number\">2</span>f\t\t\t<span class=\"regexp\">//</span>     scan more</span><br><span class=\"line\">\tCacheHit <span class=\"variable\">$0</span>\t\t\t<span class=\"regexp\">//</span> call or return imp</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"number\">2</span>:\t<span class=\"regexp\">//</span> not hit: p12 = not-hit bucket</span><br><span class=\"line\">\tCheckMiss <span class=\"variable\">$0</span>\t\t\t<span class=\"regexp\">//</span> miss <span class=\"keyword\">if</span> bucket-&gt;sel == <span class=\"number\">0</span></span><br><span class=\"line\">\tcmp\tp12, p10\t\t<span class=\"regexp\">//</span> wrap <span class=\"keyword\">if</span> bucket == buckets</span><br><span class=\"line\">\tb.eq\t<span class=\"number\">3</span>f</span><br><span class=\"line\">\tldp\tp17, p9, [x12, <span class=\"comment\">#-BUCKET_SIZE]!\t// &#123;imp, sel&#125; = *--bucket</span></span><br><span class=\"line\">\tb\t<span class=\"number\">1</span>b\t\t\t<span class=\"regexp\">//</span> loop</span><br><span class=\"line\"></span><br><span class=\"line\">LLookupEnd<span class=\"variable\">$1</span>:</span><br><span class=\"line\">LLookupRecover<span class=\"variable\">$1</span>:</span><br><span class=\"line\"><span class=\"number\">3</span>:\t<span class=\"regexp\">//</span> double wrap</span><br><span class=\"line\">\tJumpMiss <span class=\"variable\">$0</span></span><br><span class=\"line\"></span><br><span class=\"line\">.endmacro</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>分析：</p>\n<ol>\n<li>找到isa指向的类，偏移16字节后取到cache_t cache元素的首地址，首地址在iOS下为<code>_maskAndBuckets</code>赋值到p11</li>\n<li>p11 &amp; 0x0000ffffffffffff，得到低48位的buckets</li>\n<li>p11逻辑右移48位，得到mask，mask &amp; _cmd得到数组buckets起始查找位置的index</li>\n<li>index &lt;&lt; 4，即index * 16字节，获取到index所指向bucket的首地址p12</li>\n<li>p17, p9 分别为imp，sel<br>///第一步</li>\n<li>比较p9和p1(即传入的第二个参数，所要查找的SEL _cmp)</li>\n<li>如果不想等，则跳转到2f，如果相等则缓存命中，返回sel所对应的函数指针地址imp<br>///第二步</li>\n<li>首先检查bucket的sel是否等于0，如果等于0则跳转到<code>CheckMiss</code></li>\n<li>如果bucket的sel不等于0，判断bucket是否为数组第一个元素，如果是，则跳转到第三步，之后不会走下一步，而是直接走第三步之后的代码，否则形成死循环</li>\n<li>如果bucket不是数组第一个元素，则获取前一个bucket，将新的imp和sel赋值到p17和p9，并跳转到第一步进行循环</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>///第三步<br>11. mask为数组buckets元素个数(capacity-1)，mask &lt;&lt; 4，即获取数组最后一个元素bucket的首地址，赋值给p12</p>\n</blockquote>\n<blockquote>\n<p>12.之后的第一步和上面第一步一样，第二步如果走到数组buckets的第一个元素仍然没有找到，则直接跳转到第三步即<code>JumpMiss</code></p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-45650706f1f09463.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"cachelookup.png\"></p>\n<h4 id=\"4-CheckMiss源码分析\"><a href=\"#4-CheckMiss源码分析\" class=\"headerlink\" title=\"4. CheckMiss源码分析\"></a>4. <code>CheckMiss</code>源码分析</h4><figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">.macro</span> CheckMiss</span><br><span class=\"line\">\t<span class=\"string\">//</span> miss <span class=\"keyword\">if</span> bucket-&gt;sel == 0</span><br><span class=\"line\"><span class=\"string\">.if</span> $0 == GETIMP</span><br><span class=\"line\">\tcbz\tp9, LGetImpMiss</span><br><span class=\"line\"><span class=\"string\">.elseif</span> $0 == NORMAL</span><br><span class=\"line\">\tcbz\tp9, __objc_msgSend_uncached</span><br><span class=\"line\"><span class=\"string\">.elseif</span> $0 == LOOKUP</span><br><span class=\"line\">\tcbz\tp9, __objc_msgLookup_uncached</span><br><span class=\"line\"><span class=\"string\">.else</span></span><br><span class=\"line\"><span class=\"string\">.abort</span> oops</span><br><span class=\"line\"><span class=\"string\">.endif</span></span><br><span class=\"line\"><span class=\"string\">.endmacro</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>分析：此时为NORMAL模式，则进入<code>__objc_msgSend_uncached</code>流程</p>\n</blockquote>\n<h4 id=\"5-objc-msgSend-uncached源码分析\"><a href=\"#5-objc-msgSend-uncached源码分析\" class=\"headerlink\" title=\"5. __objc_msgSend_uncached源码分析\"></a>5. <code>__objc_msgSend_uncached</code>源码分析</h4><figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class=\"line\">\tUNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class=\"line\"></span><br><span class=\"line\">\t// THIS <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> A CALLABLE C <span class=\"keyword\">FUNCTION</span></span><br><span class=\"line\">\t// <span class=\"keyword\">Out</span>-<span class=\"keyword\">of</span>-band p16 <span class=\"keyword\">is</span> the <span class=\"keyword\">class</span> <span class=\"keyword\">to</span> <span class=\"keyword\">search</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tMethodTableLookup</span><br><span class=\"line\">\tTailCallFunctionPointer x17</span><br><span class=\"line\"></span><br><span class=\"line\">\tEND_ENTRY __objc_msgSend_uncached</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>分析：此时快速缓存查找没有找到对应imp，调用<code>MethodTableLookup</code>函数中调用<code>_lookUpImpOrForward</code>，进入对应类或元类的methodlist查找流程</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.jianshu.com/p/55daf526120d\">objc_msgSend源码解析(一)</a><br><a href=\"https://www.jianshu.com/p/7128dac1f0e8\">objc_msgSend源码解析(二)</a></p>\n<h4 id=\"1-objc-msgSend源码解析\"><a href=\"#1-objc-msgSend源码解析\" class=\"headerlink\" title=\"1. objc_msgSend源码解析\"></a>1. <code>objc_msgSend</code>源码解析</h4><p>在 objc4源码中全局搜索<code>objc_msgSend</code>可知该方法由汇编实现，在iOS平台下实现是在<code>objc-msg-arm64.s</code>文件中。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENTRY _objc_msgSend </span><br><span class=\"line\"><span class=\"regexp\">//</span>进入objc_msgSend流程</span><br><span class=\"line\"></span><br><span class=\"line\">cmp\tp0, <span class=\"comment\">#0\t\t\t// nil check and tagged pointer check</span></span><br><span class=\"line\"><span class=\"regexp\">//</span>p0为第一个参数消息接收者，判断消息接收者是否为nil或者为taggedPointer类型</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#if SUPPORT_TAGGED_POINTERS</span></span><br><span class=\"line\">\tb.le\tLNilOrTagged\t\t<span class=\"regexp\">//</span>  (MSB tagged pointer looks negative)</span><br><span class=\"line\">    <span class=\"regexp\">//</span>如果为taggedPointer 则跳转到LNilOrTagged</span><br><span class=\"line\"><span class=\"comment\">#else</span></span><br><span class=\"line\">\tb.eq\tLReturnZero</span><br><span class=\"line\">    <span class=\"regexp\">//</span>如果为nil 则跳转到LReturnZero</span><br><span class=\"line\"><span class=\"comment\">#endif</span></span><br><span class=\"line\"></span><br><span class=\"line\">ldr\tp13, [x0]\t\t<span class=\"regexp\">//</span> p13 = isa</span><br><span class=\"line\"><span class=\"regexp\">//</span>取出消息接收者的isa</span><br><span class=\"line\"></span><br><span class=\"line\">\tGetClassFromIsa_p16 p13\t\t<span class=\"regexp\">//</span> p16 = class</span><br><span class=\"line\"><span class=\"regexp\">//</span>获取isa指向的class</span><br><span class=\"line\"></span><br><span class=\"line\">LGetIsaDone:</span><br><span class=\"line\">\t<span class=\"regexp\">//</span> calls imp or objc_msgSend_uncached</span><br><span class=\"line\">\tCacheLookup NORMAL, _objc_msgSend</span><br><span class=\"line\"><span class=\"regexp\">//</span>调用CacheLookup的NORMAL模式</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#if SUPPORT_TAGGED_POINTERS</span></span><br><span class=\"line\">LNilOrTagged:</span><br><span class=\"line\">\tb.eq\tLReturnZero\t\t<span class=\"regexp\">//</span> nil check</span><br><span class=\"line\">    <span class=\"regexp\">//</span>taggedPointer作为消息接收者第一步同样也是跳转到LReturnZero</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"regexp\">//</span> tagged 为taggedPointer的特殊处理</span><br><span class=\"line\">\tadrp\tx10, _objc_debug_taggedpointer_classes@PAGE</span><br><span class=\"line\">\tadd\tx10, x10, _objc_debug_taggedpointer_classes@PAGEOFF</span><br><span class=\"line\">\tubfx\tx11, x0, <span class=\"comment\">#60, #4</span></span><br><span class=\"line\">\tldr\tx16, [x10, x11, LSL <span class=\"comment\">#3]</span></span><br><span class=\"line\">\tadrp\tx10, _OBJC_CLASS_<span class=\"variable\">$___NSUnrecognizedTaggedPointer</span>@PAGE</span><br><span class=\"line\">\tadd\tx10, x10, _OBJC_CLASS_<span class=\"variable\">$___NSUnrecognizedTaggedPointer</span>@PAGEOFF</span><br><span class=\"line\">\tcmp\tx10, x16</span><br><span class=\"line\">\tb.ne\tLGetIsaDone</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"regexp\">//</span> ext tagged</span><br><span class=\"line\">\tadrp\tx10, _objc_debug_taggedpointer_ext_classes@PAGE</span><br><span class=\"line\">\tadd\tx10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF</span><br><span class=\"line\">\tubfx\tx11, x0, <span class=\"comment\">#52, #8</span></span><br><span class=\"line\">\tldr\tx16, [x10, x11, LSL <span class=\"comment\">#3]</span></span><br><span class=\"line\">\tb\tLGetIsaDone</span><br><span class=\"line\"><span class=\"regexp\">//</span> SUPPORT_TAGGED_POINTERS</span><br><span class=\"line\"><span class=\"comment\">#endif</span></span><br><span class=\"line\"></span><br><span class=\"line\">LReturnZero:</span><br><span class=\"line\">    <span class=\"regexp\">//</span>消息接收者为nil或者taggedPointer类型都是直接return</span><br><span class=\"line\">\t<span class=\"regexp\">//</span> x0 is already zero</span><br><span class=\"line\">\tmov\tx1, <span class=\"comment\">#0</span></span><br><span class=\"line\">\tmovi\td0, <span class=\"comment\">#0</span></span><br><span class=\"line\">\tmovi\td1, <span class=\"comment\">#0</span></span><br><span class=\"line\">\tmovi\td2, <span class=\"comment\">#0</span></span><br><span class=\"line\">\tmovi\td3, <span class=\"comment\">#0</span></span><br><span class=\"line\">\tret</span><br><span class=\"line\"></span><br><span class=\"line\">\tEND_ENTRY _objc_msgSend</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>分析：</p>\n<ol>\n<li>p0为第一个参数消息接收者，判断消息接收者是否为nil或者为taggedPointer类型</li>\n<li>如果为nil或者taggedPointer 则跳转到LReturnZero，直接return</li>\n<li>如果不为nil或taggedPointer，则将消息接收者第一个地址的isa取出，赋值给p13</li>\n<li>将p13即消息接收者的isa作为参数，调用<code>GetClassFromIsa_p16</code>，获取isa指向的类或者元类</li>\n<li>然后调用<code>CacheLookup</code>函数的NORMAL模式</li>\n</ol>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-d6d9b57eee1f2ee3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"objc_msgSend.png\"></p>\n<h4 id=\"2-GetClassFromIsa-p16源码解析\"><a href=\"#2-GetClassFromIsa-p16源码解析\" class=\"headerlink\" title=\"2. GetClassFromIsa_p16源码解析\"></a>2. <code>GetClassFromIsa_p16</code>源码解析</h4><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.macro GetClassFromIsa_p16 <span class=\"regexp\">/* src */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#if SUPPORT_INDEXED_ISA</span></span><br><span class=\"line\">\t<span class=\"regexp\">//</span> Indexed isa</span><br><span class=\"line\">\tmov\tp16, <span class=\"variable\">$0</span>\t\t\t<span class=\"regexp\">//</span> optimistically set dst = src</span><br><span class=\"line\">\ttbz\tp16, <span class=\"comment\">#ISA_INDEX_IS_NPI_BIT, 1f\t// done if not non-pointer isa</span></span><br><span class=\"line\">\t<span class=\"regexp\">//</span> isa <span class=\"keyword\">in</span> p16 is indexed</span><br><span class=\"line\">\tadrp\tx10, _objc_indexed_classes@PAGE</span><br><span class=\"line\">\tadd\tx10, x10, _objc_indexed_classes@PAGEOFF</span><br><span class=\"line\">\tubfx\tp16, p16, <span class=\"comment\">#ISA_INDEX_SHIFT, #ISA_INDEX_BITS  // extract index</span></span><br><span class=\"line\">\tldr\tp16, [x10, p16, UXTP <span class=\"comment\">#PTRSHIFT]\t// load class from array</span></span><br><span class=\"line\"><span class=\"number\">1</span>:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span>在<span class=\"number\">64</span>位下根据传入的第一个参数 即 isa &amp; ISA_MASK 取出class</span><br><span class=\"line\"><span class=\"comment\">#elif __LP64__</span></span><br><span class=\"line\">\t<span class=\"regexp\">//</span> <span class=\"number\">64</span>-bit packed isa</span><br><span class=\"line\">\tand\tp16, <span class=\"variable\">$0</span>, <span class=\"comment\">#ISA_MASK</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#else</span></span><br><span class=\"line\">\t<span class=\"regexp\">//</span> <span class=\"number\">32</span>-bit raw isa</span><br><span class=\"line\">\tmov\tp16, <span class=\"variable\">$0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#endif</span></span><br><span class=\"line\"></span><br><span class=\"line\">.endmacro</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>分析： 在64位下根据传入的第一个参数 即 isa &amp; ISA_MASK 取出class</p>\n</blockquote>\n<h4 id=\"3-CacheLookup源码解析\"><a href=\"#3-CacheLookup源码解析\" class=\"headerlink\" title=\"3. CacheLookup源码解析\"></a>3. <code>CacheLookup</code>源码解析</h4><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#define PTRSHIFT 3  // 1&lt;&lt;PTRSHIFT == PTRSIZE</span></span><br><span class=\"line\"></span><br><span class=\"line\">.macro CacheLookup</span><br><span class=\"line\"></span><br><span class=\"line\">LLookupStart<span class=\"variable\">$1</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"regexp\">//</span> p1 = SEL, p16 = isa</span><br><span class=\"line\">\tldr\tp11, [x16, <span class=\"comment\">#CACHE]\t\t\t\t// p11 = mask|buckets</span></span><br><span class=\"line\"><span class=\"regexp\">//</span>获取isa指向class中的cache_t cache结构中的mask|buckets</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span>在iOS下走以下分支</span><br><span class=\"line\"><span class=\"comment\">#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16</span></span><br><span class=\"line\"><span class=\"regexp\">//</span>将p11中存的mask|buckets &amp; <span class=\"number\">0</span>x0000ffffffffffff，获取低<span class=\"number\">48</span>位的为buckets</span><br><span class=\"line\">\tand\tp10, p11, <span class=\"comment\">#0x0000ffffffffffff\t// p10 = buckets</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span>将p11中存的mask|buckets 逻辑右移<span class=\"number\">48</span>位，即将buckets顶出去，留下<span class=\"number\">16</span>位的mask；然后将获取到的mask &amp; p1(_cmd)，获取到buckets数组中要查找的index，即index = _cmd &amp; mask</span><br><span class=\"line\">\tand\tp12, p1, p11, LSR <span class=\"comment\">#48\t\t// x12 = _cmd &amp; mask</span></span><br><span class=\"line\"><span class=\"comment\">#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4</span></span><br><span class=\"line\">\tand\tp10, p11, <span class=\"comment\">#~0xf\t\t\t// p10 = buckets</span></span><br><span class=\"line\">\tand\tp11, p11, <span class=\"comment\">#0xf\t\t\t// p11 = maskShift</span></span><br><span class=\"line\">\tmov\tp12, <span class=\"comment\">#0xffff</span></span><br><span class=\"line\">\tlsr\tp11, p12, p11\t\t\t\t<span class=\"regexp\">//</span> p11 = mask = <span class=\"number\">0</span>xffff &gt;&gt; p11</span><br><span class=\"line\">\tand\tp12, p1, p11\t\t\t\t<span class=\"regexp\">//</span> x12 = _cmd &amp; mask</span><br><span class=\"line\"><span class=\"comment\">#else</span></span><br><span class=\"line\"><span class=\"comment\">#error Unsupported cache mask storage for ARM64.</span></span><br><span class=\"line\"><span class=\"comment\">#endif</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\tadd\tp12, p10, p12, LSL <span class=\"comment\">#(1+PTRSHIFT)</span></span><br><span class=\"line\">\t\t             <span class=\"regexp\">//</span> p12 = buckets + ((_cmd &amp; mask) &lt;&lt; (<span class=\"number\">1</span>+PTRSHIFT))</span><br><span class=\"line\"><span class=\"regexp\">//</span>(<span class=\"number\">1</span>+PTRSHIFT) = (<span class=\"number\">1</span>+<span class=\"number\">3</span>) = <span class=\"number\">4</span>，由于一个bucket结构包含 IMP _imp，SEL _sel，即<span class=\"number\">16</span>位，所以((_cmd &amp; mask) &lt;&lt; (<span class=\"number\">1</span>+PTRSHIFT))含义为index * <span class=\"number\">16</span>，buckets + ((_cmd &amp; mask) &lt;&lt; (<span class=\"number\">1</span>+PTRSHIFT))含义为获取到index位置bucket的首地址赋值到p12</span><br><span class=\"line\"></span><br><span class=\"line\">\tldp\tp17, p9, [x12]\t\t<span class=\"regexp\">//</span> &#123;imp, sel&#125; = *bucket</span><br><span class=\"line\"><span class=\"regexp\">//</span>在iOS下bucket结构为&#123;imp, sel&#125;，mac下为&#123;sel, imp&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>:\tcmp\tp9, p1\t\t\t<span class=\"regexp\">//</span> <span class=\"keyword\">if</span> (bucket-&gt;sel != _cmd)</span><br><span class=\"line\"><span class=\"regexp\">//</span>比较bucket的sel和所需查找的_cmd是否相等</span><br><span class=\"line\"></span><br><span class=\"line\">\tb.ne\t<span class=\"number\">2</span>f\t\t\t<span class=\"regexp\">//</span>     scan more</span><br><span class=\"line\"><span class=\"regexp\">//</span>如果不相等 跳转到<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tCacheHit <span class=\"variable\">$0</span>\t\t\t<span class=\"regexp\">//</span> call or return imp</span><br><span class=\"line\"><span class=\"regexp\">//</span>如果缓存命中，则直接返回imp</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"number\">2</span>:\t<span class=\"regexp\">//</span> not hit: p12 = not-hit bucket</span><br><span class=\"line\">\tCheckMiss <span class=\"variable\">$0</span>\t\t\t<span class=\"regexp\">//</span> miss <span class=\"keyword\">if</span> bucket-&gt;sel == <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"regexp\">//</span>首先检查bucket的_sel是否等于<span class=\"number\">0</span>，如果等于<span class=\"number\">0</span>，跳转到CheckMiss</span><br><span class=\"line\"></span><br><span class=\"line\">\tcmp\tp12, p10\t\t<span class=\"regexp\">//</span> wrap <span class=\"keyword\">if</span> bucket == buckets</span><br><span class=\"line\"><span class=\"regexp\">//</span>判断获取的bucket是否是buckets中的第一个</span><br><span class=\"line\"></span><br><span class=\"line\">\tb.eq\t<span class=\"number\">3</span>f</span><br><span class=\"line\"><span class=\"regexp\">//</span>如果遍历到数组的首个元素，则跳转到<span class=\"number\">3</span>，之后不会返回来继续，否则形成死循环</span><br><span class=\"line\"></span><br><span class=\"line\">\tldp\tp17, p9, [x12, <span class=\"comment\">#-BUCKET_SIZE]!\t// &#123;imp, sel&#125; = *--bucket</span></span><br><span class=\"line\"><span class=\"regexp\">//</span>如果不是数组首个元素，则取得前一个bucket的imp和sel，继续进行比较</span><br><span class=\"line\"></span><br><span class=\"line\">\tb\t<span class=\"number\">1</span>b\t\t\t<span class=\"regexp\">//</span> loop</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3</span>:\t<span class=\"regexp\">//</span> wrap: p12 = first bucket, w11 = mask</span><br><span class=\"line\"><span class=\"comment\">#if CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_HIGH_16</span></span><br><span class=\"line\">\tadd\tp12, p12, p11, LSR <span class=\"comment\">#(48 - (1+PTRSHIFT))</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"regexp\">//</span> p12 = buckets + (mask &lt;&lt; <span class=\"number\">1</span>+PTRSHIFT)</span><br><span class=\"line\"><span class=\"regexp\">//m</span>ask为数组个数capacity减一，(mask &lt;&lt; <span class=\"number\">1</span>+PTRSHIFT)为mask * <span class=\"number\">16</span>，即获取数组最后一个bucket赋值给p12</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#elif CACHE_MASK_STORAGE == CACHE_MASK_STORAGE_LOW_4</span></span><br><span class=\"line\">\tadd\tp12, p12, p11, LSL <span class=\"comment\">#(1+PTRSHIFT)</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"regexp\">//</span> p12 = buckets + (mask &lt;&lt; <span class=\"number\">1</span>+PTRSHIFT)</span><br><span class=\"line\"><span class=\"comment\">#else</span></span><br><span class=\"line\"><span class=\"comment\">#error Unsupported cache mask storage for ARM64.</span></span><br><span class=\"line\"><span class=\"comment\">#endif</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"regexp\">//</span> Clone scanning loop to miss instead of hang when cache is corrupt.</span><br><span class=\"line\">\t<span class=\"regexp\">//</span> The slow path may detect any corruption and halt later.</span><br><span class=\"line\"></span><br><span class=\"line\">\tldp\tp17, p9, [x12]\t\t<span class=\"regexp\">//</span> &#123;imp, sel&#125; = *bucket</span><br><span class=\"line\"><span class=\"number\">1</span>:\tcmp\tp9, p1\t\t\t<span class=\"regexp\">//</span> <span class=\"keyword\">if</span> (bucket-&gt;sel != _cmd)</span><br><span class=\"line\">\tb.ne\t<span class=\"number\">2</span>f\t\t\t<span class=\"regexp\">//</span>     scan more</span><br><span class=\"line\">\tCacheHit <span class=\"variable\">$0</span>\t\t\t<span class=\"regexp\">//</span> call or return imp</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"number\">2</span>:\t<span class=\"regexp\">//</span> not hit: p12 = not-hit bucket</span><br><span class=\"line\">\tCheckMiss <span class=\"variable\">$0</span>\t\t\t<span class=\"regexp\">//</span> miss <span class=\"keyword\">if</span> bucket-&gt;sel == <span class=\"number\">0</span></span><br><span class=\"line\">\tcmp\tp12, p10\t\t<span class=\"regexp\">//</span> wrap <span class=\"keyword\">if</span> bucket == buckets</span><br><span class=\"line\">\tb.eq\t<span class=\"number\">3</span>f</span><br><span class=\"line\">\tldp\tp17, p9, [x12, <span class=\"comment\">#-BUCKET_SIZE]!\t// &#123;imp, sel&#125; = *--bucket</span></span><br><span class=\"line\">\tb\t<span class=\"number\">1</span>b\t\t\t<span class=\"regexp\">//</span> loop</span><br><span class=\"line\"></span><br><span class=\"line\">LLookupEnd<span class=\"variable\">$1</span>:</span><br><span class=\"line\">LLookupRecover<span class=\"variable\">$1</span>:</span><br><span class=\"line\"><span class=\"number\">3</span>:\t<span class=\"regexp\">//</span> double wrap</span><br><span class=\"line\">\tJumpMiss <span class=\"variable\">$0</span></span><br><span class=\"line\"></span><br><span class=\"line\">.endmacro</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>分析：</p>\n<ol>\n<li>找到isa指向的类，偏移16字节后取到cache_t cache元素的首地址，首地址在iOS下为<code>_maskAndBuckets</code>赋值到p11</li>\n<li>p11 &amp; 0x0000ffffffffffff，得到低48位的buckets</li>\n<li>p11逻辑右移48位，得到mask，mask &amp; _cmd得到数组buckets起始查找位置的index</li>\n<li>index &lt;&lt; 4，即index * 16字节，获取到index所指向bucket的首地址p12</li>\n<li>p17, p9 分别为imp，sel<br>///第一步</li>\n<li>比较p9和p1(即传入的第二个参数，所要查找的SEL _cmp)</li>\n<li>如果不想等，则跳转到2f，如果相等则缓存命中，返回sel所对应的函数指针地址imp<br>///第二步</li>\n<li>首先检查bucket的sel是否等于0，如果等于0则跳转到<code>CheckMiss</code></li>\n<li>如果bucket的sel不等于0，判断bucket是否为数组第一个元素，如果是，则跳转到第三步，之后不会走下一步，而是直接走第三步之后的代码，否则形成死循环</li>\n<li>如果bucket不是数组第一个元素，则获取前一个bucket，将新的imp和sel赋值到p17和p9，并跳转到第一步进行循环</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>///第三步<br>11. mask为数组buckets元素个数(capacity-1)，mask &lt;&lt; 4，即获取数组最后一个元素bucket的首地址，赋值给p12</p>\n</blockquote>\n<blockquote>\n<p>12.之后的第一步和上面第一步一样，第二步如果走到数组buckets的第一个元素仍然没有找到，则直接跳转到第三步即<code>JumpMiss</code></p>\n</blockquote>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-45650706f1f09463.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"cachelookup.png\"></p>\n<h4 id=\"4-CheckMiss源码分析\"><a href=\"#4-CheckMiss源码分析\" class=\"headerlink\" title=\"4. CheckMiss源码分析\"></a>4. <code>CheckMiss</code>源码分析</h4><figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">.macro</span> CheckMiss</span><br><span class=\"line\">\t<span class=\"string\">//</span> miss <span class=\"keyword\">if</span> bucket-&gt;sel == 0</span><br><span class=\"line\"><span class=\"string\">.if</span> $0 == GETIMP</span><br><span class=\"line\">\tcbz\tp9, LGetImpMiss</span><br><span class=\"line\"><span class=\"string\">.elseif</span> $0 == NORMAL</span><br><span class=\"line\">\tcbz\tp9, __objc_msgSend_uncached</span><br><span class=\"line\"><span class=\"string\">.elseif</span> $0 == LOOKUP</span><br><span class=\"line\">\tcbz\tp9, __objc_msgLookup_uncached</span><br><span class=\"line\"><span class=\"string\">.else</span></span><br><span class=\"line\"><span class=\"string\">.abort</span> oops</span><br><span class=\"line\"><span class=\"string\">.endif</span></span><br><span class=\"line\"><span class=\"string\">.endmacro</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>分析：此时为NORMAL模式，则进入<code>__objc_msgSend_uncached</code>流程</p>\n</blockquote>\n<h4 id=\"5-objc-msgSend-uncached源码分析\"><a href=\"#5-objc-msgSend-uncached源码分析\" class=\"headerlink\" title=\"5. __objc_msgSend_uncached源码分析\"></a>5. <code>__objc_msgSend_uncached</code>源码分析</h4><figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">STATIC_ENTRY __objc_msgSend_uncached</span><br><span class=\"line\">\tUNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class=\"line\"></span><br><span class=\"line\">\t// THIS <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> A CALLABLE C <span class=\"keyword\">FUNCTION</span></span><br><span class=\"line\">\t// <span class=\"keyword\">Out</span>-<span class=\"keyword\">of</span>-band p16 <span class=\"keyword\">is</span> the <span class=\"keyword\">class</span> <span class=\"keyword\">to</span> <span class=\"keyword\">search</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tMethodTableLookup</span><br><span class=\"line\">\tTailCallFunctionPointer x17</span><br><span class=\"line\"></span><br><span class=\"line\">\tEND_ENTRY __objc_msgSend_uncached</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>分析：此时快速缓存查找没有找到对应imp，调用<code>MethodTableLookup</code>函数中调用<code>_lookUpImpOrForward</code>，进入对应类或元类的methodlist查找流程</p>\n</blockquote>\n"},{"title":"objc_msgSend源码解析(二)","date":"2020-09-22T16:00:00.000Z","_content":"\n在[objc_msgSend源码解析(一)](https://www.jianshu.com/p/55daf526120d)中最后进入`_lookUpImpOrForward`函数调用\n#### 1. `_lookUpImpOrForward`源码分析\n```\n_objc_msgForward_impcache->_objc_msgForward->_objc_forward_handler  \n\n__attribute__((noreturn, cold)) void\nobjc_defaultForwardHandler(id self, SEL sel)\n{\n    _objc_fatal(\"%c[%s %s]: unrecognized selector sent to instance %p \"\n                \"(no message forward handler is installed)\", \n                class_isMetaClass(object_getClass(self)) ? '+' : '-', \n                object_getClassName(self), sel_getName(sel), self);\n}\nvoid *_objc_forward_handler = (void*)objc_defaultForwardHandler;\n\nIMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)\n{\n    const IMP forward_imp = (IMP)_objc_msgForward_impcache;\n    IMP imp = nil;\n    Class curClass;\n\n    runtimeLock.assertUnlocked();\n\n    // Optimistic cache lookup\n    if (fastpath(behavior & LOOKUP_CACHE)) {\n        imp = cache_getImp(cls, sel);\n        if (imp) goto done_nolock;\n    } \n\n    runtimeLock.lock();\n \n    // TODO: this check is quite costly during process startup.\n    checkIsKnownClass(cls);\n\n    if (slowpath(!cls->isRealized())) {\n        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);\n        // runtimeLock may have been dropped but is now locked again\n    }\n\n    if (slowpath((behavior & LOOKUP_INITIALIZE) && !cls->isInitialized())) {\n        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);\n    }\n\n    runtimeLock.assertLocked();\n    curClass = cls; \n\n    for (unsigned attempts = unreasonableClassCount();;) {\n        // curClass method list.\n        Method meth = getMethodNoSuper_nolock(curClass, sel);\n        if (meth) {\n            imp = meth->imp;\n            goto done;\n        }\n\n        if (slowpath((curClass = curClass->superclass) == nil)) {\n            // No implementation found, and method resolver didn't help.\n            // Use forwarding.\n            imp = forward_imp;\n            break;\n        }\n\n        // Halt if there is a cycle in the superclass chain.\n        if (slowpath(--attempts == 0)) {\n            _objc_fatal(\"Memory corruption in class list.\");\n        }\n\n        // Superclass cache.\n        imp = cache_getImp(curClass, sel);\n        if (slowpath(imp == forward_imp)) {\n            break;\n        }\n        if (fastpath(imp)) {\n            // Found the method in a superclass. Cache it in this class.\n            goto done;\n        }\n    }\n\n    // No implementation found. Try method resolver once.\n    if (slowpath(behavior & LOOKUP_RESOLVER)) {\n        behavior ^= LOOKUP_RESOLVER;\n        return resolveMethod_locked(inst, sel, cls, behavior);\n    }\n\n done:\n    log_and_fill_cache(cls, imp, sel, inst, curClass);\n    runtimeLock.unlock();\n done_nolock:\n    if (slowpath((behavior & LOOKUP_NIL) && imp == forward_imp)) {\n        return nil;\n    }\n    return imp;\n}\n```\n> 分析：\n> 1. 首先还是会在当前类`curClass`的缓存中查找一遍，避免由于多线程问题，此时已经将该方法放进缓存\n> 2. 然后进行类的一系列准备及确认工作\n> 3. 此时的for循环只要没有跳出循环，则相当于死循环，在for循环中先调用`getMethodNoSuper_nolock`方法，从当前类`curClass`的`methodlist`中进行查找,如果找到则放到缓存中\n> 4. 如果没有找到，则将当前类修改为当前类的父类，即`curClass=curClass->superclass`，如果父类为nil，则给imp赋值为`unrecognized selector`\n> 5. 然后调用`cache_getImp`去父类的缓存中进行查找，`cache_getImp`在父类缓存中如果找到，则返回imp，并放入自己类的缓存中\n> 6. 如果父类缓存中也没有找到，即在`cache_getImp`函数中没有找到imp，则继续循环，通过`getMethodNoSuper_nolock`函数查找父类的methodlist，如果没有找到则递归查找父类缓存，父类方法列表，直到找到对应的imp或者走到第4步\n> 7. 在返回`unrecognized selector`之前，会走一次`resolveMethod_locked`动态方法解析的流程\n\n#### 2. `getMethodNoSuper_nolock`源码分析\n```\ngetMethodNoSuper_nolock -> search_method_list_inline -> findMethodInSortedMethodList\n\nALWAYS_INLINE static method_t *\nfindMethodInSortedMethodList(SEL key, const method_list_t *list)\n{\n    ASSERT(list);\n\n    const method_t * const first = &list->first;\n    const method_t *base = first;\n    const method_t *probe;\n    uintptr_t keyValue = (uintptr_t)key;\n    uint32_t count;\n    \n    for (count = list->count; count != 0; count >>= 1) {\n        probe = base + (count >> 1);\n        \n        uintptr_t probeValue = (uintptr_t)probe->name;\n        \n        if (keyValue == probeValue) { \n            while (probe > first && keyValue == (uintptr_t)probe[-1].name) {\n                probe--;\n            }\n            return (method_t *)probe;\n        }\n        \n        if (keyValue > probeValue) {\n            base = probe + 1;\n            count--;\n        }\n    }\n    \n    return nil;\n}\n```\n> 分析：此处采用二分查找方式，由于`method`在`methodlist`中存放的特点，如果找到`sel`对应的`method`，则会检查该`method`的前一个`method`的`name`是否相同，直到找到第一个为止并返回，如果没有找到则返回nil","source":"_posts/2020-09-23-objc_msgSend源码解析(二).md","raw":"---\ntitle:      \"objc_msgSend源码解析(二)\" \ndate:       2020-09-23\ntags:\n    - iOS底层原理\ncategories:\n    - iOS底层原理\n---\n\n在[objc_msgSend源码解析(一)](https://www.jianshu.com/p/55daf526120d)中最后进入`_lookUpImpOrForward`函数调用\n#### 1. `_lookUpImpOrForward`源码分析\n```\n_objc_msgForward_impcache->_objc_msgForward->_objc_forward_handler  \n\n__attribute__((noreturn, cold)) void\nobjc_defaultForwardHandler(id self, SEL sel)\n{\n    _objc_fatal(\"%c[%s %s]: unrecognized selector sent to instance %p \"\n                \"(no message forward handler is installed)\", \n                class_isMetaClass(object_getClass(self)) ? '+' : '-', \n                object_getClassName(self), sel_getName(sel), self);\n}\nvoid *_objc_forward_handler = (void*)objc_defaultForwardHandler;\n\nIMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)\n{\n    const IMP forward_imp = (IMP)_objc_msgForward_impcache;\n    IMP imp = nil;\n    Class curClass;\n\n    runtimeLock.assertUnlocked();\n\n    // Optimistic cache lookup\n    if (fastpath(behavior & LOOKUP_CACHE)) {\n        imp = cache_getImp(cls, sel);\n        if (imp) goto done_nolock;\n    } \n\n    runtimeLock.lock();\n \n    // TODO: this check is quite costly during process startup.\n    checkIsKnownClass(cls);\n\n    if (slowpath(!cls->isRealized())) {\n        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);\n        // runtimeLock may have been dropped but is now locked again\n    }\n\n    if (slowpath((behavior & LOOKUP_INITIALIZE) && !cls->isInitialized())) {\n        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);\n    }\n\n    runtimeLock.assertLocked();\n    curClass = cls; \n\n    for (unsigned attempts = unreasonableClassCount();;) {\n        // curClass method list.\n        Method meth = getMethodNoSuper_nolock(curClass, sel);\n        if (meth) {\n            imp = meth->imp;\n            goto done;\n        }\n\n        if (slowpath((curClass = curClass->superclass) == nil)) {\n            // No implementation found, and method resolver didn't help.\n            // Use forwarding.\n            imp = forward_imp;\n            break;\n        }\n\n        // Halt if there is a cycle in the superclass chain.\n        if (slowpath(--attempts == 0)) {\n            _objc_fatal(\"Memory corruption in class list.\");\n        }\n\n        // Superclass cache.\n        imp = cache_getImp(curClass, sel);\n        if (slowpath(imp == forward_imp)) {\n            break;\n        }\n        if (fastpath(imp)) {\n            // Found the method in a superclass. Cache it in this class.\n            goto done;\n        }\n    }\n\n    // No implementation found. Try method resolver once.\n    if (slowpath(behavior & LOOKUP_RESOLVER)) {\n        behavior ^= LOOKUP_RESOLVER;\n        return resolveMethod_locked(inst, sel, cls, behavior);\n    }\n\n done:\n    log_and_fill_cache(cls, imp, sel, inst, curClass);\n    runtimeLock.unlock();\n done_nolock:\n    if (slowpath((behavior & LOOKUP_NIL) && imp == forward_imp)) {\n        return nil;\n    }\n    return imp;\n}\n```\n> 分析：\n> 1. 首先还是会在当前类`curClass`的缓存中查找一遍，避免由于多线程问题，此时已经将该方法放进缓存\n> 2. 然后进行类的一系列准备及确认工作\n> 3. 此时的for循环只要没有跳出循环，则相当于死循环，在for循环中先调用`getMethodNoSuper_nolock`方法，从当前类`curClass`的`methodlist`中进行查找,如果找到则放到缓存中\n> 4. 如果没有找到，则将当前类修改为当前类的父类，即`curClass=curClass->superclass`，如果父类为nil，则给imp赋值为`unrecognized selector`\n> 5. 然后调用`cache_getImp`去父类的缓存中进行查找，`cache_getImp`在父类缓存中如果找到，则返回imp，并放入自己类的缓存中\n> 6. 如果父类缓存中也没有找到，即在`cache_getImp`函数中没有找到imp，则继续循环，通过`getMethodNoSuper_nolock`函数查找父类的methodlist，如果没有找到则递归查找父类缓存，父类方法列表，直到找到对应的imp或者走到第4步\n> 7. 在返回`unrecognized selector`之前，会走一次`resolveMethod_locked`动态方法解析的流程\n\n#### 2. `getMethodNoSuper_nolock`源码分析\n```\ngetMethodNoSuper_nolock -> search_method_list_inline -> findMethodInSortedMethodList\n\nALWAYS_INLINE static method_t *\nfindMethodInSortedMethodList(SEL key, const method_list_t *list)\n{\n    ASSERT(list);\n\n    const method_t * const first = &list->first;\n    const method_t *base = first;\n    const method_t *probe;\n    uintptr_t keyValue = (uintptr_t)key;\n    uint32_t count;\n    \n    for (count = list->count; count != 0; count >>= 1) {\n        probe = base + (count >> 1);\n        \n        uintptr_t probeValue = (uintptr_t)probe->name;\n        \n        if (keyValue == probeValue) { \n            while (probe > first && keyValue == (uintptr_t)probe[-1].name) {\n                probe--;\n            }\n            return (method_t *)probe;\n        }\n        \n        if (keyValue > probeValue) {\n            base = probe + 1;\n            count--;\n        }\n    }\n    \n    return nil;\n}\n```\n> 分析：此处采用二分查找方式，由于`method`在`methodlist`中存放的特点，如果找到`sel`对应的`method`，则会检查该`method`的前一个`method`的`name`是否相同，直到找到第一个为止并返回，如果没有找到则返回nil","slug":"2020-09-23-objc_msgSend源码解析(二)","published":1,"updated":"2021-06-19T03:46:24.087Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbq0001wbjrj5vqn0kyl","content":"<p>在<a href=\"https://www.jianshu.com/p/55daf526120d\">objc_msgSend源码解析(一)</a>中最后进入<code>_lookUpImpOrForward</code>函数调用</p>\n<h4 id=\"1-lookUpImpOrForward源码分析\"><a href=\"#1-lookUpImpOrForward源码分析\" class=\"headerlink\" title=\"1. _lookUpImpOrForward源码分析\"></a>1. <code>_lookUpImpOrForward</code>源码分析</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_objc_msgForward_impcache-&gt;_objc_msgForward-&gt;_objc_forward_handler  </span><br><span class=\"line\"></span><br><span class=\"line\">__attribute__((noreturn, cold)) <span class=\"keyword\">void</span></span><br><span class=\"line\">objc_defaultForwardHandler(id self, SEL sel)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _objc_fatal(<span class=\"string\">&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</span></span><br><span class=\"line\">                <span class=\"string\">&quot;(no message forward handler is installed)&quot;</span>, </span><br><span class=\"line\">                class_isMetaClass(object_getClass(self)) ? <span class=\"string\">&#x27;+&#x27;</span> : <span class=\"string\">&#x27;-&#x27;</span>, </span><br><span class=\"line\">                object_getClassName(self), sel_getName(sel), self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">void</span> *_objc_forward_handler = (<span class=\"keyword\">void</span>*)objc_defaultForwardHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">IMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> IMP forward_imp = (IMP)_objc_msgForward_impcache;</span><br><span class=\"line\">    IMP imp = nil;</span><br><span class=\"line\">    Class curClass;</span><br><span class=\"line\"></span><br><span class=\"line\">    runtimeLock.assertUnlocked();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Optimistic cache lookup</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fastpath(behavior &amp; LOOKUP_CACHE)) &#123;</span><br><span class=\"line\">        imp = cache_getImp(cls, sel);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (imp) goto done_nolock;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">    runtimeLock.lock();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> this check is quite costly during process startup.</span></span><br><span class=\"line\">    checkIsKnownClass(cls);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(!cls-&gt;isRealized())) &#123;</span><br><span class=\"line\">        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</span><br><span class=\"line\">        <span class=\"comment\">// runtimeLock may have been dropped but is now locked again</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath((behavior &amp; LOOKUP_INITIALIZE) &amp;&amp; !cls-&gt;isInitialized())) &#123;</span><br><span class=\"line\">        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    runtimeLock.assertLocked();</span><br><span class=\"line\">    curClass = cls; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (unsigned attempts = unreasonableClassCount();;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// curClass method list.</span></span><br><span class=\"line\">        Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (meth) &#123;</span><br><span class=\"line\">            imp = meth-&gt;imp;</span><br><span class=\"line\">            goto done;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowpath((curClass = curClass-&gt;superclass) == nil)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// No implementation found, and method resolver didn&#x27;t help.</span></span><br><span class=\"line\">            <span class=\"comment\">// Use forwarding.</span></span><br><span class=\"line\">            imp = forward_imp;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Halt if there is a cycle in the superclass chain.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowpath(--attempts == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            _objc_fatal(<span class=\"string\">&quot;Memory corruption in class list.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Superclass cache.</span></span><br><span class=\"line\">        imp = cache_getImp(curClass, sel);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowpath(imp == forward_imp)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fastpath(imp)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Found the method in a superclass. Cache it in this class.</span></span><br><span class=\"line\">            goto done;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// No implementation found. Try method resolver once.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class=\"line\">        behavior ^= LOOKUP_RESOLVER;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> resolveMethod_locked(inst, sel, cls, behavior);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> done:</span><br><span class=\"line\">    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class=\"line\">    runtimeLock.unlock();</span><br><span class=\"line\"> done_nolock:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp == forward_imp)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> imp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>分析：</p>\n<ol>\n<li>首先还是会在当前类<code>curClass</code>的缓存中查找一遍，避免由于多线程问题，此时已经将该方法放进缓存</li>\n<li>然后进行类的一系列准备及确认工作</li>\n<li>此时的for循环只要没有跳出循环，则相当于死循环，在for循环中先调用<code>getMethodNoSuper_nolock</code>方法，从当前类<code>curClass</code>的<code>methodlist</code>中进行查找,如果找到则放到缓存中</li>\n<li>如果没有找到，则将当前类修改为当前类的父类，即<code>curClass=curClass-&gt;superclass</code>，如果父类为nil，则给imp赋值为<code>unrecognized selector</code></li>\n<li>然后调用<code>cache_getImp</code>去父类的缓存中进行查找，<code>cache_getImp</code>在父类缓存中如果找到，则返回imp，并放入自己类的缓存中</li>\n<li>如果父类缓存中也没有找到，即在<code>cache_getImp</code>函数中没有找到imp，则继续循环，通过<code>getMethodNoSuper_nolock</code>函数查找父类的methodlist，如果没有找到则递归查找父类缓存，父类方法列表，直到找到对应的imp或者走到第4步</li>\n<li>在返回<code>unrecognized selector</code>之前，会走一次<code>resolveMethod_locked</code>动态方法解析的流程</li>\n</ol>\n</blockquote>\n<h4 id=\"2-getMethodNoSuper-nolock源码分析\"><a href=\"#2-getMethodNoSuper-nolock源码分析\" class=\"headerlink\" title=\"2. getMethodNoSuper_nolock源码分析\"></a>2. <code>getMethodNoSuper_nolock</code>源码分析</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getMethodNoSuper_nolock -&gt; search_method_list_inline -&gt; findMethodInSortedMethodList</span><br><span class=\"line\"></span><br><span class=\"line\">ALWAYS_INLINE <span class=\"keyword\">static</span> <span class=\"keyword\">method_t</span> *</span><br><span class=\"line\">findMethodInSortedMethodList(SEL key, <span class=\"keyword\">const</span> <span class=\"keyword\">method_list_t</span> *<span class=\"built_in\">list</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ASSERT(<span class=\"built_in\">list</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">method_t</span> * <span class=\"keyword\">const</span> first = &amp;<span class=\"built_in\">list</span>-&gt;first;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">method_t</span> *base = first;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">method_t</span> *probe;</span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> keyValue = (<span class=\"keyword\">uintptr_t</span>)key;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> count;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (count = <span class=\"built_in\">list</span>-&gt;count; count != <span class=\"number\">0</span>; count &gt;&gt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        probe = base + (count &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">uintptr_t</span> probeValue = (<span class=\"keyword\">uintptr_t</span>)probe-&gt;name;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (keyValue == probeValue) &#123; </span><br><span class=\"line\">            <span class=\"keyword\">while</span> (probe &gt; first &amp;&amp; keyValue == (<span class=\"keyword\">uintptr_t</span>)probe[<span class=\"number\">-1</span>].name) &#123;</span><br><span class=\"line\">                probe--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (<span class=\"keyword\">method_t</span> *)probe;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (keyValue &gt; probeValue) &#123;</span><br><span class=\"line\">            base = probe + <span class=\"number\">1</span>;</span><br><span class=\"line\">            count--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> nil;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>分析：此处采用二分查找方式，由于<code>method</code>在<code>methodlist</code>中存放的特点，如果找到<code>sel</code>对应的<code>method</code>，则会检查该<code>method</code>的前一个<code>method</code>的<code>name</code>是否相同，直到找到第一个为止并返回，如果没有找到则返回nil</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>在<a href=\"https://www.jianshu.com/p/55daf526120d\">objc_msgSend源码解析(一)</a>中最后进入<code>_lookUpImpOrForward</code>函数调用</p>\n<h4 id=\"1-lookUpImpOrForward源码分析\"><a href=\"#1-lookUpImpOrForward源码分析\" class=\"headerlink\" title=\"1. _lookUpImpOrForward源码分析\"></a>1. <code>_lookUpImpOrForward</code>源码分析</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_objc_msgForward_impcache-&gt;_objc_msgForward-&gt;_objc_forward_handler  </span><br><span class=\"line\"></span><br><span class=\"line\">__attribute__((noreturn, cold)) <span class=\"keyword\">void</span></span><br><span class=\"line\">objc_defaultForwardHandler(id self, SEL sel)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    _objc_fatal(<span class=\"string\">&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</span></span><br><span class=\"line\">                <span class=\"string\">&quot;(no message forward handler is installed)&quot;</span>, </span><br><span class=\"line\">                class_isMetaClass(object_getClass(self)) ? <span class=\"string\">&#x27;+&#x27;</span> : <span class=\"string\">&#x27;-&#x27;</span>, </span><br><span class=\"line\">                object_getClassName(self), sel_getName(sel), self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">void</span> *_objc_forward_handler = (<span class=\"keyword\">void</span>*)objc_defaultForwardHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">IMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> IMP forward_imp = (IMP)_objc_msgForward_impcache;</span><br><span class=\"line\">    IMP imp = nil;</span><br><span class=\"line\">    Class curClass;</span><br><span class=\"line\"></span><br><span class=\"line\">    runtimeLock.assertUnlocked();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Optimistic cache lookup</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fastpath(behavior &amp; LOOKUP_CACHE)) &#123;</span><br><span class=\"line\">        imp = cache_getImp(cls, sel);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (imp) goto done_nolock;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">    runtimeLock.lock();</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> this check is quite costly during process startup.</span></span><br><span class=\"line\">    checkIsKnownClass(cls);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(!cls-&gt;isRealized())) &#123;</span><br><span class=\"line\">        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</span><br><span class=\"line\">        <span class=\"comment\">// runtimeLock may have been dropped but is now locked again</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath((behavior &amp; LOOKUP_INITIALIZE) &amp;&amp; !cls-&gt;isInitialized())) &#123;</span><br><span class=\"line\">        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    runtimeLock.assertLocked();</span><br><span class=\"line\">    curClass = cls; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (unsigned attempts = unreasonableClassCount();;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// curClass method list.</span></span><br><span class=\"line\">        Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (meth) &#123;</span><br><span class=\"line\">            imp = meth-&gt;imp;</span><br><span class=\"line\">            goto done;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowpath((curClass = curClass-&gt;superclass) == nil)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// No implementation found, and method resolver didn&#x27;t help.</span></span><br><span class=\"line\">            <span class=\"comment\">// Use forwarding.</span></span><br><span class=\"line\">            imp = forward_imp;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Halt if there is a cycle in the superclass chain.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowpath(--attempts == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            _objc_fatal(<span class=\"string\">&quot;Memory corruption in class list.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Superclass cache.</span></span><br><span class=\"line\">        imp = cache_getImp(curClass, sel);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowpath(imp == forward_imp)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fastpath(imp)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Found the method in a superclass. Cache it in this class.</span></span><br><span class=\"line\">            goto done;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// No implementation found. Try method resolver once.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class=\"line\">        behavior ^= LOOKUP_RESOLVER;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> resolveMethod_locked(inst, sel, cls, behavior);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> done:</span><br><span class=\"line\">    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class=\"line\">    runtimeLock.unlock();</span><br><span class=\"line\"> done_nolock:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp == forward_imp)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> imp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>分析：</p>\n<ol>\n<li>首先还是会在当前类<code>curClass</code>的缓存中查找一遍，避免由于多线程问题，此时已经将该方法放进缓存</li>\n<li>然后进行类的一系列准备及确认工作</li>\n<li>此时的for循环只要没有跳出循环，则相当于死循环，在for循环中先调用<code>getMethodNoSuper_nolock</code>方法，从当前类<code>curClass</code>的<code>methodlist</code>中进行查找,如果找到则放到缓存中</li>\n<li>如果没有找到，则将当前类修改为当前类的父类，即<code>curClass=curClass-&gt;superclass</code>，如果父类为nil，则给imp赋值为<code>unrecognized selector</code></li>\n<li>然后调用<code>cache_getImp</code>去父类的缓存中进行查找，<code>cache_getImp</code>在父类缓存中如果找到，则返回imp，并放入自己类的缓存中</li>\n<li>如果父类缓存中也没有找到，即在<code>cache_getImp</code>函数中没有找到imp，则继续循环，通过<code>getMethodNoSuper_nolock</code>函数查找父类的methodlist，如果没有找到则递归查找父类缓存，父类方法列表，直到找到对应的imp或者走到第4步</li>\n<li>在返回<code>unrecognized selector</code>之前，会走一次<code>resolveMethod_locked</code>动态方法解析的流程</li>\n</ol>\n</blockquote>\n<h4 id=\"2-getMethodNoSuper-nolock源码分析\"><a href=\"#2-getMethodNoSuper-nolock源码分析\" class=\"headerlink\" title=\"2. getMethodNoSuper_nolock源码分析\"></a>2. <code>getMethodNoSuper_nolock</code>源码分析</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getMethodNoSuper_nolock -&gt; search_method_list_inline -&gt; findMethodInSortedMethodList</span><br><span class=\"line\"></span><br><span class=\"line\">ALWAYS_INLINE <span class=\"keyword\">static</span> <span class=\"keyword\">method_t</span> *</span><br><span class=\"line\">findMethodInSortedMethodList(SEL key, <span class=\"keyword\">const</span> <span class=\"keyword\">method_list_t</span> *<span class=\"built_in\">list</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ASSERT(<span class=\"built_in\">list</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">method_t</span> * <span class=\"keyword\">const</span> first = &amp;<span class=\"built_in\">list</span>-&gt;first;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">method_t</span> *base = first;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">method_t</span> *probe;</span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> keyValue = (<span class=\"keyword\">uintptr_t</span>)key;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> count;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (count = <span class=\"built_in\">list</span>-&gt;count; count != <span class=\"number\">0</span>; count &gt;&gt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        probe = base + (count &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">uintptr_t</span> probeValue = (<span class=\"keyword\">uintptr_t</span>)probe-&gt;name;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (keyValue == probeValue) &#123; </span><br><span class=\"line\">            <span class=\"keyword\">while</span> (probe &gt; first &amp;&amp; keyValue == (<span class=\"keyword\">uintptr_t</span>)probe[<span class=\"number\">-1</span>].name) &#123;</span><br><span class=\"line\">                probe--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (<span class=\"keyword\">method_t</span> *)probe;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (keyValue &gt; probeValue) &#123;</span><br><span class=\"line\">            base = probe + <span class=\"number\">1</span>;</span><br><span class=\"line\">            count--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> nil;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>分析：此处采用二分查找方式，由于<code>method</code>在<code>methodlist</code>中存放的特点，如果找到<code>sel</code>对应的<code>method</code>，则会检查该<code>method</code>的前一个<code>method</code>的<code>name</code>是否相同，直到找到第一个为止并返回，如果没有找到则返回nil</p>\n</blockquote>\n"},{"title":"objc_msgSend源码解析(三)","date":"2020-09-23T16:00:00.000Z","_content":"\n#### 1. 动态方法解析\n\n`resolveMethod_locked`源码\n```\nstatic NEVER_INLINE IMP\nresolveMethod_locked(id inst, SEL sel, Class cls, int behavior)\n{\n    runtimeLock.assertLocked();\n    ASSERT(cls->isRealized());\n    runtimeLock.unlock();\n    if (! cls->isMetaClass()) { \n        resolveInstanceMethod(inst, sel, cls);\n    } \n    else { \n        resolveClassMethod(inst, sel, cls);\n        if (!lookUpImpOrNil(inst, sel, cls)) {\n            resolveInstanceMethod(inst, sel, cls);\n        }\n    }\n    return lookUpImpOrForward(inst, sel, cls, behavior | LOOKUP_CACHE);\n}\n```\n> 分析：根据传入的`cls`是否是元类分别调用`resolveInstanceMethod`或者`resolveClassMethod`\n\n对于类方法的动态解析示例\n```\nvoid myClassMethod() {\n    NSLog(@\"%s\", __FUNCTION__);\n}\n\n+ (BOOL)resolveClassMethod:(SEL)sel {\n    if ([NSStringFromSelector(sel) isEqualToString:@\"classMethod\"]) {\n        const char *cls = [NSStringFromClass([self class]) UTF8String];\n        Class metaClass = objc_getMetaClass(cls);\n        \n        return class_addMethod(metaClass, sel, (IMP)myClassMethod, \"\");\n    }\n    return [super resolveClassMethod:sel];\n}\n```\n> 注意：\n> 1. 对于类方法的动态解析需要给元类添加IMP\n> 2. 由于NSObject的元类的父类为NSObject，所以也可以给NSObject的分类添加对应的实例方法\n\n对于实例方法的动态解析示例\n```\nvoid myInstanceMethod() {\n    NSLog(@\"%s\", __FUNCTION__);\n}\n\n+ (BOOL)resolveInstanceMethod:(SEL)sel {\n    if ([NSStringFromSelector(sel) isEqualToString:@\"instanceMethod\"]) {        \n        return class_addMethod(self, sel, (IMP)myInstanceMethod, \"\");\n    }\n    return [super resolveInstanceMethod:sel];\n}\n```\n\n#### 2. 快速转发流程\n在`lookUpImpOrForward`函数中如果找到sel对应的imp，则走到`log_and_fill_cache`这步，将找到的imp放入缓存。\n\n`log_and_fill_cache`源码解析\n```\nstatic void\nlog_and_fill_cache(Class cls, IMP imp, SEL sel, id receiver, Class implementer)\n{\n#if SUPPORT_MESSAGE_LOGGING\n    if (slowpath(objcMsgLogEnabled && implementer)) {\n        bool cacheIt = logMessageSend(implementer->isMetaClass(), \n                                      cls->nameForLogging(),\n                                      implementer->nameForLogging(), \n                                      sel);\n        if (!cacheIt) return;\n    }\n#endif\n    cache_fill(cls, sel, imp, receiver);\n}\n```\n可以跟进`logMessageSend`函数->`logMessageSend`->`instrumentObjcMessageSends`，在`instrumentObjcMessageSends`传入的flag即可以打印到文件。  \n所以在外部定义函数如下\n```\n#import <Foundation/Foundation.h>\n#import \"LSPerson.h\"\n\nextern void instrumentObjcMessageSends(BOOL flag); \n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        LSPerson *person = [[LSPerson alloc] init];\n        instrumentObjcMessageSends(true);\n        [person performSelector:@selector(eat)];\n        instrumentObjcMessageSends(false);\n    }\n    return 0;\n}\n```  \ncrash报错`unrecognized selector sent to instance`,然后由于是macos项目，则在`/tmp/msgSends-xxx`文件中可以看到如下调用顺序  \n```\n- LSPerson NSObject performSelector:\n+ LSPerson NSObject resolveInstanceMethod:\n+ LSPerson NSObject resolveInstanceMethod:\n- LSPerson NSObject forwardingTargetForSelector:\n- LSPerson NSObject forwardingTargetForSelector:\n- LSPerson NSObject methodSignatureForSelector:\n- LSPerson NSObject methodSignatureForSelector:\n- LSPerson NSObject class\n+ LSPerson NSObject resolveInstanceMethod:\n+ LSPerson NSObject resolveInstanceMethod:\n- LSPerson NSObject doesNotRecognizeSelector:\n- LSPerson NSObject doesNotRecognizeSelector:\n```\n可以看到调用之后没有找到方法除了会走动态解析逻辑`resolveInstanceMethod`，还走了`forwardingTargetForSelector`和`methodSignatureForSelector`分别对应**快速转发流程**和**慢速转发流程**。\n\n> 我理解的**快速转发流程**和**慢速转发流程**中的快慢是指在`objc_msgSend`中的先后顺序，并不是快速一定比慢速要快，或者效率更高。\n\n> 通过反汇编查看`____forwarding___`流程猜测如果函数返回空或者`self`，仍然会报错\n```\nloc_64bdc:\n    rdi = rbx;\n    rax = [rdi forwardingTargetForSelector:var_140];\n    if ((rax == 0x0) || (rax == rbx)) goto loc_64c47;\n```\n\n所以可以给自己类或者其他类添加sel对应的imp后返回\n```\n@implementation LSPerson\n\n- (void)run{\n    NSLog(@\"%s\", __FUNCTION__);\n}\n\n- (id)forwardingTargetForSelector:(SEL)aSelector {\n    if ([NSStringFromSelector(aSelector) isEqualToString:@\"eat\"]) {\n        //获取LSPerson中的run方法\n        Method method = class_getInstanceMethod([self class], @selector(run));\n        const char *type = method_getTypeEncoding(method);\n        IMP imp = method_getImplementation(method);\n        //将aSelector指向run的imp\n        class_addMethod([self class], aSelector, imp, type);\n        return [LSPerson alloc];\n    }\n    return [super forwardingTargetForSelector:aSelector];\n}\n@end\n```\n\n#### 3. 慢速转发流程\n```\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    if (aSelector == @selector(eat)) {\n        NSMethodSignature *methodSignature = [NSMethodSignature signatureWithObjCTypes:\"v@@:\"];\n        return methodSignature;\n    }\n    return [super methodSignatureForSelector:aSelector];\n}\n\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    SEL selector = anInvocation.selector;\n    if ([[LSPerson alloc] respondsToSelector:selector]) {\n        [anInvocation invokeWithTarget:[LSPerson alloc]];\n    }else {\n        [self doesNotRecognizeSelector:[anInvocation selector]];\n    }\n}\n\n- (void) doesNotRecognizeSelector: (SEL)aSelector\n{\n    NSLog(@\"%@ does not recognize %@\",NSStringFromClass([self class]), NSStringFromSelector(aSelector));\n}\n```\n> 分析：\n> 1. 在`methodSignatureForSelector`这个函数中返回一个aSelector对应的`NSMethodSignature *`的函数签名\n> 2. 在`forwardInvocation`函数中同样像上述**快速转发流程**一样，修改消息接收者，即修改`anInvocation.target`指向，也可以根据模块前缀做相应的UI操作以及上报处理等。","source":"_posts/2020-09-24-objc_msgSend源码解析(三).md","raw":"---\ntitle:      \"objc_msgSend源码解析(三)\" \ndate:       2020-09-24\ntags:\n    - iOS底层原理\ncategories:\n    - iOS底层原理\n---\n\n#### 1. 动态方法解析\n\n`resolveMethod_locked`源码\n```\nstatic NEVER_INLINE IMP\nresolveMethod_locked(id inst, SEL sel, Class cls, int behavior)\n{\n    runtimeLock.assertLocked();\n    ASSERT(cls->isRealized());\n    runtimeLock.unlock();\n    if (! cls->isMetaClass()) { \n        resolveInstanceMethod(inst, sel, cls);\n    } \n    else { \n        resolveClassMethod(inst, sel, cls);\n        if (!lookUpImpOrNil(inst, sel, cls)) {\n            resolveInstanceMethod(inst, sel, cls);\n        }\n    }\n    return lookUpImpOrForward(inst, sel, cls, behavior | LOOKUP_CACHE);\n}\n```\n> 分析：根据传入的`cls`是否是元类分别调用`resolveInstanceMethod`或者`resolveClassMethod`\n\n对于类方法的动态解析示例\n```\nvoid myClassMethod() {\n    NSLog(@\"%s\", __FUNCTION__);\n}\n\n+ (BOOL)resolveClassMethod:(SEL)sel {\n    if ([NSStringFromSelector(sel) isEqualToString:@\"classMethod\"]) {\n        const char *cls = [NSStringFromClass([self class]) UTF8String];\n        Class metaClass = objc_getMetaClass(cls);\n        \n        return class_addMethod(metaClass, sel, (IMP)myClassMethod, \"\");\n    }\n    return [super resolveClassMethod:sel];\n}\n```\n> 注意：\n> 1. 对于类方法的动态解析需要给元类添加IMP\n> 2. 由于NSObject的元类的父类为NSObject，所以也可以给NSObject的分类添加对应的实例方法\n\n对于实例方法的动态解析示例\n```\nvoid myInstanceMethod() {\n    NSLog(@\"%s\", __FUNCTION__);\n}\n\n+ (BOOL)resolveInstanceMethod:(SEL)sel {\n    if ([NSStringFromSelector(sel) isEqualToString:@\"instanceMethod\"]) {        \n        return class_addMethod(self, sel, (IMP)myInstanceMethod, \"\");\n    }\n    return [super resolveInstanceMethod:sel];\n}\n```\n\n#### 2. 快速转发流程\n在`lookUpImpOrForward`函数中如果找到sel对应的imp，则走到`log_and_fill_cache`这步，将找到的imp放入缓存。\n\n`log_and_fill_cache`源码解析\n```\nstatic void\nlog_and_fill_cache(Class cls, IMP imp, SEL sel, id receiver, Class implementer)\n{\n#if SUPPORT_MESSAGE_LOGGING\n    if (slowpath(objcMsgLogEnabled && implementer)) {\n        bool cacheIt = logMessageSend(implementer->isMetaClass(), \n                                      cls->nameForLogging(),\n                                      implementer->nameForLogging(), \n                                      sel);\n        if (!cacheIt) return;\n    }\n#endif\n    cache_fill(cls, sel, imp, receiver);\n}\n```\n可以跟进`logMessageSend`函数->`logMessageSend`->`instrumentObjcMessageSends`，在`instrumentObjcMessageSends`传入的flag即可以打印到文件。  \n所以在外部定义函数如下\n```\n#import <Foundation/Foundation.h>\n#import \"LSPerson.h\"\n\nextern void instrumentObjcMessageSends(BOOL flag); \n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        LSPerson *person = [[LSPerson alloc] init];\n        instrumentObjcMessageSends(true);\n        [person performSelector:@selector(eat)];\n        instrumentObjcMessageSends(false);\n    }\n    return 0;\n}\n```  \ncrash报错`unrecognized selector sent to instance`,然后由于是macos项目，则在`/tmp/msgSends-xxx`文件中可以看到如下调用顺序  \n```\n- LSPerson NSObject performSelector:\n+ LSPerson NSObject resolveInstanceMethod:\n+ LSPerson NSObject resolveInstanceMethod:\n- LSPerson NSObject forwardingTargetForSelector:\n- LSPerson NSObject forwardingTargetForSelector:\n- LSPerson NSObject methodSignatureForSelector:\n- LSPerson NSObject methodSignatureForSelector:\n- LSPerson NSObject class\n+ LSPerson NSObject resolveInstanceMethod:\n+ LSPerson NSObject resolveInstanceMethod:\n- LSPerson NSObject doesNotRecognizeSelector:\n- LSPerson NSObject doesNotRecognizeSelector:\n```\n可以看到调用之后没有找到方法除了会走动态解析逻辑`resolveInstanceMethod`，还走了`forwardingTargetForSelector`和`methodSignatureForSelector`分别对应**快速转发流程**和**慢速转发流程**。\n\n> 我理解的**快速转发流程**和**慢速转发流程**中的快慢是指在`objc_msgSend`中的先后顺序，并不是快速一定比慢速要快，或者效率更高。\n\n> 通过反汇编查看`____forwarding___`流程猜测如果函数返回空或者`self`，仍然会报错\n```\nloc_64bdc:\n    rdi = rbx;\n    rax = [rdi forwardingTargetForSelector:var_140];\n    if ((rax == 0x0) || (rax == rbx)) goto loc_64c47;\n```\n\n所以可以给自己类或者其他类添加sel对应的imp后返回\n```\n@implementation LSPerson\n\n- (void)run{\n    NSLog(@\"%s\", __FUNCTION__);\n}\n\n- (id)forwardingTargetForSelector:(SEL)aSelector {\n    if ([NSStringFromSelector(aSelector) isEqualToString:@\"eat\"]) {\n        //获取LSPerson中的run方法\n        Method method = class_getInstanceMethod([self class], @selector(run));\n        const char *type = method_getTypeEncoding(method);\n        IMP imp = method_getImplementation(method);\n        //将aSelector指向run的imp\n        class_addMethod([self class], aSelector, imp, type);\n        return [LSPerson alloc];\n    }\n    return [super forwardingTargetForSelector:aSelector];\n}\n@end\n```\n\n#### 3. 慢速转发流程\n```\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    if (aSelector == @selector(eat)) {\n        NSMethodSignature *methodSignature = [NSMethodSignature signatureWithObjCTypes:\"v@@:\"];\n        return methodSignature;\n    }\n    return [super methodSignatureForSelector:aSelector];\n}\n\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    SEL selector = anInvocation.selector;\n    if ([[LSPerson alloc] respondsToSelector:selector]) {\n        [anInvocation invokeWithTarget:[LSPerson alloc]];\n    }else {\n        [self doesNotRecognizeSelector:[anInvocation selector]];\n    }\n}\n\n- (void) doesNotRecognizeSelector: (SEL)aSelector\n{\n    NSLog(@\"%@ does not recognize %@\",NSStringFromClass([self class]), NSStringFromSelector(aSelector));\n}\n```\n> 分析：\n> 1. 在`methodSignatureForSelector`这个函数中返回一个aSelector对应的`NSMethodSignature *`的函数签名\n> 2. 在`forwardInvocation`函数中同样像上述**快速转发流程**一样，修改消息接收者，即修改`anInvocation.target`指向，也可以根据模块前缀做相应的UI操作以及上报处理等。","slug":"2020-09-24-objc_msgSend源码解析(三)","published":1,"updated":"2021-06-19T03:46:24.087Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbq20020bjrj870mgsby","content":"<h4 id=\"1-动态方法解析\"><a href=\"#1-动态方法解析\" class=\"headerlink\" title=\"1. 动态方法解析\"></a>1. 动态方法解析</h4><p><code>resolveMethod_locked</code>源码</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static NEVER_INLINE IMP</span><br><span class=\"line\">resolve<span class=\"constructor\">Method_locked(<span class=\"params\">id</span> <span class=\"params\">inst</span>, SEL <span class=\"params\">sel</span>, Class <span class=\"params\">cls</span>, <span class=\"params\">int</span> <span class=\"params\">behavior</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    runtimeLock.<span class=\"keyword\">assert</span><span class=\"constructor\">Locked()</span>;</span><br><span class=\"line\">    <span class=\"constructor\">ASSERT(<span class=\"params\">cls</span>-&gt;<span class=\"params\">isRealized</span>()</span>);</span><br><span class=\"line\">    runtimeLock.unlock<span class=\"literal\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! cls-&gt;is<span class=\"constructor\">MetaClass()</span>) &#123; </span><br><span class=\"line\">        resolve<span class=\"constructor\">InstanceMethod(<span class=\"params\">inst</span>, <span class=\"params\">sel</span>, <span class=\"params\">cls</span>)</span>;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        resolve<span class=\"constructor\">ClassMethod(<span class=\"params\">inst</span>, <span class=\"params\">sel</span>, <span class=\"params\">cls</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!look<span class=\"constructor\">UpImpOrNil(<span class=\"params\">inst</span>, <span class=\"params\">sel</span>, <span class=\"params\">cls</span>)</span>) &#123;</span><br><span class=\"line\">            resolve<span class=\"constructor\">InstanceMethod(<span class=\"params\">inst</span>, <span class=\"params\">sel</span>, <span class=\"params\">cls</span>)</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return look<span class=\"constructor\">UpImpOrForward(<span class=\"params\">inst</span>, <span class=\"params\">sel</span>, <span class=\"params\">cls</span>, <span class=\"params\">behavior</span> | LOOKUP_CACHE)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>分析：根据传入的<code>cls</code>是否是元类分别调用<code>resolveInstanceMethod</code>或者<code>resolveClassMethod</code></p>\n</blockquote>\n<p>对于类方法的动态解析示例</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> myClassMethod() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveClassMethod:(SEL)sel &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"built_in\">NSStringFromSelector</span>(sel) isEqualToString:<span class=\"string\">@&quot;classMethod&quot;</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *cls = [<span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]) UTF8String];</span><br><span class=\"line\">        Class metaClass = objc_getMetaClass(cls);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> class_addMethod(metaClass, sel, (IMP)myClassMethod, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> resolveClassMethod:sel];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：</p>\n<ol>\n<li>对于类方法的动态解析需要给元类添加IMP</li>\n<li>由于NSObject的元类的父类为NSObject，所以也可以给NSObject的分类添加对应的实例方法</li>\n</ol>\n</blockquote>\n<p>对于实例方法的动态解析示例</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">void</span> <span class=\"selector-tag\">myInstanceMethod</span>() &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">NSLog</span>(@<span class=\"string\">&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (BOOL)<span class=\"selector-tag\">resolveInstanceMethod</span><span class=\"selector-pseudo\">:(SEL)sel</span> &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">if</span> ([NSStringFromSelector(sel) <span class=\"attribute\">isEqualToString</span>:@<span class=\"string\">&quot;instanceMethod&quot;</span>]) &#123;        </span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">class_addMethod</span>(self, sel, (IMP)myInstanceMethod, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">return</span> <span class=\"selector-attr\">[super resolveInstanceMethod:sel]</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-快速转发流程\"><a href=\"#2-快速转发流程\" class=\"headerlink\" title=\"2. 快速转发流程\"></a>2. 快速转发流程</h4><p>在<code>lookUpImpOrForward</code>函数中如果找到sel对应的imp，则走到<code>log_and_fill_cache</code>这步，将找到的imp放入缓存。</p>\n<p><code>log_and_fill_cache</code>源码解析</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void</span><br><span class=\"line\">log<span class=\"constructor\">_and_fill_cache(Class <span class=\"params\">cls</span>, IMP <span class=\"params\">imp</span>, SEL <span class=\"params\">sel</span>, <span class=\"params\">id</span> <span class=\"params\">receiver</span>, Class <span class=\"params\">implementer</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">#<span class=\"keyword\">if</span> SUPPORT_MESSAGE_LOGGING</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(objcMsgLogEnabled<span class=\"operator\"> &amp;&amp; </span>implementer)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">bool</span> cacheIt = log<span class=\"constructor\">MessageSend(<span class=\"params\">implementer</span>-&gt;<span class=\"params\">isMetaClass</span>()</span>, </span><br><span class=\"line\">                                      cls-&gt;name<span class=\"constructor\">ForLogging()</span>,</span><br><span class=\"line\">                                      implementer-&gt;name<span class=\"constructor\">ForLogging()</span>, </span><br><span class=\"line\">                                      sel);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cacheIt) return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">    cache<span class=\"constructor\">_fill(<span class=\"params\">cls</span>, <span class=\"params\">sel</span>, <span class=\"params\">imp</span>, <span class=\"params\">receiver</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以跟进<code>logMessageSend</code>函数-&gt;<code>logMessageSend</code>-&gt;<code>instrumentObjcMessageSends</code>，在<code>instrumentObjcMessageSends</code>传入的flag即可以打印到文件。<br>所以在外部定义函数如下</p>\n<figure class=\"highlight d\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"keyword\">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#<span class=\"keyword\">import</span> <span class=\"string\">&quot;LSPerson.h&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> instrumentObjcMessageSends(BOOL flag); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"built_in\">char</span> * argv[]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</span><br><span class=\"line\">        LSPerson *person = [[LSPerson alloc] init];</span><br><span class=\"line\">        instrumentObjcMessageSends(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        [person performSelector:<span class=\"keyword\">@selector</span>(eat)];</span><br><span class=\"line\">        instrumentObjcMessageSends(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">crash报错`</span>unrecognized selector sent to instance<span class=\"string\">`,然后由于是macos项目，则在`</span>/tmp/msgSends-xxx<span class=\"string\">`文件中可以看到如下调用顺序  </span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>LSPerson NSObject performSelector:</li>\n</ul>\n<ul>\n<li>LSPerson NSObject resolveInstanceMethod:</li>\n<li>LSPerson NSObject resolveInstanceMethod:</li>\n</ul>\n<ul>\n<li>LSPerson NSObject forwardingTargetForSelector:</li>\n<li>LSPerson NSObject forwardingTargetForSelector:</li>\n<li>LSPerson NSObject methodSignatureForSelector:</li>\n<li>LSPerson NSObject methodSignatureForSelector:</li>\n<li>LSPerson NSObject class</li>\n</ul>\n<ul>\n<li>LSPerson NSObject resolveInstanceMethod:</li>\n<li>LSPerson NSObject resolveInstanceMethod:</li>\n</ul>\n<ul>\n<li><p>LSPerson NSObject doesNotRecognizeSelector:</p>\n</li>\n<li><p>LSPerson NSObject doesNotRecognizeSelector:</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可以看到调用之后没有找到方法除了会走动态解析逻辑`resolveInstanceMethod`，还走了`forwardingTargetForSelector`和`methodSignatureForSelector`分别对应**快速转发流程**和**慢速转发流程**。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 我理解的**快速转发流程**和**慢速转发流程**中的快慢是指在`objc_msgSend`中的先后顺序，并不是快速一定比慢速要快，或者效率更高。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 通过反汇编查看`____forwarding___`流程猜测如果函数返回空或者`self`，仍然会报错</span><br></pre></td></tr></table></figure>\n<p>loc_64bdc:<br>  rdi = rbx;<br>  rax = [rdi forwardingTargetForSelector:var_140];<br>  if ((rax == 0x0) || (rax == rbx)) goto loc_64c47;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">所以可以给自己类或者其他类添加sel对应的imp后返回</span><br></pre></td></tr></table></figure>\n<p>@implementation LSPerson</p>\n</li>\n<li><p>(void)run{<br>  NSLog(@”%s”, <strong>FUNCTION</strong>);<br>}</p>\n</li>\n<li><p>(id)forwardingTargetForSelector:(SEL)aSelector {<br>  if ([NSStringFromSelector(aSelector) isEqualToString:@”eat”]) {</p>\n<pre><code>  //获取LSPerson中的run方法\n  Method method = class_getInstanceMethod([self class], @selector(run));\n  const char *type = method_getTypeEncoding(method);\n  IMP imp = method_getImplementation(method);\n  //将aSelector指向run的imp\n  class_addMethod([self class], aSelector, imp, type);\n  return [LSPerson alloc];\n</code></pre>\n<p>  }<br>  return [super forwardingTargetForSelector:aSelector];<br>}<br>@end</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### <span class=\"number\">3.</span> 慢速转发流程</span><br></pre></td></tr></table></figure></li>\n<li><p>(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {<br>  if (aSelector == @selector(eat)) {</p>\n<pre><code>  NSMethodSignature *methodSignature = [NSMethodSignature signatureWithObjCTypes:&quot;v@@:&quot;];\n  return methodSignature;\n</code></pre>\n<p>  }<br>  return [super methodSignatureForSelector:aSelector];<br>}</p>\n</li>\n<li><p>(void)forwardInvocation:(NSInvocation *)anInvocation {<br>  SEL selector = anInvocation.selector;<br>  if ([[LSPerson alloc] respondsToSelector:selector]) {</p>\n<pre><code>  [anInvocation invokeWithTarget:[LSPerson alloc]];\n</code></pre>\n<p>  }else {</p>\n<pre><code>  [self doesNotRecognizeSelector:[anInvocation selector]];\n</code></pre>\n<p>  }<br>}</p>\n</li>\n<li><p>(void) doesNotRecognizeSelector: (SEL)aSelector<br>{<br>  NSLog(@”%@ does not recognize %@”,NSStringFromClass([self class]), NSStringFromSelector(aSelector));<br>}<br>```</p>\n<blockquote>\n<p>分析：</p>\n<ol>\n<li>在<code>methodSignatureForSelector</code>这个函数中返回一个aSelector对应的<code>NSMethodSignature *</code>的函数签名</li>\n<li>在<code>forwardInvocation</code>函数中同样像上述<strong>快速转发流程</strong>一样，修改消息接收者，即修改<code>anInvocation.target</code>指向，也可以根据模块前缀做相应的UI操作以及上报处理等。</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1-动态方法解析\"><a href=\"#1-动态方法解析\" class=\"headerlink\" title=\"1. 动态方法解析\"></a>1. 动态方法解析</h4><p><code>resolveMethod_locked</code>源码</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static NEVER_INLINE IMP</span><br><span class=\"line\">resolve<span class=\"constructor\">Method_locked(<span class=\"params\">id</span> <span class=\"params\">inst</span>, SEL <span class=\"params\">sel</span>, Class <span class=\"params\">cls</span>, <span class=\"params\">int</span> <span class=\"params\">behavior</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    runtimeLock.<span class=\"keyword\">assert</span><span class=\"constructor\">Locked()</span>;</span><br><span class=\"line\">    <span class=\"constructor\">ASSERT(<span class=\"params\">cls</span>-&gt;<span class=\"params\">isRealized</span>()</span>);</span><br><span class=\"line\">    runtimeLock.unlock<span class=\"literal\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! cls-&gt;is<span class=\"constructor\">MetaClass()</span>) &#123; </span><br><span class=\"line\">        resolve<span class=\"constructor\">InstanceMethod(<span class=\"params\">inst</span>, <span class=\"params\">sel</span>, <span class=\"params\">cls</span>)</span>;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        resolve<span class=\"constructor\">ClassMethod(<span class=\"params\">inst</span>, <span class=\"params\">sel</span>, <span class=\"params\">cls</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!look<span class=\"constructor\">UpImpOrNil(<span class=\"params\">inst</span>, <span class=\"params\">sel</span>, <span class=\"params\">cls</span>)</span>) &#123;</span><br><span class=\"line\">            resolve<span class=\"constructor\">InstanceMethod(<span class=\"params\">inst</span>, <span class=\"params\">sel</span>, <span class=\"params\">cls</span>)</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return look<span class=\"constructor\">UpImpOrForward(<span class=\"params\">inst</span>, <span class=\"params\">sel</span>, <span class=\"params\">cls</span>, <span class=\"params\">behavior</span> | LOOKUP_CACHE)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>分析：根据传入的<code>cls</code>是否是元类分别调用<code>resolveInstanceMethod</code>或者<code>resolveClassMethod</code></p>\n</blockquote>\n<p>对于类方法的动态解析示例</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> myClassMethod() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveClassMethod:(SEL)sel &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"built_in\">NSStringFromSelector</span>(sel) isEqualToString:<span class=\"string\">@&quot;classMethod&quot;</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *cls = [<span class=\"built_in\">NSStringFromClass</span>([<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>]) UTF8String];</span><br><span class=\"line\">        Class metaClass = objc_getMetaClass(cls);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> class_addMethod(metaClass, sel, (IMP)myClassMethod, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> resolveClassMethod:sel];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：</p>\n<ol>\n<li>对于类方法的动态解析需要给元类添加IMP</li>\n<li>由于NSObject的元类的父类为NSObject，所以也可以给NSObject的分类添加对应的实例方法</li>\n</ol>\n</blockquote>\n<p>对于实例方法的动态解析示例</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">void</span> <span class=\"selector-tag\">myInstanceMethod</span>() &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">NSLog</span>(@<span class=\"string\">&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (BOOL)<span class=\"selector-tag\">resolveInstanceMethod</span><span class=\"selector-pseudo\">:(SEL)sel</span> &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">if</span> ([NSStringFromSelector(sel) <span class=\"attribute\">isEqualToString</span>:@<span class=\"string\">&quot;instanceMethod&quot;</span>]) &#123;        </span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">class_addMethod</span>(self, sel, (IMP)myInstanceMethod, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">return</span> <span class=\"selector-attr\">[super resolveInstanceMethod:sel]</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-快速转发流程\"><a href=\"#2-快速转发流程\" class=\"headerlink\" title=\"2. 快速转发流程\"></a>2. 快速转发流程</h4><p>在<code>lookUpImpOrForward</code>函数中如果找到sel对应的imp，则走到<code>log_and_fill_cache</code>这步，将找到的imp放入缓存。</p>\n<p><code>log_and_fill_cache</code>源码解析</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void</span><br><span class=\"line\">log<span class=\"constructor\">_and_fill_cache(Class <span class=\"params\">cls</span>, IMP <span class=\"params\">imp</span>, SEL <span class=\"params\">sel</span>, <span class=\"params\">id</span> <span class=\"params\">receiver</span>, Class <span class=\"params\">implementer</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">#<span class=\"keyword\">if</span> SUPPORT_MESSAGE_LOGGING</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(objcMsgLogEnabled<span class=\"operator\"> &amp;&amp; </span>implementer)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">bool</span> cacheIt = log<span class=\"constructor\">MessageSend(<span class=\"params\">implementer</span>-&gt;<span class=\"params\">isMetaClass</span>()</span>, </span><br><span class=\"line\">                                      cls-&gt;name<span class=\"constructor\">ForLogging()</span>,</span><br><span class=\"line\">                                      implementer-&gt;name<span class=\"constructor\">ForLogging()</span>, </span><br><span class=\"line\">                                      sel);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cacheIt) return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">    cache<span class=\"constructor\">_fill(<span class=\"params\">cls</span>, <span class=\"params\">sel</span>, <span class=\"params\">imp</span>, <span class=\"params\">receiver</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以跟进<code>logMessageSend</code>函数-&gt;<code>logMessageSend</code>-&gt;<code>instrumentObjcMessageSends</code>，在<code>instrumentObjcMessageSends</code>传入的flag即可以打印到文件。<br>所以在外部定义函数如下</p>\n<figure class=\"highlight d\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"keyword\">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#<span class=\"keyword\">import</span> <span class=\"string\">&quot;LSPerson.h&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> instrumentObjcMessageSends(BOOL flag); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> main(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"built_in\">char</span> * argv[]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</span><br><span class=\"line\">        LSPerson *person = [[LSPerson alloc] init];</span><br><span class=\"line\">        instrumentObjcMessageSends(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        [person performSelector:<span class=\"keyword\">@selector</span>(eat)];</span><br><span class=\"line\">        instrumentObjcMessageSends(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">crash报错`</span>unrecognized selector sent to instance<span class=\"string\">`,然后由于是macos项目，则在`</span>/tmp/msgSends-xxx<span class=\"string\">`文件中可以看到如下调用顺序  </span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>LSPerson NSObject performSelector:</li>\n</ul>\n<ul>\n<li>LSPerson NSObject resolveInstanceMethod:</li>\n<li>LSPerson NSObject resolveInstanceMethod:</li>\n</ul>\n<ul>\n<li>LSPerson NSObject forwardingTargetForSelector:</li>\n<li>LSPerson NSObject forwardingTargetForSelector:</li>\n<li>LSPerson NSObject methodSignatureForSelector:</li>\n<li>LSPerson NSObject methodSignatureForSelector:</li>\n<li>LSPerson NSObject class</li>\n</ul>\n<ul>\n<li>LSPerson NSObject resolveInstanceMethod:</li>\n<li>LSPerson NSObject resolveInstanceMethod:</li>\n</ul>\n<ul>\n<li><p>LSPerson NSObject doesNotRecognizeSelector:</p>\n</li>\n<li><p>LSPerson NSObject doesNotRecognizeSelector:</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">可以看到调用之后没有找到方法除了会走动态解析逻辑`resolveInstanceMethod`，还走了`forwardingTargetForSelector`和`methodSignatureForSelector`分别对应**快速转发流程**和**慢速转发流程**。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 我理解的**快速转发流程**和**慢速转发流程**中的快慢是指在`objc_msgSend`中的先后顺序，并不是快速一定比慢速要快，或者效率更高。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 通过反汇编查看`____forwarding___`流程猜测如果函数返回空或者`self`，仍然会报错</span><br></pre></td></tr></table></figure>\n<p>loc_64bdc:<br>  rdi = rbx;<br>  rax = [rdi forwardingTargetForSelector:var_140];<br>  if ((rax == 0x0) || (rax == rbx)) goto loc_64c47;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">所以可以给自己类或者其他类添加sel对应的imp后返回</span><br></pre></td></tr></table></figure>\n<p>@implementation LSPerson</p>\n</li>\n<li><p>(void)run{<br>  NSLog(@”%s”, <strong>FUNCTION</strong>);<br>}</p>\n</li>\n<li><p>(id)forwardingTargetForSelector:(SEL)aSelector {<br>  if ([NSStringFromSelector(aSelector) isEqualToString:@”eat”]) {</p>\n<pre><code>  //获取LSPerson中的run方法\n  Method method = class_getInstanceMethod([self class], @selector(run));\n  const char *type = method_getTypeEncoding(method);\n  IMP imp = method_getImplementation(method);\n  //将aSelector指向run的imp\n  class_addMethod([self class], aSelector, imp, type);\n  return [LSPerson alloc];\n</code></pre>\n<p>  }<br>  return [super forwardingTargetForSelector:aSelector];<br>}<br>@end</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### <span class=\"number\">3.</span> 慢速转发流程</span><br></pre></td></tr></table></figure></li>\n<li><p>(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {<br>  if (aSelector == @selector(eat)) {</p>\n<pre><code>  NSMethodSignature *methodSignature = [NSMethodSignature signatureWithObjCTypes:&quot;v@@:&quot;];\n  return methodSignature;\n</code></pre>\n<p>  }<br>  return [super methodSignatureForSelector:aSelector];<br>}</p>\n</li>\n<li><p>(void)forwardInvocation:(NSInvocation *)anInvocation {<br>  SEL selector = anInvocation.selector;<br>  if ([[LSPerson alloc] respondsToSelector:selector]) {</p>\n<pre><code>  [anInvocation invokeWithTarget:[LSPerson alloc]];\n</code></pre>\n<p>  }else {</p>\n<pre><code>  [self doesNotRecognizeSelector:[anInvocation selector]];\n</code></pre>\n<p>  }<br>}</p>\n</li>\n<li><p>(void) doesNotRecognizeSelector: (SEL)aSelector<br>{<br>  NSLog(@”%@ does not recognize %@”,NSStringFromClass([self class]), NSStringFromSelector(aSelector));<br>}<br>```</p>\n<blockquote>\n<p>分析：</p>\n<ol>\n<li>在<code>methodSignatureForSelector</code>这个函数中返回一个aSelector对应的<code>NSMethodSignature *</code>的函数签名</li>\n<li>在<code>forwardInvocation</code>函数中同样像上述<strong>快速转发流程</strong>一样，修改消息接收者，即修改<code>anInvocation.target</code>指向，也可以根据模块前缀做相应的UI操作以及上报处理等。</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n"},{"title":"iOS APP启动流程","date":"2020-10-14T16:00:00.000Z","_content":"\n#### 1. `_dyld_start`入口函数\n在一个类的`+ (void)load`函数上打断点，查看此时的堆栈信息如下：\n```\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 2.1\n  * frame #0: 0x000000010d168ee7 test`+[ViewController load](self=ViewController, _cmd=\"load\") at ViewController.m:20:5\n    frame #1: 0x00007fff512a9477 libobjc.A.dylib`load_images + 1386\n    frame #2: 0x000000010d177e34 dyld_sim`dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*) + 418\n    frame #3: 0x000000010d185856 dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&, unsigned int, char const*, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 438\n    frame #4: 0x000000010d183d2c dyld_sim`ImageLoader::processInitializers(ImageLoader::LinkContext const&, unsigned int, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 188\n    frame #5: 0x000000010d183dcc dyld_sim`ImageLoader::runInitializers(ImageLoader::LinkContext const&, ImageLoader::InitializerTimingList&) + 82\n    frame #6: 0x000000010d178270 dyld_sim`dyld::initializeMainExecutable() + 199\n    frame #7: 0x000000010d17c1bb dyld_sim`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 3662\n    frame #8: 0x000000010d1771cd dyld_sim`start_sim + 122\n    frame #9: 0x00000001174ff85c dyld`dyld::useSimulatorDyld(int, macho_header const*, char const*, int, char const**, char const**, char const**, unsigned long*, unsigned long*) + 2308\n    frame #10: 0x00000001174fd4f4 dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 837\n    frame #11: 0x00000001174f8227 dyld`dyldbootstrap::start(dyld3::MachOLoaded const*, int, char const**, dyld3::MachOLoaded const*, unsigned long*) + 453\n    frame #12: 0x00000001174f8025 dyld`_dyld_start + 37\n```\n可以看到栈底信息是从`dyld`源码中的`_dyld_start`函数开始的，查看`dyld`源码可知该函数在`dyldStartup.s`的汇编文件中，通过查看汇编或以上栈信息可以得知下一个调用函数为`dyldbootstrap::start`。\n\n#### 2. `dyldbootstrap::start`源码分析\n```\nuintptr_t start(const dyld3::MachOLoaded* appsMachHeader, int argc, const char* argv[],\n\t\t\t\tconst dyld3::MachOLoaded* dyldsMachHeader, uintptr_t* startGlue)\n{\n\n    // Emit kdebug tracepoint to indicate dyld bootstrap has started <rdar://46878536>\n    dyld3::kdebug_trace_dyld_marker(DBG_DYLD_TIMING_BOOTSTRAP_START, 0, 0, 0, 0);\n\n\t// if kernel had to slide dyld, we need to fix up load sensitive locations\n\t// we have to do this before using any global variables\n    rebaseDyld(dyldsMachHeader);\n\n\t// kernel sets up env pointer to be just past end of agv array\n\tconst char** envp = &argv[argc+1];\n\t\n\t// kernel sets up apple pointer to be just past end of envp array\n\tconst char** apple = envp;\n\twhile(*apple != NULL) { ++apple; }\n\t++apple;\n\n\t// set up random value for stack canary\n\t__guard_setup(apple);\n\n#if DYLD_INITIALIZER_SUPPORT\n\t// run all C++ initializers inside dyld\n\trunDyldInitializers(argc, argv, envp, apple);\n#endif\n\n\t// now that we are done bootstrapping dyld, call dyld's main\n\tuintptr_t appsSlide = appsMachHeader->getSlide();\n\treturn dyld::_main((macho_header*)appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);\n}\n```\n分析： \n1. `rebaseDyld`在使用全局变量前修复dyld的地址偏移，同时会初始化进程和系统层\n2. 设置环境变量\n3. 现在的版本不需要初始化dyld了\n4. 获取地址偏移量，调用`dyld::_main`\n\n#### 3. `dyld::_main`源码分析\n```\nuintptr_t\n_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, \n\t\tint argc, const char* argv[], const char* envp[], const char* apple[], \n\t\tuintptr_t* startGlue)\n{\n\n...\n//加载共享缓存\nmapSharedCache();\n\n//加载可执行文件并实例化\n// instantiate ImageLoader for main executable\nsMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);\n\n//遍历加载插入的动态库\n// load any inserted libraries\nif\t( sEnv.DYLD_INSERT_LIBRARIES != NULL ) {\n\tfor (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) \n\t\tloadInsertedDylib(*lib);\n}\n\n//链接主程序\nlink(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);\n\n//在链接主程序之后，遍历链接已经插入的动态库\n// link any inserted libraries\n// do this after linking main executable so that any dylibs pulled in by inserted \n// dylibs (e.g. libSystem) will not be in front of dylibs the program uses\nif ( sInsertedDylibCount > 0 ) {\n\tfor(unsigned int i=0; i < sInsertedDylibCount; ++i) {\n\t\tImageLoader* image = sAllImages[i+1];\n\t\tlink(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);\n\t\timage->setNeverUnloadRecursive();\n\t}\n\tif ( gLinkContext.allowInterposing ) {\n\t\t// only INSERTED libraries can interpose\n\t\t// register interposing info after all inserted libraries are bound so chaining works\n\t\tfor(unsigned int i=0; i < sInsertedDylibCount; ++i) {\n\t\t\tImageLoader* image = sAllImages[i+1];\n\t\t\timage->registerInterposing(gLinkContext);\n\t\t}\n\t}\n}\n\n// 初始化主程序\ninitializeMainExecutable();\n\n// 通知监听程序调用main()函数 notify any montoring proccesses that this process is about to enter main() \nnotifyMonitoringDyldMain();\n...\n\n}\n```\n分析：`dyld::_main`主要做了以下几件事情：\n1. `mapSharedCache` 加载共享缓存\n2. `instantiateFromLoadedImage` 加载可执行文件并实例化\n3. `loadInsertedDylib` 遍历加载插入的动态库\n4. `link` 链接主程序\n5. 在链接主程序之后，遍历链接已经插入的动态库\n6. `initializeMainExecutable` 初始化主程序\n7. `notifyMonitoringDyldMain` 通知监听程序调用main()函数  \n\n此时main函数之前的流程已经走完了，下面说下`dyld`如何和`objc`关联起来的。\n\n------\n在上述初始化主程序`initializeMainExecutable`函数中，`initializeMainExecutable` -> `runInitializers` -> `processInitializers`\n\n#### 4.`initializeMainExecutable`源码\n```\nvoid initializeMainExecutable()\n{\n\t// record that we've reached this step\n\tgLinkContext.startedInitializingMainExecutable = true;\n\n\t// run initialzers for any inserted dylibs\n\tImageLoader::InitializerTimingList initializerTimes[allImagesCount()];\n\tinitializerTimes[0].count = 0;\n\tconst size_t rootCount = sImageRoots.size();\n\tif ( rootCount > 1 ) {\n\t\tfor(size_t i=1; i < rootCount; ++i) {\n\t\t\tsImageRoots[i]->runInitializers(gLinkContext, initializerTimes[0]);\n\t\t}\n\t}\n\t\n\t// run initializers for main executable and everything it brings up \n\tsMainExecutable->runInitializers(gLinkContext, initializerTimes[0]);\n\t\n\t// register cxa_atexit() handler to run static terminators in all loaded images when this process exits\n\tif ( gLibSystemHelpers != NULL ) \n\t\t(*gLibSystemHelpers->cxa_atexit)(&runAllStaticTerminators, NULL, NULL);\n\n\t// dump info if requested\n\tif ( sEnv.DYLD_PRINT_STATISTICS )\n\t\tImageLoader::printStatistics((unsigned int)allImagesCount(), initializerTimes[0]);\n\tif ( sEnv.DYLD_PRINT_STATISTICS_DETAILS )\n\t\tImageLoaderMachO::printStatisticsDetails((unsigned int)allImagesCount(), initializerTimes[0]);\n}\n```\n分析：\n1. 初始化所有已经插入的动态库\n2. 初始化主程序\n\n#### 5. `processInitializers`源码\n```\nvoid ImageLoader::processInitializers(const LinkContext& context, mach_port_t thisThread,\n\t\t\t\t\t\t\t\t\t InitializerTimingList& timingInfo, ImageLoader::UninitedUpwards& images)\n{\n\tuint32_t maxImageCount = context.imageCount()+2;\n\tImageLoader::UninitedUpwards upsBuffer[maxImageCount];\n\tImageLoader::UninitedUpwards& ups = upsBuffer[0];\n\tups.count = 0;\n\t// Calling recursive init on all images in images list, building a new list of\n\t// uninitialized upward dependencies.\n\tfor (uintptr_t i=0; i < images.count; ++i) {\n\t\timages.imagesAndPaths[i].first->recursiveInitialization(context, thisThread, images.imagesAndPaths[i].second, timingInfo, ups);\n\t}\n\t// If any upward dependencies remain, init them.\n\tif ( ups.count > 0 )\n\t\tprocessInitializers(context, thisThread, timingInfo, ups);\n}\n```\n分析：\n1. 初始化所有images，调用`recursiveInitialization`递归其依赖的镜像进行初始化，直至全部初始化完成\n\n#### 6. `recursiveInitialization`源码\n```\nvoid ImageLoader::recursiveInitialization(const LinkContext& context, mach_port_t this_thread, const char* pathToInitialize,\n\t\t\t\t\t\t\t\t\t\t  InitializerTimingList& timingInfo, UninitedUpwards& uninitUps)\n{ \n \n \t...省略部分代码\n \t\n\t// initialize lower level libraries first\n\tfor(unsigned int i=0; i < libraryCount(); ++i) {\n\t\tImageLoader* dependentImage = libImage(i);\n\t\tif ( dependentImage != NULL ) {\n\t\t\t// don't try to initialize stuff \"above\" me yet\n\t\t\tif ( libIsUpward(i) ) {\n\t\t\t\tuninitUps.imagesAndPaths[uninitUps.count] = { dependentImage, libPath(i) };\n\t\t\t\tuninitUps.count++;\n\t\t\t}\n\t\t\telse if ( dependentImage->fDepth >= fDepth ) {\n\t\t\t\tdependentImage->recursiveInitialization(context, this_thread, libPath(i), timingInfo, uninitUps);\n\t\t\t}\n        }\n\t} \n\n\t// let objc know we are about to initialize this image\n\tuint64_t t1 = mach_absolute_time();\n\tfState = dyld_image_state_dependents_initialized;\n\toldState = fState;\n\tcontext.notifySingle(dyld_image_state_dependents_initialized, this, &timingInfo);\n\t\n\t// initialize this image\n\tbool hasInitializers = this->doInitialization(context);\n\n\t// let anyone know we finished initializing this image\n\tfState = dyld_image_state_initialized;\n\toldState = fState;\n\tcontext.notifySingle(dyld_image_state_initialized, this, NULL);\n\t \n}\n```\n分析：\n1. 首先保证初始化级别较低，被依赖的镜像\n2. `notifySingle`通知objc初始化该镜像\n3. `doInitialization`初始化该镜像\n4. `notifySingle`通知objc初始化该镜像完毕\n\n#### 7.`notifySingle`流程\n1. 看上去`notifySingle`应该是类似发了个通知的\n2. 在源码中可以看到调用了`(*sNotifyObjCInit)(image->getRealPath(), image->machHeader());`函数\n3. `sNotifyObjCInit`是在`registerObjCNotifiers`函数中赋值的第二个参数\n4. `registerObjCNotifiers`是在`_dyld_objc_notify_register`函数中调用的\n5. `_dyld_objc_notify_register`看着比较眼熟，实在`libobjc`源码中`_objc_init`函数中调用的\n6. 那`_objc_init`是在何时调用的呢？\n\n通过在`_objc_init`添加符号断点，查看堆栈如下\n```\nframe #0: 0x000000010dd9cb6b libobjc.A.dylib`_objc_init\nframe #1: 0x000000010f7c2789 libdispatch.dylib`_os_object_init + 13\nframe #2: 0x000000010f7d12e3 libdispatch.dylib`libdispatch_init + 300\nframe #3: 0x000000010ddd785f libSystem.B.dylib`libSystem_initializer + 252\nframe #4: 0x000000010d4f26d9 dyld_sim`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext const&) + 513\nframe #5: 0x000000010d4f2ace dyld_sim`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext const&) + 40\nframe #6: 0x000000010d4ed868 dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&, unsigned int, char const*, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 456\nframe #7: 0x000000010d4ed7d5 dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&, unsigned int, char const*, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 309\nframe #8: 0x000000010d4ebd2c dyld_sim`ImageLoader::processInitializers(ImageLoader::LinkContext const&, unsigned int, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 188\nframe #9: 0x000000010d4ebdcc dyld_sim`ImageLoader::runInitializers(ImageLoader::LinkContext const&, ImageLoader::InitializerTimingList&) + 82\nframe #10: 0x000000010d4e022a dyld_sim`dyld::initializeMainExecutable() + 129\nframe #11: 0x000000010d4e41bb dyld_sim`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 3662\nframe #12: 0x000000010d4df1cd dyld_sim`start_sim + 122\nframe #13: 0x0000000111d1379a dyld`dyld::useSimulatorDyld(int, macho_header const*, char const*, int, char const**, char const**, char const**, unsigned long*, unsigned long*) + 2308\nframe #14: 0x0000000111d11432 dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 837\nframe #15: 0x0000000111d0c227 dyld`dyldbootstrap::start(dyld3::MachOLoaded const*, int, char const**, dyld3::MachOLoaded const*, unsigned long*) + 453\nframe #16: 0x0000000111d0c025 dyld`_dyld_start + 37\n```\n发现`doModInitFunctions` -> `libSystem_initializer` -> `libdispatch_init` -> `_os_object_init` -> `_objc_init`\n\n#### 8. `doInitialization`源码\n```\nbool ImageLoaderMachO::doInitialization(const LinkContext& context)\n{\n\tCRSetCrashLogMessage2(this->getPath());\n\n\t// mach-o has -init and static initializers\n\tdoImageInit(context);\n\tdoModInitFunctions(context);\n\t\n\tCRSetCrashLogMessage2(NULL);\n\t\n\treturn (fHasDashInit || fHasInitializers);\n}\n```\n在`doInitialization`中初始化镜像以及静态C++的构造函数，注意：在`doInitialization`之前需要首先确保`libSystem`已经初始化。\n\n#### 总结：\n`dyld->objc` 流程\n\n`_dyld_start` -> `` -> `dyldbootstrap::start` -> `dyld::_main` -> `dyld::initializeMainExecutable` -> `ImageLoader::runInitializers` -> `ImageLoader::processInitializers` -> `ImageLoader::recursiveInitialization` -> `doInitialization` -> `libSystem_initializer` -> `libdispatch_init` -> `_os_object_init` ->  `_objc_init`  -> `_dyld_objc_notify_register`\n在`doInitialization`调用完成之后，调用 `_dyld_objc_notify_register`函数注册的`load_images`函数，至此由runtime接管app运行。\n\n![dyld->objc流程.png](https://upload-images.jianshu.io/upload_images/1395687-ebb30dca022ea4fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","source":"_posts/2020-10-15-iOS APP启动流程.md","raw":"---\ntitle:      \"iOS APP启动流程\" \ndate:       2020-10-15\ntags:\n    - iOS底层原理\ncategories:\n    - iOS底层原理\n---\n\n#### 1. `_dyld_start`入口函数\n在一个类的`+ (void)load`函数上打断点，查看此时的堆栈信息如下：\n```\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 2.1\n  * frame #0: 0x000000010d168ee7 test`+[ViewController load](self=ViewController, _cmd=\"load\") at ViewController.m:20:5\n    frame #1: 0x00007fff512a9477 libobjc.A.dylib`load_images + 1386\n    frame #2: 0x000000010d177e34 dyld_sim`dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*) + 418\n    frame #3: 0x000000010d185856 dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&, unsigned int, char const*, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 438\n    frame #4: 0x000000010d183d2c dyld_sim`ImageLoader::processInitializers(ImageLoader::LinkContext const&, unsigned int, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 188\n    frame #5: 0x000000010d183dcc dyld_sim`ImageLoader::runInitializers(ImageLoader::LinkContext const&, ImageLoader::InitializerTimingList&) + 82\n    frame #6: 0x000000010d178270 dyld_sim`dyld::initializeMainExecutable() + 199\n    frame #7: 0x000000010d17c1bb dyld_sim`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 3662\n    frame #8: 0x000000010d1771cd dyld_sim`start_sim + 122\n    frame #9: 0x00000001174ff85c dyld`dyld::useSimulatorDyld(int, macho_header const*, char const*, int, char const**, char const**, char const**, unsigned long*, unsigned long*) + 2308\n    frame #10: 0x00000001174fd4f4 dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 837\n    frame #11: 0x00000001174f8227 dyld`dyldbootstrap::start(dyld3::MachOLoaded const*, int, char const**, dyld3::MachOLoaded const*, unsigned long*) + 453\n    frame #12: 0x00000001174f8025 dyld`_dyld_start + 37\n```\n可以看到栈底信息是从`dyld`源码中的`_dyld_start`函数开始的，查看`dyld`源码可知该函数在`dyldStartup.s`的汇编文件中，通过查看汇编或以上栈信息可以得知下一个调用函数为`dyldbootstrap::start`。\n\n#### 2. `dyldbootstrap::start`源码分析\n```\nuintptr_t start(const dyld3::MachOLoaded* appsMachHeader, int argc, const char* argv[],\n\t\t\t\tconst dyld3::MachOLoaded* dyldsMachHeader, uintptr_t* startGlue)\n{\n\n    // Emit kdebug tracepoint to indicate dyld bootstrap has started <rdar://46878536>\n    dyld3::kdebug_trace_dyld_marker(DBG_DYLD_TIMING_BOOTSTRAP_START, 0, 0, 0, 0);\n\n\t// if kernel had to slide dyld, we need to fix up load sensitive locations\n\t// we have to do this before using any global variables\n    rebaseDyld(dyldsMachHeader);\n\n\t// kernel sets up env pointer to be just past end of agv array\n\tconst char** envp = &argv[argc+1];\n\t\n\t// kernel sets up apple pointer to be just past end of envp array\n\tconst char** apple = envp;\n\twhile(*apple != NULL) { ++apple; }\n\t++apple;\n\n\t// set up random value for stack canary\n\t__guard_setup(apple);\n\n#if DYLD_INITIALIZER_SUPPORT\n\t// run all C++ initializers inside dyld\n\trunDyldInitializers(argc, argv, envp, apple);\n#endif\n\n\t// now that we are done bootstrapping dyld, call dyld's main\n\tuintptr_t appsSlide = appsMachHeader->getSlide();\n\treturn dyld::_main((macho_header*)appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);\n}\n```\n分析： \n1. `rebaseDyld`在使用全局变量前修复dyld的地址偏移，同时会初始化进程和系统层\n2. 设置环境变量\n3. 现在的版本不需要初始化dyld了\n4. 获取地址偏移量，调用`dyld::_main`\n\n#### 3. `dyld::_main`源码分析\n```\nuintptr_t\n_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, \n\t\tint argc, const char* argv[], const char* envp[], const char* apple[], \n\t\tuintptr_t* startGlue)\n{\n\n...\n//加载共享缓存\nmapSharedCache();\n\n//加载可执行文件并实例化\n// instantiate ImageLoader for main executable\nsMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);\n\n//遍历加载插入的动态库\n// load any inserted libraries\nif\t( sEnv.DYLD_INSERT_LIBRARIES != NULL ) {\n\tfor (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) \n\t\tloadInsertedDylib(*lib);\n}\n\n//链接主程序\nlink(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);\n\n//在链接主程序之后，遍历链接已经插入的动态库\n// link any inserted libraries\n// do this after linking main executable so that any dylibs pulled in by inserted \n// dylibs (e.g. libSystem) will not be in front of dylibs the program uses\nif ( sInsertedDylibCount > 0 ) {\n\tfor(unsigned int i=0; i < sInsertedDylibCount; ++i) {\n\t\tImageLoader* image = sAllImages[i+1];\n\t\tlink(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);\n\t\timage->setNeverUnloadRecursive();\n\t}\n\tif ( gLinkContext.allowInterposing ) {\n\t\t// only INSERTED libraries can interpose\n\t\t// register interposing info after all inserted libraries are bound so chaining works\n\t\tfor(unsigned int i=0; i < sInsertedDylibCount; ++i) {\n\t\t\tImageLoader* image = sAllImages[i+1];\n\t\t\timage->registerInterposing(gLinkContext);\n\t\t}\n\t}\n}\n\n// 初始化主程序\ninitializeMainExecutable();\n\n// 通知监听程序调用main()函数 notify any montoring proccesses that this process is about to enter main() \nnotifyMonitoringDyldMain();\n...\n\n}\n```\n分析：`dyld::_main`主要做了以下几件事情：\n1. `mapSharedCache` 加载共享缓存\n2. `instantiateFromLoadedImage` 加载可执行文件并实例化\n3. `loadInsertedDylib` 遍历加载插入的动态库\n4. `link` 链接主程序\n5. 在链接主程序之后，遍历链接已经插入的动态库\n6. `initializeMainExecutable` 初始化主程序\n7. `notifyMonitoringDyldMain` 通知监听程序调用main()函数  \n\n此时main函数之前的流程已经走完了，下面说下`dyld`如何和`objc`关联起来的。\n\n------\n在上述初始化主程序`initializeMainExecutable`函数中，`initializeMainExecutable` -> `runInitializers` -> `processInitializers`\n\n#### 4.`initializeMainExecutable`源码\n```\nvoid initializeMainExecutable()\n{\n\t// record that we've reached this step\n\tgLinkContext.startedInitializingMainExecutable = true;\n\n\t// run initialzers for any inserted dylibs\n\tImageLoader::InitializerTimingList initializerTimes[allImagesCount()];\n\tinitializerTimes[0].count = 0;\n\tconst size_t rootCount = sImageRoots.size();\n\tif ( rootCount > 1 ) {\n\t\tfor(size_t i=1; i < rootCount; ++i) {\n\t\t\tsImageRoots[i]->runInitializers(gLinkContext, initializerTimes[0]);\n\t\t}\n\t}\n\t\n\t// run initializers for main executable and everything it brings up \n\tsMainExecutable->runInitializers(gLinkContext, initializerTimes[0]);\n\t\n\t// register cxa_atexit() handler to run static terminators in all loaded images when this process exits\n\tif ( gLibSystemHelpers != NULL ) \n\t\t(*gLibSystemHelpers->cxa_atexit)(&runAllStaticTerminators, NULL, NULL);\n\n\t// dump info if requested\n\tif ( sEnv.DYLD_PRINT_STATISTICS )\n\t\tImageLoader::printStatistics((unsigned int)allImagesCount(), initializerTimes[0]);\n\tif ( sEnv.DYLD_PRINT_STATISTICS_DETAILS )\n\t\tImageLoaderMachO::printStatisticsDetails((unsigned int)allImagesCount(), initializerTimes[0]);\n}\n```\n分析：\n1. 初始化所有已经插入的动态库\n2. 初始化主程序\n\n#### 5. `processInitializers`源码\n```\nvoid ImageLoader::processInitializers(const LinkContext& context, mach_port_t thisThread,\n\t\t\t\t\t\t\t\t\t InitializerTimingList& timingInfo, ImageLoader::UninitedUpwards& images)\n{\n\tuint32_t maxImageCount = context.imageCount()+2;\n\tImageLoader::UninitedUpwards upsBuffer[maxImageCount];\n\tImageLoader::UninitedUpwards& ups = upsBuffer[0];\n\tups.count = 0;\n\t// Calling recursive init on all images in images list, building a new list of\n\t// uninitialized upward dependencies.\n\tfor (uintptr_t i=0; i < images.count; ++i) {\n\t\timages.imagesAndPaths[i].first->recursiveInitialization(context, thisThread, images.imagesAndPaths[i].second, timingInfo, ups);\n\t}\n\t// If any upward dependencies remain, init them.\n\tif ( ups.count > 0 )\n\t\tprocessInitializers(context, thisThread, timingInfo, ups);\n}\n```\n分析：\n1. 初始化所有images，调用`recursiveInitialization`递归其依赖的镜像进行初始化，直至全部初始化完成\n\n#### 6. `recursiveInitialization`源码\n```\nvoid ImageLoader::recursiveInitialization(const LinkContext& context, mach_port_t this_thread, const char* pathToInitialize,\n\t\t\t\t\t\t\t\t\t\t  InitializerTimingList& timingInfo, UninitedUpwards& uninitUps)\n{ \n \n \t...省略部分代码\n \t\n\t// initialize lower level libraries first\n\tfor(unsigned int i=0; i < libraryCount(); ++i) {\n\t\tImageLoader* dependentImage = libImage(i);\n\t\tif ( dependentImage != NULL ) {\n\t\t\t// don't try to initialize stuff \"above\" me yet\n\t\t\tif ( libIsUpward(i) ) {\n\t\t\t\tuninitUps.imagesAndPaths[uninitUps.count] = { dependentImage, libPath(i) };\n\t\t\t\tuninitUps.count++;\n\t\t\t}\n\t\t\telse if ( dependentImage->fDepth >= fDepth ) {\n\t\t\t\tdependentImage->recursiveInitialization(context, this_thread, libPath(i), timingInfo, uninitUps);\n\t\t\t}\n        }\n\t} \n\n\t// let objc know we are about to initialize this image\n\tuint64_t t1 = mach_absolute_time();\n\tfState = dyld_image_state_dependents_initialized;\n\toldState = fState;\n\tcontext.notifySingle(dyld_image_state_dependents_initialized, this, &timingInfo);\n\t\n\t// initialize this image\n\tbool hasInitializers = this->doInitialization(context);\n\n\t// let anyone know we finished initializing this image\n\tfState = dyld_image_state_initialized;\n\toldState = fState;\n\tcontext.notifySingle(dyld_image_state_initialized, this, NULL);\n\t \n}\n```\n分析：\n1. 首先保证初始化级别较低，被依赖的镜像\n2. `notifySingle`通知objc初始化该镜像\n3. `doInitialization`初始化该镜像\n4. `notifySingle`通知objc初始化该镜像完毕\n\n#### 7.`notifySingle`流程\n1. 看上去`notifySingle`应该是类似发了个通知的\n2. 在源码中可以看到调用了`(*sNotifyObjCInit)(image->getRealPath(), image->machHeader());`函数\n3. `sNotifyObjCInit`是在`registerObjCNotifiers`函数中赋值的第二个参数\n4. `registerObjCNotifiers`是在`_dyld_objc_notify_register`函数中调用的\n5. `_dyld_objc_notify_register`看着比较眼熟，实在`libobjc`源码中`_objc_init`函数中调用的\n6. 那`_objc_init`是在何时调用的呢？\n\n通过在`_objc_init`添加符号断点，查看堆栈如下\n```\nframe #0: 0x000000010dd9cb6b libobjc.A.dylib`_objc_init\nframe #1: 0x000000010f7c2789 libdispatch.dylib`_os_object_init + 13\nframe #2: 0x000000010f7d12e3 libdispatch.dylib`libdispatch_init + 300\nframe #3: 0x000000010ddd785f libSystem.B.dylib`libSystem_initializer + 252\nframe #4: 0x000000010d4f26d9 dyld_sim`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext const&) + 513\nframe #5: 0x000000010d4f2ace dyld_sim`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext const&) + 40\nframe #6: 0x000000010d4ed868 dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&, unsigned int, char const*, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 456\nframe #7: 0x000000010d4ed7d5 dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&, unsigned int, char const*, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 309\nframe #8: 0x000000010d4ebd2c dyld_sim`ImageLoader::processInitializers(ImageLoader::LinkContext const&, unsigned int, ImageLoader::InitializerTimingList&, ImageLoader::UninitedUpwards&) + 188\nframe #9: 0x000000010d4ebdcc dyld_sim`ImageLoader::runInitializers(ImageLoader::LinkContext const&, ImageLoader::InitializerTimingList&) + 82\nframe #10: 0x000000010d4e022a dyld_sim`dyld::initializeMainExecutable() + 129\nframe #11: 0x000000010d4e41bb dyld_sim`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 3662\nframe #12: 0x000000010d4df1cd dyld_sim`start_sim + 122\nframe #13: 0x0000000111d1379a dyld`dyld::useSimulatorDyld(int, macho_header const*, char const*, int, char const**, char const**, char const**, unsigned long*, unsigned long*) + 2308\nframe #14: 0x0000000111d11432 dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + 837\nframe #15: 0x0000000111d0c227 dyld`dyldbootstrap::start(dyld3::MachOLoaded const*, int, char const**, dyld3::MachOLoaded const*, unsigned long*) + 453\nframe #16: 0x0000000111d0c025 dyld`_dyld_start + 37\n```\n发现`doModInitFunctions` -> `libSystem_initializer` -> `libdispatch_init` -> `_os_object_init` -> `_objc_init`\n\n#### 8. `doInitialization`源码\n```\nbool ImageLoaderMachO::doInitialization(const LinkContext& context)\n{\n\tCRSetCrashLogMessage2(this->getPath());\n\n\t// mach-o has -init and static initializers\n\tdoImageInit(context);\n\tdoModInitFunctions(context);\n\t\n\tCRSetCrashLogMessage2(NULL);\n\t\n\treturn (fHasDashInit || fHasInitializers);\n}\n```\n在`doInitialization`中初始化镜像以及静态C++的构造函数，注意：在`doInitialization`之前需要首先确保`libSystem`已经初始化。\n\n#### 总结：\n`dyld->objc` 流程\n\n`_dyld_start` -> `` -> `dyldbootstrap::start` -> `dyld::_main` -> `dyld::initializeMainExecutable` -> `ImageLoader::runInitializers` -> `ImageLoader::processInitializers` -> `ImageLoader::recursiveInitialization` -> `doInitialization` -> `libSystem_initializer` -> `libdispatch_init` -> `_os_object_init` ->  `_objc_init`  -> `_dyld_objc_notify_register`\n在`doInitialization`调用完成之后，调用 `_dyld_objc_notify_register`函数注册的`load_images`函数，至此由runtime接管app运行。\n\n![dyld->objc流程.png](https://upload-images.jianshu.io/upload_images/1395687-ebb30dca022ea4fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","slug":"2020-10-15-iOS APP启动流程","published":1,"updated":"2021-06-19T03:46:24.088Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq3hjbqp003fbjrjhlu8ccxq","content":"<h4 id=\"1-dyld-start入口函数\"><a href=\"#1-dyld-start入口函数\" class=\"headerlink\" title=\"1. _dyld_start入口函数\"></a>1. <code>_dyld_start</code>入口函数</h4><p>在一个类的<code>+ (void)load</code>函数上打断点，查看此时的堆栈信息如下：</p>\n<figure class=\"highlight zephir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* thread #<span class=\"number\">1</span>, queue = <span class=\"string\">&#x27;com.apple.main-thread&#x27;</span>, stop reason = breakpoint <span class=\"number\">2.1</span></span><br><span class=\"line\">  * frame #<span class=\"number\">0</span>: <span class=\"number\">0x000000010d168ee7</span> test`+[ViewController load](<span class=\"keyword\">self</span>=ViewController, _cmd=<span class=\"string\">&quot;load&quot;</span>) at ViewController.m:<span class=\"number\">20</span>:<span class=\"number\">5</span></span><br><span class=\"line\">    frame #<span class=\"number\">1</span>: <span class=\"number\">0x00007fff512a9477</span> libobjc.A.dylib`load_images + <span class=\"number\">1386</span></span><br><span class=\"line\">    frame #<span class=\"number\">2</span>: <span class=\"number\">0x000000010d177e34</span> dyld_sim`dyld::notifySingle(dyld_image_states, ImageLoader <span class=\"keyword\">const</span>*, ImageLoader::InitializerTimingList*) + <span class=\"number\">418</span></span><br><span class=\"line\">    frame #<span class=\"number\">3</span>: <span class=\"number\">0x000000010d185856</span> dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext <span class=\"keyword\">const</span>&amp;, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class=\"number\">438</span></span><br><span class=\"line\">    frame #<span class=\"number\">4</span>: <span class=\"number\">0x000000010d183d2c</span> dyld_sim`ImageLoader::processInitializers(ImageLoader::LinkContext <span class=\"keyword\">const</span>&amp;, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class=\"number\">188</span></span><br><span class=\"line\">    frame #<span class=\"number\">5</span>: <span class=\"number\">0x000000010d183dcc</span> dyld_sim`ImageLoader::runInitializers(ImageLoader::LinkContext <span class=\"keyword\">const</span>&amp;, ImageLoader::InitializerTimingList&amp;) + <span class=\"number\">82</span></span><br><span class=\"line\">    frame #<span class=\"number\">6</span>: <span class=\"number\">0x000000010d178270</span> dyld_sim`dyld::initializeMainExecutable() + <span class=\"number\">199</span></span><br><span class=\"line\">    frame #<span class=\"number\">7</span>: <span class=\"number\">0x000000010d17c1bb</span> dyld_sim`dyld::_main(macho_header <span class=\"keyword\">const</span>*, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>, <span class=\"keyword\">int</span>, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>**, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>**, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>**, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>*) + <span class=\"number\">3662</span></span><br><span class=\"line\">    frame #<span class=\"number\">8</span>: <span class=\"number\">0x000000010d1771cd</span> dyld_sim`start_sim + <span class=\"number\">122</span></span><br><span class=\"line\">    frame #<span class=\"number\">9</span>: <span class=\"number\">0x00000001174ff85c</span> dyld`dyld::useSimulatorDyld(<span class=\"keyword\">int</span>, macho_header <span class=\"keyword\">const</span>*, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>*, <span class=\"keyword\">int</span>, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>**, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>**, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>**, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>*, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>*) + <span class=\"number\">2308</span></span><br><span class=\"line\">    frame #<span class=\"number\">10</span>: <span class=\"number\">0x00000001174fd4f4</span> dyld`dyld::_main(macho_header <span class=\"keyword\">const</span>*, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>, <span class=\"keyword\">int</span>, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>**, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>**, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>**, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>*) + <span class=\"number\">837</span></span><br><span class=\"line\">    frame #<span class=\"number\">11</span>: <span class=\"number\">0x00000001174f8227</span> dyld`dyldbootstrap::start(dyld3::MachOLoaded <span class=\"keyword\">const</span>*, <span class=\"keyword\">int</span>, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>**, dyld3::MachOLoaded <span class=\"keyword\">const</span>*, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>*) + <span class=\"number\">453</span></span><br><span class=\"line\">    frame #<span class=\"number\">12</span>: <span class=\"number\">0x00000001174f8025</span> dyld`_dyld_start + <span class=\"number\">37</span></span><br></pre></td></tr></table></figure>\n<p>可以看到栈底信息是从<code>dyld</code>源码中的<code>_dyld_start</code>函数开始的，查看<code>dyld</code>源码可知该函数在<code>dyldStartup.s</code>的汇编文件中，通过查看汇编或以上栈信息可以得知下一个调用函数为<code>dyldbootstrap::start</code>。</p>\n<h4 id=\"2-dyldbootstrap-start源码分析\"><a href=\"#2-dyldbootstrap-start源码分析\" class=\"headerlink\" title=\"2. dyldbootstrap::start源码分析\"></a>2. <code>dyldbootstrap::start</code>源码分析</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">uintptr_t</span> <span class=\"title\">start</span><span class=\"params\">(<span class=\"keyword\">const</span> dyld3::MachOLoaded* appsMachHeader, <span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* argv[],</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t<span class=\"keyword\">const</span> dyld3::MachOLoaded* dyldsMachHeader, <span class=\"keyword\">uintptr_t</span>* startGlue)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Emit kdebug tracepoint to indicate dyld bootstrap has started &lt;rdar://46878536&gt;</span></span><br><span class=\"line\">    dyld3::kdebug_trace_dyld_marker(DBG_DYLD_TIMING_BOOTSTRAP_START, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// if kernel had to slide dyld, we need to fix up load sensitive locations</span></span><br><span class=\"line\">\t<span class=\"comment\">// we have to do this before using any global variables</span></span><br><span class=\"line\">    rebaseDyld(dyldsMachHeader);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// kernel sets up env pointer to be just past end of agv array</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>** envp = &amp;argv[argc+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// kernel sets up apple pointer to be just past end of envp array</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>** apple = envp;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(*apple != <span class=\"literal\">NULL</span>) &#123; ++apple; &#125;</span><br><span class=\"line\">\t++apple;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// set up random value for stack canary</span></span><br><span class=\"line\">\t__guard_setup(apple);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> DYLD_INITIALIZER_SUPPORT</span></span><br><span class=\"line\">\t<span class=\"comment\">// run all C++ initializers inside dyld</span></span><br><span class=\"line\">\trunDyldInitializers(argc, argv, envp, apple);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// now that we are done bootstrapping dyld, call dyld&#x27;s main</span></span><br><span class=\"line\">\t<span class=\"keyword\">uintptr_t</span> appsSlide = appsMachHeader-&gt;getSlide();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dyld::_main((macho_header*)appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析： </p>\n<ol>\n<li><code>rebaseDyld</code>在使用全局变量前修复dyld的地址偏移，同时会初始化进程和系统层</li>\n<li>设置环境变量</li>\n<li>现在的版本不需要初始化dyld了</li>\n<li>获取地址偏移量，调用<code>dyld::_main</code></li>\n</ol>\n<h4 id=\"3-dyld-main源码分析\"><a href=\"#3-dyld-main源码分析\" class=\"headerlink\" title=\"3. dyld::_main源码分析\"></a>3. <code>dyld::_main</code>源码分析</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">uintptr_t</span></span><br><span class=\"line\">_main(<span class=\"keyword\">const</span> macho_header* mainExecutableMH, <span class=\"keyword\">uintptr_t</span> mainExecutableSlide, </span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* argv[], <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* envp[], <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* apple[], </span><br><span class=\"line\">\t\t<span class=\"keyword\">uintptr_t</span>* startGlue)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">//加载共享缓存</span></span><br><span class=\"line\">mapSharedCache();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//加载可执行文件并实例化</span></span><br><span class=\"line\"><span class=\"comment\">// instantiate ImageLoader for main executable</span></span><br><span class=\"line\">sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//遍历加载插入的动态库</span></span><br><span class=\"line\"><span class=\"comment\">// load any inserted libraries</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>\t( sEnv.DYLD_INSERT_LIBRARIES != <span class=\"literal\">NULL</span> ) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class=\"literal\">NULL</span>; ++lib) </span><br><span class=\"line\">\t\tloadInsertedDylib(*lib);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//链接主程序</span></span><br><span class=\"line\">link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, <span class=\"literal\">true</span>, ImageLoader::RPathChain(<span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>), <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在链接主程序之后，遍历链接已经插入的动态库</span></span><br><span class=\"line\"><span class=\"comment\">// link any inserted libraries</span></span><br><span class=\"line\"><span class=\"comment\">// do this after linking main executable so that any dylibs pulled in by inserted </span></span><br><span class=\"line\"><span class=\"comment\">// dylibs (e.g. libSystem) will not be in front of dylibs the program uses</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ( sInsertedDylibCount &gt; <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class=\"line\">\t\tImageLoader* <span class=\"built_in\">image</span> = sAllImages[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\tlink(<span class=\"built_in\">image</span>, sEnv.DYLD_BIND_AT_LAUNCH, <span class=\"literal\">true</span>, ImageLoader::RPathChain(<span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>), <span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">image</span>-&gt;setNeverUnloadRecursive();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( gLinkContext.allowInterposing ) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// only INSERTED libraries can interpose</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// register interposing info after all inserted libraries are bound so chaining works</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class=\"line\">\t\t\tImageLoader* <span class=\"built_in\">image</span> = sAllImages[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">image</span>-&gt;registerInterposing(gLinkContext);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化主程序</span></span><br><span class=\"line\">initializeMainExecutable();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通知监听程序调用main()函数 notify any montoring proccesses that this process is about to enter main() </span></span><br><span class=\"line\">notifyMonitoringDyldMain();</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析：<code>dyld::_main</code>主要做了以下几件事情：</p>\n<ol>\n<li><code>mapSharedCache</code> 加载共享缓存</li>\n<li><code>instantiateFromLoadedImage</code> 加载可执行文件并实例化</li>\n<li><code>loadInsertedDylib</code> 遍历加载插入的动态库</li>\n<li><code>link</code> 链接主程序</li>\n<li>在链接主程序之后，遍历链接已经插入的动态库</li>\n<li><code>initializeMainExecutable</code> 初始化主程序</li>\n<li><code>notifyMonitoringDyldMain</code> 通知监听程序调用main()函数  </li>\n</ol>\n<p>此时main函数之前的流程已经走完了，下面说下<code>dyld</code>如何和<code>objc</code>关联起来的。</p>\n<hr>\n<p>在上述初始化主程序<code>initializeMainExecutable</code>函数中，<code>initializeMainExecutable</code> -&gt; <code>runInitializers</code> -&gt; <code>processInitializers</code></p>\n<h4 id=\"4-initializeMainExecutable源码\"><a href=\"#4-initializeMainExecutable源码\" class=\"headerlink\" title=\"4.initializeMainExecutable源码\"></a>4.<code>initializeMainExecutable</code>源码</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initializeMainExecutable</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// record that we&#x27;ve reached this step</span></span><br><span class=\"line\">\tgLinkContext.startedInitializingMainExecutable = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// run initialzers for any inserted dylibs</span></span><br><span class=\"line\">\tImageLoader::InitializerTimingList initializerTimes[allImagesCount()];</span><br><span class=\"line\">\tinitializerTimes[<span class=\"number\">0</span>].count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">size_t</span> rootCount = sImageRoots.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( rootCount &gt; <span class=\"number\">1</span> ) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i=<span class=\"number\">1</span>; i &lt; rootCount; ++i) &#123;</span><br><span class=\"line\">\t\t\tsImageRoots[i]-&gt;runInitializers(gLinkContext, initializerTimes[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// run initializers for main executable and everything it brings up </span></span><br><span class=\"line\">\tsMainExecutable-&gt;runInitializers(gLinkContext, initializerTimes[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( gLibSystemHelpers != <span class=\"literal\">NULL</span> ) </span><br><span class=\"line\">\t\t(*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// dump info if requested</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( sEnv.DYLD_PRINT_STATISTICS )</span><br><span class=\"line\">\t\tImageLoader::printStatistics((<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)allImagesCount(), initializerTimes[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( sEnv.DYLD_PRINT_STATISTICS_DETAILS )</span><br><span class=\"line\">\t\tImageLoaderMachO::printStatisticsDetails((<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)allImagesCount(), initializerTimes[<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析：</p>\n<ol>\n<li>初始化所有已经插入的动态库</li>\n<li>初始化主程序</li>\n</ol>\n<h4 id=\"5-processInitializers源码\"><a href=\"#5-processInitializers源码\" class=\"headerlink\" title=\"5. processInitializers源码\"></a>5. <code>processInitializers</code>源码</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ImageLoader::processInitializers</span><span class=\"params\">(<span class=\"keyword\">const</span> LinkContext&amp; context, <span class=\"keyword\">mach_port_t</span> thisThread,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t\t\t\t InitializerTimingList&amp; timingInfo, ImageLoader::UninitedUpwards&amp; images)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> maxImageCount = context.imageCount()+<span class=\"number\">2</span>;</span><br><span class=\"line\">\tImageLoader::UninitedUpwards upsBuffer[maxImageCount];</span><br><span class=\"line\">\tImageLoader::UninitedUpwards&amp; ups = upsBuffer[<span class=\"number\">0</span>];</span><br><span class=\"line\">\tups.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// Calling recursive init on all images in images list, building a new list of</span></span><br><span class=\"line\">\t<span class=\"comment\">// uninitialized upward dependencies.</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">uintptr_t</span> i=<span class=\"number\">0</span>; i &lt; images.count; ++i) &#123;</span><br><span class=\"line\">\t\timages.imagesAndPaths[i].first-&gt;recursiveInitialization(context, thisThread, images.imagesAndPaths[i].second, timingInfo, ups);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// If any upward dependencies remain, init them.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( ups.count &gt; <span class=\"number\">0</span> )</span><br><span class=\"line\">\t\tprocessInitializers(context, thisThread, timingInfo, ups);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析：</p>\n<ol>\n<li>初始化所有images，调用<code>recursiveInitialization</code>递归其依赖的镜像进行初始化，直至全部初始化完成</li>\n</ol>\n<h4 id=\"6-recursiveInitialization源码\"><a href=\"#6-recursiveInitialization源码\" class=\"headerlink\" title=\"6. recursiveInitialization源码\"></a>6. <code>recursiveInitialization</code>源码</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ImageLoader::recursiveInitialization</span><span class=\"params\">(<span class=\"keyword\">const</span> LinkContext&amp; context, <span class=\"keyword\">mach_port_t</span> this_thread, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* pathToInitialize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t\t\t\t\t  InitializerTimingList&amp; timingInfo, UninitedUpwards&amp; uninitUps)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\"> </span><br><span class=\"line\"> \t...省略部分代码</span><br><span class=\"line\"> \t</span><br><span class=\"line\">\t<span class=\"comment\">// initialize lower level libraries first</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i &lt; libraryCount(); ++i) &#123;</span><br><span class=\"line\">\t\tImageLoader* dependentImage = libImage(i);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( dependentImage != <span class=\"literal\">NULL</span> ) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// don&#x27;t try to initialize stuff &quot;above&quot; me yet</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ( libIsUpward(i) ) &#123;</span><br><span class=\"line\">\t\t\t\tuninitUps.imagesAndPaths[uninitUps.count] = &#123; dependentImage, libPath(i) &#125;;</span><br><span class=\"line\">\t\t\t\tuninitUps.count++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( dependentImage-&gt;fDepth &gt;= fDepth ) &#123;</span><br><span class=\"line\">\t\t\t\tdependentImage-&gt;recursiveInitialization(context, this_thread, libPath(i), timingInfo, uninitUps);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// let objc know we are about to initialize this image</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint64_t</span> t1 = mach_absolute_time();</span><br><span class=\"line\">\tfState = dyld_image_state_dependents_initialized;</span><br><span class=\"line\">\toldState = fState;</span><br><span class=\"line\">\tcontext.notifySingle(dyld_image_state_dependents_initialized, <span class=\"keyword\">this</span>, &amp;timingInfo);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// initialize this image</span></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> hasInitializers = <span class=\"keyword\">this</span>-&gt;doInitialization(context);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// let anyone know we finished initializing this image</span></span><br><span class=\"line\">\tfState = dyld_image_state_initialized;</span><br><span class=\"line\">\toldState = fState;</span><br><span class=\"line\">\tcontext.notifySingle(dyld_image_state_initialized, <span class=\"keyword\">this</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析：</p>\n<ol>\n<li>首先保证初始化级别较低，被依赖的镜像</li>\n<li><code>notifySingle</code>通知objc初始化该镜像</li>\n<li><code>doInitialization</code>初始化该镜像</li>\n<li><code>notifySingle</code>通知objc初始化该镜像完毕</li>\n</ol>\n<h4 id=\"7-notifySingle流程\"><a href=\"#7-notifySingle流程\" class=\"headerlink\" title=\"7.notifySingle流程\"></a>7.<code>notifySingle</code>流程</h4><ol>\n<li>看上去<code>notifySingle</code>应该是类似发了个通知的</li>\n<li>在源码中可以看到调用了<code>(*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader());</code>函数</li>\n<li><code>sNotifyObjCInit</code>是在<code>registerObjCNotifiers</code>函数中赋值的第二个参数</li>\n<li><code>registerObjCNotifiers</code>是在<code>_dyld_objc_notify_register</code>函数中调用的</li>\n<li><code>_dyld_objc_notify_register</code>看着比较眼熟，实在<code>libobjc</code>源码中<code>_objc_init</code>函数中调用的</li>\n<li>那<code>_objc_init</code>是在何时调用的呢？</li>\n</ol>\n<p>通过在<code>_objc_init</code>添加符号断点，查看堆栈如下</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">0</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>dd<span class=\"number\">9</span>cb<span class=\"number\">6</span>b libobjc.A.dylib`_objc_init</span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">1</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>f<span class=\"number\">7</span>c<span class=\"number\">2789</span> libdispatch.dylib`_os_object_init + <span class=\"number\">13</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">2</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>f<span class=\"number\">7</span>d<span class=\"number\">12</span>e<span class=\"number\">3</span> libdispatch.dylib`libdispatch_init + <span class=\"number\">300</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">3</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>ddd<span class=\"number\">785</span>f libSystem.B.dylib`libSystem_initializer + <span class=\"number\">252</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">4</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>d<span class=\"number\">4</span>f<span class=\"number\">26</span>d<span class=\"number\">9</span> dyld_sim`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext const&amp;) + <span class=\"number\">513</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">5</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>d<span class=\"number\">4</span>f<span class=\"number\">2</span>ace dyld_sim`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext const&amp;) + <span class=\"number\">40</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">6</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>d<span class=\"number\">4</span>ed<span class=\"number\">868</span> dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class=\"number\">456</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">7</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>d<span class=\"number\">4</span>ed<span class=\"number\">7</span>d<span class=\"number\">5</span> dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class=\"number\">309</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">8</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>d<span class=\"number\">4</span>ebd<span class=\"number\">2</span>c dyld_sim`ImageLoader::processInitializers(ImageLoader::LinkContext const&amp;, unsigned int, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class=\"number\">188</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">9</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>d<span class=\"number\">4</span>ebdcc dyld_sim`ImageLoader::runInitializers(ImageLoader::LinkContext const&amp;, ImageLoader::InitializerTimingList&amp;) + <span class=\"number\">82</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">10</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>d<span class=\"number\">4</span>e<span class=\"number\">022</span>a dyld_sim`dyld::initializeMainExecutable() + <span class=\"number\">129</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">11</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>d<span class=\"number\">4</span>e<span class=\"number\">41</span>bb dyld_sim`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + <span class=\"number\">3662</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">12</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>d<span class=\"number\">4</span>df<span class=\"number\">1</span>cd dyld_sim`start_sim + <span class=\"number\">122</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">13</span>: <span class=\"number\">0</span>x<span class=\"number\">0000000111</span>d<span class=\"number\">1379</span>a dyld`dyld::useSimulatorDyld(int, macho_header const*, char const*, int, char const**, char const**, char const**, unsigned long*, unsigned long*) + <span class=\"number\">2308</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">14</span>: <span class=\"number\">0</span>x<span class=\"number\">0000000111</span>d<span class=\"number\">11432</span> dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + <span class=\"number\">837</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">15</span>: <span class=\"number\">0</span>x<span class=\"number\">0000000111</span>d<span class=\"number\">0</span>c<span class=\"number\">227</span> dyld`dyldbootstrap::start(dyld<span class=\"number\">3</span>::MachOLoaded const*, int, char const**, dyld<span class=\"number\">3</span>::MachOLoaded const*, unsigned long*) + <span class=\"number\">453</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">16</span>: <span class=\"number\">0</span>x<span class=\"number\">0000000111</span>d<span class=\"number\">0</span>c<span class=\"number\">025</span> dyld`_dyld_start + <span class=\"number\">37</span></span><br></pre></td></tr></table></figure>\n<p>发现<code>doModInitFunctions</code> -&gt; <code>libSystem_initializer</code> -&gt; <code>libdispatch_init</code> -&gt; <code>_os_object_init</code> -&gt; <code>_objc_init</code></p>\n<h4 id=\"8-doInitialization源码\"><a href=\"#8-doInitialization源码\" class=\"headerlink\" title=\"8. doInitialization源码\"></a>8. <code>doInitialization</code>源码</h4><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">bool</span> ImageLoaderMachO::<span class=\"keyword\">do</span><span class=\"constructor\">Initialization(<span class=\"params\">const</span> LinkContext&amp; <span class=\"params\">context</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"constructor\">CRSetCrashLogMessage2(<span class=\"params\">this</span>-&gt;<span class=\"params\">getPath</span>()</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// mach-o has -init and static initializers</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span><span class=\"constructor\">ImageInit(<span class=\"params\">context</span>)</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">do</span><span class=\"constructor\">ModInitFunctions(<span class=\"params\">context</span>)</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"constructor\">CRSetCrashLogMessage2(NULL)</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\treturn (fHasDashInit<span class=\"operator\"> || </span>fHasInitializers);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>doInitialization</code>中初始化镜像以及静态C++的构造函数，注意：在<code>doInitialization</code>之前需要首先确保<code>libSystem</code>已经初始化。</p>\n<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><p><code>dyld-&gt;objc</code> 流程</p>\n<p><code>_dyld_start</code> -&gt; `` -&gt; <code>dyldbootstrap::start</code> -&gt; <code>dyld::_main</code> -&gt; <code>dyld::initializeMainExecutable</code> -&gt; <code>ImageLoader::runInitializers</code> -&gt; <code>ImageLoader::processInitializers</code> -&gt; <code>ImageLoader::recursiveInitialization</code> -&gt; <code>doInitialization</code> -&gt; <code>libSystem_initializer</code> -&gt; <code>libdispatch_init</code> -&gt; <code>_os_object_init</code> -&gt;  <code>_objc_init</code>  -&gt; <code>_dyld_objc_notify_register</code><br>在<code>doInitialization</code>调用完成之后，调用 <code>_dyld_objc_notify_register</code>函数注册的<code>load_images</code>函数，至此由runtime接管app运行。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-ebb30dca022ea4fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"dyld-&gt;objc流程.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"1-dyld-start入口函数\"><a href=\"#1-dyld-start入口函数\" class=\"headerlink\" title=\"1. _dyld_start入口函数\"></a>1. <code>_dyld_start</code>入口函数</h4><p>在一个类的<code>+ (void)load</code>函数上打断点，查看此时的堆栈信息如下：</p>\n<figure class=\"highlight zephir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* thread #<span class=\"number\">1</span>, queue = <span class=\"string\">&#x27;com.apple.main-thread&#x27;</span>, stop reason = breakpoint <span class=\"number\">2.1</span></span><br><span class=\"line\">  * frame #<span class=\"number\">0</span>: <span class=\"number\">0x000000010d168ee7</span> test`+[ViewController load](<span class=\"keyword\">self</span>=ViewController, _cmd=<span class=\"string\">&quot;load&quot;</span>) at ViewController.m:<span class=\"number\">20</span>:<span class=\"number\">5</span></span><br><span class=\"line\">    frame #<span class=\"number\">1</span>: <span class=\"number\">0x00007fff512a9477</span> libobjc.A.dylib`load_images + <span class=\"number\">1386</span></span><br><span class=\"line\">    frame #<span class=\"number\">2</span>: <span class=\"number\">0x000000010d177e34</span> dyld_sim`dyld::notifySingle(dyld_image_states, ImageLoader <span class=\"keyword\">const</span>*, ImageLoader::InitializerTimingList*) + <span class=\"number\">418</span></span><br><span class=\"line\">    frame #<span class=\"number\">3</span>: <span class=\"number\">0x000000010d185856</span> dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext <span class=\"keyword\">const</span>&amp;, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class=\"number\">438</span></span><br><span class=\"line\">    frame #<span class=\"number\">4</span>: <span class=\"number\">0x000000010d183d2c</span> dyld_sim`ImageLoader::processInitializers(ImageLoader::LinkContext <span class=\"keyword\">const</span>&amp;, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class=\"number\">188</span></span><br><span class=\"line\">    frame #<span class=\"number\">5</span>: <span class=\"number\">0x000000010d183dcc</span> dyld_sim`ImageLoader::runInitializers(ImageLoader::LinkContext <span class=\"keyword\">const</span>&amp;, ImageLoader::InitializerTimingList&amp;) + <span class=\"number\">82</span></span><br><span class=\"line\">    frame #<span class=\"number\">6</span>: <span class=\"number\">0x000000010d178270</span> dyld_sim`dyld::initializeMainExecutable() + <span class=\"number\">199</span></span><br><span class=\"line\">    frame #<span class=\"number\">7</span>: <span class=\"number\">0x000000010d17c1bb</span> dyld_sim`dyld::_main(macho_header <span class=\"keyword\">const</span>*, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>, <span class=\"keyword\">int</span>, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>**, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>**, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>**, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>*) + <span class=\"number\">3662</span></span><br><span class=\"line\">    frame #<span class=\"number\">8</span>: <span class=\"number\">0x000000010d1771cd</span> dyld_sim`start_sim + <span class=\"number\">122</span></span><br><span class=\"line\">    frame #<span class=\"number\">9</span>: <span class=\"number\">0x00000001174ff85c</span> dyld`dyld::useSimulatorDyld(<span class=\"keyword\">int</span>, macho_header <span class=\"keyword\">const</span>*, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>*, <span class=\"keyword\">int</span>, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>**, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>**, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>**, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>*, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>*) + <span class=\"number\">2308</span></span><br><span class=\"line\">    frame #<span class=\"number\">10</span>: <span class=\"number\">0x00000001174fd4f4</span> dyld`dyld::_main(macho_header <span class=\"keyword\">const</span>*, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>, <span class=\"keyword\">int</span>, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>**, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>**, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>**, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>*) + <span class=\"number\">837</span></span><br><span class=\"line\">    frame #<span class=\"number\">11</span>: <span class=\"number\">0x00000001174f8227</span> dyld`dyldbootstrap::start(dyld3::MachOLoaded <span class=\"keyword\">const</span>*, <span class=\"keyword\">int</span>, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>**, dyld3::MachOLoaded <span class=\"keyword\">const</span>*, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>*) + <span class=\"number\">453</span></span><br><span class=\"line\">    frame #<span class=\"number\">12</span>: <span class=\"number\">0x00000001174f8025</span> dyld`_dyld_start + <span class=\"number\">37</span></span><br></pre></td></tr></table></figure>\n<p>可以看到栈底信息是从<code>dyld</code>源码中的<code>_dyld_start</code>函数开始的，查看<code>dyld</code>源码可知该函数在<code>dyldStartup.s</code>的汇编文件中，通过查看汇编或以上栈信息可以得知下一个调用函数为<code>dyldbootstrap::start</code>。</p>\n<h4 id=\"2-dyldbootstrap-start源码分析\"><a href=\"#2-dyldbootstrap-start源码分析\" class=\"headerlink\" title=\"2. dyldbootstrap::start源码分析\"></a>2. <code>dyldbootstrap::start</code>源码分析</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">uintptr_t</span> <span class=\"title\">start</span><span class=\"params\">(<span class=\"keyword\">const</span> dyld3::MachOLoaded* appsMachHeader, <span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* argv[],</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t<span class=\"keyword\">const</span> dyld3::MachOLoaded* dyldsMachHeader, <span class=\"keyword\">uintptr_t</span>* startGlue)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Emit kdebug tracepoint to indicate dyld bootstrap has started &lt;rdar://46878536&gt;</span></span><br><span class=\"line\">    dyld3::kdebug_trace_dyld_marker(DBG_DYLD_TIMING_BOOTSTRAP_START, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// if kernel had to slide dyld, we need to fix up load sensitive locations</span></span><br><span class=\"line\">\t<span class=\"comment\">// we have to do this before using any global variables</span></span><br><span class=\"line\">    rebaseDyld(dyldsMachHeader);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// kernel sets up env pointer to be just past end of agv array</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>** envp = &amp;argv[argc+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// kernel sets up apple pointer to be just past end of envp array</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>** apple = envp;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(*apple != <span class=\"literal\">NULL</span>) &#123; ++apple; &#125;</span><br><span class=\"line\">\t++apple;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// set up random value for stack canary</span></span><br><span class=\"line\">\t__guard_setup(apple);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> DYLD_INITIALIZER_SUPPORT</span></span><br><span class=\"line\">\t<span class=\"comment\">// run all C++ initializers inside dyld</span></span><br><span class=\"line\">\trunDyldInitializers(argc, argv, envp, apple);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// now that we are done bootstrapping dyld, call dyld&#x27;s main</span></span><br><span class=\"line\">\t<span class=\"keyword\">uintptr_t</span> appsSlide = appsMachHeader-&gt;getSlide();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dyld::_main((macho_header*)appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析： </p>\n<ol>\n<li><code>rebaseDyld</code>在使用全局变量前修复dyld的地址偏移，同时会初始化进程和系统层</li>\n<li>设置环境变量</li>\n<li>现在的版本不需要初始化dyld了</li>\n<li>获取地址偏移量，调用<code>dyld::_main</code></li>\n</ol>\n<h4 id=\"3-dyld-main源码分析\"><a href=\"#3-dyld-main源码分析\" class=\"headerlink\" title=\"3. dyld::_main源码分析\"></a>3. <code>dyld::_main</code>源码分析</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">uintptr_t</span></span><br><span class=\"line\">_main(<span class=\"keyword\">const</span> macho_header* mainExecutableMH, <span class=\"keyword\">uintptr_t</span> mainExecutableSlide, </span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* argv[], <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* envp[], <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* apple[], </span><br><span class=\"line\">\t\t<span class=\"keyword\">uintptr_t</span>* startGlue)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">//加载共享缓存</span></span><br><span class=\"line\">mapSharedCache();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//加载可执行文件并实例化</span></span><br><span class=\"line\"><span class=\"comment\">// instantiate ImageLoader for main executable</span></span><br><span class=\"line\">sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//遍历加载插入的动态库</span></span><br><span class=\"line\"><span class=\"comment\">// load any inserted libraries</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>\t( sEnv.DYLD_INSERT_LIBRARIES != <span class=\"literal\">NULL</span> ) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class=\"literal\">NULL</span>; ++lib) </span><br><span class=\"line\">\t\tloadInsertedDylib(*lib);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//链接主程序</span></span><br><span class=\"line\">link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, <span class=\"literal\">true</span>, ImageLoader::RPathChain(<span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>), <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在链接主程序之后，遍历链接已经插入的动态库</span></span><br><span class=\"line\"><span class=\"comment\">// link any inserted libraries</span></span><br><span class=\"line\"><span class=\"comment\">// do this after linking main executable so that any dylibs pulled in by inserted </span></span><br><span class=\"line\"><span class=\"comment\">// dylibs (e.g. libSystem) will not be in front of dylibs the program uses</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ( sInsertedDylibCount &gt; <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class=\"line\">\t\tImageLoader* <span class=\"built_in\">image</span> = sAllImages[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\tlink(<span class=\"built_in\">image</span>, sEnv.DYLD_BIND_AT_LAUNCH, <span class=\"literal\">true</span>, ImageLoader::RPathChain(<span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>), <span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">image</span>-&gt;setNeverUnloadRecursive();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( gLinkContext.allowInterposing ) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// only INSERTED libraries can interpose</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// register interposing info after all inserted libraries are bound so chaining works</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class=\"line\">\t\t\tImageLoader* <span class=\"built_in\">image</span> = sAllImages[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">image</span>-&gt;registerInterposing(gLinkContext);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化主程序</span></span><br><span class=\"line\">initializeMainExecutable();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通知监听程序调用main()函数 notify any montoring proccesses that this process is about to enter main() </span></span><br><span class=\"line\">notifyMonitoringDyldMain();</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析：<code>dyld::_main</code>主要做了以下几件事情：</p>\n<ol>\n<li><code>mapSharedCache</code> 加载共享缓存</li>\n<li><code>instantiateFromLoadedImage</code> 加载可执行文件并实例化</li>\n<li><code>loadInsertedDylib</code> 遍历加载插入的动态库</li>\n<li><code>link</code> 链接主程序</li>\n<li>在链接主程序之后，遍历链接已经插入的动态库</li>\n<li><code>initializeMainExecutable</code> 初始化主程序</li>\n<li><code>notifyMonitoringDyldMain</code> 通知监听程序调用main()函数  </li>\n</ol>\n<p>此时main函数之前的流程已经走完了，下面说下<code>dyld</code>如何和<code>objc</code>关联起来的。</p>\n<hr>\n<p>在上述初始化主程序<code>initializeMainExecutable</code>函数中，<code>initializeMainExecutable</code> -&gt; <code>runInitializers</code> -&gt; <code>processInitializers</code></p>\n<h4 id=\"4-initializeMainExecutable源码\"><a href=\"#4-initializeMainExecutable源码\" class=\"headerlink\" title=\"4.initializeMainExecutable源码\"></a>4.<code>initializeMainExecutable</code>源码</h4><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initializeMainExecutable</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// record that we&#x27;ve reached this step</span></span><br><span class=\"line\">\tgLinkContext.startedInitializingMainExecutable = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// run initialzers for any inserted dylibs</span></span><br><span class=\"line\">\tImageLoader::InitializerTimingList initializerTimes[allImagesCount()];</span><br><span class=\"line\">\tinitializerTimes[<span class=\"number\">0</span>].count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">size_t</span> rootCount = sImageRoots.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( rootCount &gt; <span class=\"number\">1</span> ) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">size_t</span> i=<span class=\"number\">1</span>; i &lt; rootCount; ++i) &#123;</span><br><span class=\"line\">\t\t\tsImageRoots[i]-&gt;runInitializers(gLinkContext, initializerTimes[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// run initializers for main executable and everything it brings up </span></span><br><span class=\"line\">\tsMainExecutable-&gt;runInitializers(gLinkContext, initializerTimes[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( gLibSystemHelpers != <span class=\"literal\">NULL</span> ) </span><br><span class=\"line\">\t\t(*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// dump info if requested</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( sEnv.DYLD_PRINT_STATISTICS )</span><br><span class=\"line\">\t\tImageLoader::printStatistics((<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)allImagesCount(), initializerTimes[<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( sEnv.DYLD_PRINT_STATISTICS_DETAILS )</span><br><span class=\"line\">\t\tImageLoaderMachO::printStatisticsDetails((<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span>)allImagesCount(), initializerTimes[<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析：</p>\n<ol>\n<li>初始化所有已经插入的动态库</li>\n<li>初始化主程序</li>\n</ol>\n<h4 id=\"5-processInitializers源码\"><a href=\"#5-processInitializers源码\" class=\"headerlink\" title=\"5. processInitializers源码\"></a>5. <code>processInitializers</code>源码</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ImageLoader::processInitializers</span><span class=\"params\">(<span class=\"keyword\">const</span> LinkContext&amp; context, <span class=\"keyword\">mach_port_t</span> thisThread,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t\t\t\t InitializerTimingList&amp; timingInfo, ImageLoader::UninitedUpwards&amp; images)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> maxImageCount = context.imageCount()+<span class=\"number\">2</span>;</span><br><span class=\"line\">\tImageLoader::UninitedUpwards upsBuffer[maxImageCount];</span><br><span class=\"line\">\tImageLoader::UninitedUpwards&amp; ups = upsBuffer[<span class=\"number\">0</span>];</span><br><span class=\"line\">\tups.count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// Calling recursive init on all images in images list, building a new list of</span></span><br><span class=\"line\">\t<span class=\"comment\">// uninitialized upward dependencies.</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">uintptr_t</span> i=<span class=\"number\">0</span>; i &lt; images.count; ++i) &#123;</span><br><span class=\"line\">\t\timages.imagesAndPaths[i].first-&gt;recursiveInitialization(context, thisThread, images.imagesAndPaths[i].second, timingInfo, ups);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// If any upward dependencies remain, init them.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( ups.count &gt; <span class=\"number\">0</span> )</span><br><span class=\"line\">\t\tprocessInitializers(context, thisThread, timingInfo, ups);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析：</p>\n<ol>\n<li>初始化所有images，调用<code>recursiveInitialization</code>递归其依赖的镜像进行初始化，直至全部初始化完成</li>\n</ol>\n<h4 id=\"6-recursiveInitialization源码\"><a href=\"#6-recursiveInitialization源码\" class=\"headerlink\" title=\"6. recursiveInitialization源码\"></a>6. <code>recursiveInitialization</code>源码</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ImageLoader::recursiveInitialization</span><span class=\"params\">(<span class=\"keyword\">const</span> LinkContext&amp; context, <span class=\"keyword\">mach_port_t</span> this_thread, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* pathToInitialize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t\t\t\t\t  InitializerTimingList&amp; timingInfo, UninitedUpwards&amp; uninitUps)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\"> </span><br><span class=\"line\"> \t...省略部分代码</span><br><span class=\"line\"> \t</span><br><span class=\"line\">\t<span class=\"comment\">// initialize lower level libraries first</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i &lt; libraryCount(); ++i) &#123;</span><br><span class=\"line\">\t\tImageLoader* dependentImage = libImage(i);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( dependentImage != <span class=\"literal\">NULL</span> ) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// don&#x27;t try to initialize stuff &quot;above&quot; me yet</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ( libIsUpward(i) ) &#123;</span><br><span class=\"line\">\t\t\t\tuninitUps.imagesAndPaths[uninitUps.count] = &#123; dependentImage, libPath(i) &#125;;</span><br><span class=\"line\">\t\t\t\tuninitUps.count++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( dependentImage-&gt;fDepth &gt;= fDepth ) &#123;</span><br><span class=\"line\">\t\t\t\tdependentImage-&gt;recursiveInitialization(context, this_thread, libPath(i), timingInfo, uninitUps);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// let objc know we are about to initialize this image</span></span><br><span class=\"line\">\t<span class=\"keyword\">uint64_t</span> t1 = mach_absolute_time();</span><br><span class=\"line\">\tfState = dyld_image_state_dependents_initialized;</span><br><span class=\"line\">\toldState = fState;</span><br><span class=\"line\">\tcontext.notifySingle(dyld_image_state_dependents_initialized, <span class=\"keyword\">this</span>, &amp;timingInfo);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// initialize this image</span></span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> hasInitializers = <span class=\"keyword\">this</span>-&gt;doInitialization(context);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// let anyone know we finished initializing this image</span></span><br><span class=\"line\">\tfState = dyld_image_state_initialized;</span><br><span class=\"line\">\toldState = fState;</span><br><span class=\"line\">\tcontext.notifySingle(dyld_image_state_initialized, <span class=\"keyword\">this</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析：</p>\n<ol>\n<li>首先保证初始化级别较低，被依赖的镜像</li>\n<li><code>notifySingle</code>通知objc初始化该镜像</li>\n<li><code>doInitialization</code>初始化该镜像</li>\n<li><code>notifySingle</code>通知objc初始化该镜像完毕</li>\n</ol>\n<h4 id=\"7-notifySingle流程\"><a href=\"#7-notifySingle流程\" class=\"headerlink\" title=\"7.notifySingle流程\"></a>7.<code>notifySingle</code>流程</h4><ol>\n<li>看上去<code>notifySingle</code>应该是类似发了个通知的</li>\n<li>在源码中可以看到调用了<code>(*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader());</code>函数</li>\n<li><code>sNotifyObjCInit</code>是在<code>registerObjCNotifiers</code>函数中赋值的第二个参数</li>\n<li><code>registerObjCNotifiers</code>是在<code>_dyld_objc_notify_register</code>函数中调用的</li>\n<li><code>_dyld_objc_notify_register</code>看着比较眼熟，实在<code>libobjc</code>源码中<code>_objc_init</code>函数中调用的</li>\n<li>那<code>_objc_init</code>是在何时调用的呢？</li>\n</ol>\n<p>通过在<code>_objc_init</code>添加符号断点，查看堆栈如下</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">0</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>dd<span class=\"number\">9</span>cb<span class=\"number\">6</span>b libobjc.A.dylib`_objc_init</span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">1</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>f<span class=\"number\">7</span>c<span class=\"number\">2789</span> libdispatch.dylib`_os_object_init + <span class=\"number\">13</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">2</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>f<span class=\"number\">7</span>d<span class=\"number\">12</span>e<span class=\"number\">3</span> libdispatch.dylib`libdispatch_init + <span class=\"number\">300</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">3</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>ddd<span class=\"number\">785</span>f libSystem.B.dylib`libSystem_initializer + <span class=\"number\">252</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">4</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>d<span class=\"number\">4</span>f<span class=\"number\">26</span>d<span class=\"number\">9</span> dyld_sim`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext const&amp;) + <span class=\"number\">513</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">5</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>d<span class=\"number\">4</span>f<span class=\"number\">2</span>ace dyld_sim`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext const&amp;) + <span class=\"number\">40</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">6</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>d<span class=\"number\">4</span>ed<span class=\"number\">868</span> dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class=\"number\">456</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">7</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>d<span class=\"number\">4</span>ed<span class=\"number\">7</span>d<span class=\"number\">5</span> dyld_sim`ImageLoader::recursiveInitialization(ImageLoader::LinkContext const&amp;, unsigned int, char const*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class=\"number\">309</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">8</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>d<span class=\"number\">4</span>ebd<span class=\"number\">2</span>c dyld_sim`ImageLoader::processInitializers(ImageLoader::LinkContext const&amp;, unsigned int, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class=\"number\">188</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">9</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>d<span class=\"number\">4</span>ebdcc dyld_sim`ImageLoader::runInitializers(ImageLoader::LinkContext const&amp;, ImageLoader::InitializerTimingList&amp;) + <span class=\"number\">82</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">10</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>d<span class=\"number\">4</span>e<span class=\"number\">022</span>a dyld_sim`dyld::initializeMainExecutable() + <span class=\"number\">129</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">11</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>d<span class=\"number\">4</span>e<span class=\"number\">41</span>bb dyld_sim`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + <span class=\"number\">3662</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">12</span>: <span class=\"number\">0</span>x<span class=\"number\">000000010</span>d<span class=\"number\">4</span>df<span class=\"number\">1</span>cd dyld_sim`start_sim + <span class=\"number\">122</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">13</span>: <span class=\"number\">0</span>x<span class=\"number\">0000000111</span>d<span class=\"number\">1379</span>a dyld`dyld::useSimulatorDyld(int, macho_header const*, char const*, int, char const**, char const**, char const**, unsigned long*, unsigned long*) + <span class=\"number\">2308</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">14</span>: <span class=\"number\">0</span>x<span class=\"number\">0000000111</span>d<span class=\"number\">11432</span> dyld`dyld::_main(macho_header const*, unsigned long, int, char const**, char const**, char const**, unsigned long*) + <span class=\"number\">837</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">15</span>: <span class=\"number\">0</span>x<span class=\"number\">0000000111</span>d<span class=\"number\">0</span>c<span class=\"number\">227</span> dyld`dyldbootstrap::start(dyld<span class=\"number\">3</span>::MachOLoaded const*, int, char const**, dyld<span class=\"number\">3</span>::MachOLoaded const*, unsigned long*) + <span class=\"number\">453</span></span><br><span class=\"line\"><span class=\"attribute\">frame</span> #<span class=\"number\">16</span>: <span class=\"number\">0</span>x<span class=\"number\">0000000111</span>d<span class=\"number\">0</span>c<span class=\"number\">025</span> dyld`_dyld_start + <span class=\"number\">37</span></span><br></pre></td></tr></table></figure>\n<p>发现<code>doModInitFunctions</code> -&gt; <code>libSystem_initializer</code> -&gt; <code>libdispatch_init</code> -&gt; <code>_os_object_init</code> -&gt; <code>_objc_init</code></p>\n<h4 id=\"8-doInitialization源码\"><a href=\"#8-doInitialization源码\" class=\"headerlink\" title=\"8. doInitialization源码\"></a>8. <code>doInitialization</code>源码</h4><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">bool</span> ImageLoaderMachO::<span class=\"keyword\">do</span><span class=\"constructor\">Initialization(<span class=\"params\">const</span> LinkContext&amp; <span class=\"params\">context</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"constructor\">CRSetCrashLogMessage2(<span class=\"params\">this</span>-&gt;<span class=\"params\">getPath</span>()</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// mach-o has -init and static initializers</span></span><br><span class=\"line\">\t<span class=\"keyword\">do</span><span class=\"constructor\">ImageInit(<span class=\"params\">context</span>)</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">do</span><span class=\"constructor\">ModInitFunctions(<span class=\"params\">context</span>)</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"constructor\">CRSetCrashLogMessage2(NULL)</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\treturn (fHasDashInit<span class=\"operator\"> || </span>fHasInitializers);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>doInitialization</code>中初始化镜像以及静态C++的构造函数，注意：在<code>doInitialization</code>之前需要首先确保<code>libSystem</code>已经初始化。</p>\n<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><p><code>dyld-&gt;objc</code> 流程</p>\n<p><code>_dyld_start</code> -&gt; `` -&gt; <code>dyldbootstrap::start</code> -&gt; <code>dyld::_main</code> -&gt; <code>dyld::initializeMainExecutable</code> -&gt; <code>ImageLoader::runInitializers</code> -&gt; <code>ImageLoader::processInitializers</code> -&gt; <code>ImageLoader::recursiveInitialization</code> -&gt; <code>doInitialization</code> -&gt; <code>libSystem_initializer</code> -&gt; <code>libdispatch_init</code> -&gt; <code>_os_object_init</code> -&gt;  <code>_objc_init</code>  -&gt; <code>_dyld_objc_notify_register</code><br>在<code>doInitialization</code>调用完成之后，调用 <code>_dyld_objc_notify_register</code>函数注册的<code>load_images</code>函数，至此由runtime接管app运行。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1395687-ebb30dca022ea4fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"dyld-&gt;objc流程.png\"></p>\n"},{"title":"Objective-C Dispatch Direct","date":"2021-06-24T16:00:00.000Z","_content":"\n## Objective-C Dispatch Direct\n\n### Method 通过给Clang 传递 objc_direct\n\n```\n@interface Tool : NSObject\n- (void)printMySelf;\n@end\n\n    0x100a60825 <+85>:  movq   %rax, -0x28(%rbp)\n->  0x100a60829 <+89>:  movq   -0x28(%rbp), %rax\n    0x100a6082d <+93>:  movq   0x7fec(%rip), %rsi        ; \"printMySelf\"\n    0x100a60834 <+100>: movq   %rax, %rdi\n    0x100a60837 <+103>: callq  *0x27d3(%rip)             ; (void *)0x00007fff20175280: objc_msgSend\n```\n\n上述代码 调用时，根据汇编显示callq 调用objc_msgSend发送“printMySelf”的消息\n\n\n\n```\n@interface Tool : NSObject\n- (void)printMySelf __attribute__((objc_direct));\n@end\n\n    0x10270c835 <+85>:  movq   %rax, -0x28(%rbp)\n->  0x10270c839 <+89>:  movq   -0x28(%rbp), %rax\n    0x10270c83d <+93>:  movq   %rax, %rdi\n    0x10270c840 <+96>:  callq  0x10270c2f0               ; -[Tool printMySelf] at Tool.m:33\n    0x10270c845 <+101>: xorl   %r8d, %r8d\n    0x10270c848 <+104>: movl   %r8d, %esi\n    \n    \n /**\n 打印类的实例方法\n */\nvoid printAllInstanceMethod(Class cls) {\n    unsigned int count;\n    Method *methods = class_copyMethodList(cls, &count);\n    NSMutableArray *mutableA = [NSMutableArray arrayWithCapacity:10];\n    for (int i = 0; i < count; i++) {\n        NSString *methodName = NSStringFromSelector(method_getName(methods[i]));\n        [mutableA addObject:methodName];\n    }\n    for (NSString *methodName in mutableA) {\n        NSLog(@\"%@ has Method - %@\", cls, methodName);\n    }\n}\n```\n\n1. 上述代码 给函数通过给Clang传递**objc_direct**属性调用时，汇编显示callq 直接调用函数\n2. 此时通过 `Method originMethod = class_getInstanceMethod([self class], @selector(printMySelf));`  获取该方法的Method时，会报如下错误 @selector expression formed with direct selector 'printMySelf' ，证明此时该方法不能被常见的runtime进行方法交换\n3. 通过NSSelectorFromString 反射获取的SEL 为 0x0\n4. 所以通过performSelector 调用方式会报 找不到方法的错误\n5. 通过runtime获取类的方法，并获取不到被direct修饰的方法，应该在编译器确定了调用地址，直接调用\n6. 一个direct method，不能被子类重写，会报如下错误 Cannot override a method that is declared direct by a superclass，同时在direct method中调用super也会报错\n7. 协议中不能声明属性和方法为 direct，会报以下错误 'objc_direct' attribute cannot be applied to properties declared in an Objective-C protocol\n\n### Property 通过 **direct**进行修饰\n\n```\n@interface Tool : NSObject\n@property (nonatomic, strong) NSString *name;\n@end\n```\n\n我们都知道平时声明属性时，编译器会帮助我们生成_name成员变量、setter、getter方法\n\n\n\n```\n@interface Tool : NSObject\n@property (nonatomic, strong, direct) NSString *name;\n@end\n\n/**\n 打印实例对象的成员变量\n */\nvoid printAllIvars(NSObject *obj) {\n    unsigned int count;\n    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n    Ivar *list = class_copyIvarList([obj class], &count);\n    for (int i = 0; i < count; i++) {\n        NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(list[i])];\n        id ivarValue = [obj valueForKey:ivarName];\n        if (ivarValue) {\n            dict[ivarName] = ivarValue;\n        }else{\n            dict[ivarName] = @\"\";\n        }\n    }\n    for (NSString *ivarName in dict.allKeys) {\n        NSLog(@\"ivarName:%@,ivarValue:%@\",ivarName,dict[ivarName]);\n    }\n}\n```\n\n通过查看汇编，对应的setter 和 getter方法都是直接调用，不再走objc_msgSend流程；通过runtime获取成员变量列表，仍然有对应的_name成员变量\n\n```\nt.name= @\"zhangsan\";\n[t addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew context:nil];\nt.name = @\"lisi\";\n```\n\n由于没有setter方法，故kvo时，并没有任何回调\n\n现在属性修饰词有以下16个\n\n```\n setter getter\n readwrite readonly\n strong weak copy assign unsafe_unretained\n nullable nonnull null_resettable\n atomic nonatomic\n class direct\n```\n\n\n\n### `objc_direct_members` 修饰\n\n```\n__attribute__((objc_direct_members))\n@interface Tool()\n\n@end\n```\n\n在接口处添加修饰，没有任何作用\n\n\n\n```\n__attribute__((objc_direct_members))\n@implementation Tool\n```\n\n在实现处添加修饰，则之前未声明的成员为直接成员，以及之前未声明的方法也会被直接调用\n\n\n\n>  直接派发的效率和C语言调用一样，但是Objective-C的objc_msgSend在汇编和缓存层面做了很大的优化，调用效率相差并不会很大。\n>\n> 禁止通过runtime动态调用，作为私有实现。\n>\n> 最大的影响应该是在包体积方面的减少，主要是在SDK这方面。主要原因是因为方法不会放在method list中\n>\n> 如果OC的方法直接派发，仍然想要被外部可见，可以包装在C函数中\n\n学习自：\n\n[Objective-C Direct Methods](https://nshipster.com/direct/)\n\nhttps://clang.llvm.org/docs/AttributeReference.html#objc-direct\n\n","source":"_posts/2021-06-24-Objective-C Dispatch Direct.md","raw":"---\ntitle:      \"Objective-C Dispatch Direct\" \ndate:       2021-06-25\ntags:\n    - iOS\ncategories:\n    - iOS\n---\n\n## Objective-C Dispatch Direct\n\n### Method 通过给Clang 传递 objc_direct\n\n```\n@interface Tool : NSObject\n- (void)printMySelf;\n@end\n\n    0x100a60825 <+85>:  movq   %rax, -0x28(%rbp)\n->  0x100a60829 <+89>:  movq   -0x28(%rbp), %rax\n    0x100a6082d <+93>:  movq   0x7fec(%rip), %rsi        ; \"printMySelf\"\n    0x100a60834 <+100>: movq   %rax, %rdi\n    0x100a60837 <+103>: callq  *0x27d3(%rip)             ; (void *)0x00007fff20175280: objc_msgSend\n```\n\n上述代码 调用时，根据汇编显示callq 调用objc_msgSend发送“printMySelf”的消息\n\n\n\n```\n@interface Tool : NSObject\n- (void)printMySelf __attribute__((objc_direct));\n@end\n\n    0x10270c835 <+85>:  movq   %rax, -0x28(%rbp)\n->  0x10270c839 <+89>:  movq   -0x28(%rbp), %rax\n    0x10270c83d <+93>:  movq   %rax, %rdi\n    0x10270c840 <+96>:  callq  0x10270c2f0               ; -[Tool printMySelf] at Tool.m:33\n    0x10270c845 <+101>: xorl   %r8d, %r8d\n    0x10270c848 <+104>: movl   %r8d, %esi\n    \n    \n /**\n 打印类的实例方法\n */\nvoid printAllInstanceMethod(Class cls) {\n    unsigned int count;\n    Method *methods = class_copyMethodList(cls, &count);\n    NSMutableArray *mutableA = [NSMutableArray arrayWithCapacity:10];\n    for (int i = 0; i < count; i++) {\n        NSString *methodName = NSStringFromSelector(method_getName(methods[i]));\n        [mutableA addObject:methodName];\n    }\n    for (NSString *methodName in mutableA) {\n        NSLog(@\"%@ has Method - %@\", cls, methodName);\n    }\n}\n```\n\n1. 上述代码 给函数通过给Clang传递**objc_direct**属性调用时，汇编显示callq 直接调用函数\n2. 此时通过 `Method originMethod = class_getInstanceMethod([self class], @selector(printMySelf));`  获取该方法的Method时，会报如下错误 @selector expression formed with direct selector 'printMySelf' ，证明此时该方法不能被常见的runtime进行方法交换\n3. 通过NSSelectorFromString 反射获取的SEL 为 0x0\n4. 所以通过performSelector 调用方式会报 找不到方法的错误\n5. 通过runtime获取类的方法，并获取不到被direct修饰的方法，应该在编译器确定了调用地址，直接调用\n6. 一个direct method，不能被子类重写，会报如下错误 Cannot override a method that is declared direct by a superclass，同时在direct method中调用super也会报错\n7. 协议中不能声明属性和方法为 direct，会报以下错误 'objc_direct' attribute cannot be applied to properties declared in an Objective-C protocol\n\n### Property 通过 **direct**进行修饰\n\n```\n@interface Tool : NSObject\n@property (nonatomic, strong) NSString *name;\n@end\n```\n\n我们都知道平时声明属性时，编译器会帮助我们生成_name成员变量、setter、getter方法\n\n\n\n```\n@interface Tool : NSObject\n@property (nonatomic, strong, direct) NSString *name;\n@end\n\n/**\n 打印实例对象的成员变量\n */\nvoid printAllIvars(NSObject *obj) {\n    unsigned int count;\n    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n    Ivar *list = class_copyIvarList([obj class], &count);\n    for (int i = 0; i < count; i++) {\n        NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(list[i])];\n        id ivarValue = [obj valueForKey:ivarName];\n        if (ivarValue) {\n            dict[ivarName] = ivarValue;\n        }else{\n            dict[ivarName] = @\"\";\n        }\n    }\n    for (NSString *ivarName in dict.allKeys) {\n        NSLog(@\"ivarName:%@,ivarValue:%@\",ivarName,dict[ivarName]);\n    }\n}\n```\n\n通过查看汇编，对应的setter 和 getter方法都是直接调用，不再走objc_msgSend流程；通过runtime获取成员变量列表，仍然有对应的_name成员变量\n\n```\nt.name= @\"zhangsan\";\n[t addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew context:nil];\nt.name = @\"lisi\";\n```\n\n由于没有setter方法，故kvo时，并没有任何回调\n\n现在属性修饰词有以下16个\n\n```\n setter getter\n readwrite readonly\n strong weak copy assign unsafe_unretained\n nullable nonnull null_resettable\n atomic nonatomic\n class direct\n```\n\n\n\n### `objc_direct_members` 修饰\n\n```\n__attribute__((objc_direct_members))\n@interface Tool()\n\n@end\n```\n\n在接口处添加修饰，没有任何作用\n\n\n\n```\n__attribute__((objc_direct_members))\n@implementation Tool\n```\n\n在实现处添加修饰，则之前未声明的成员为直接成员，以及之前未声明的方法也会被直接调用\n\n\n\n>  直接派发的效率和C语言调用一样，但是Objective-C的objc_msgSend在汇编和缓存层面做了很大的优化，调用效率相差并不会很大。\n>\n> 禁止通过runtime动态调用，作为私有实现。\n>\n> 最大的影响应该是在包体积方面的减少，主要是在SDK这方面。主要原因是因为方法不会放在method list中\n>\n> 如果OC的方法直接派发，仍然想要被外部可见，可以包装在C函数中\n\n学习自：\n\n[Objective-C Direct Methods](https://nshipster.com/direct/)\n\nhttps://clang.llvm.org/docs/AttributeReference.html#objc-direct\n\n","slug":"2021-06-24-Objective-C Dispatch Direct","published":1,"updated":"2021-06-25T01:47:37.264Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqboczt300002crjes33cjl8","content":"<h2 id=\"Objective-C-Dispatch-Direct\"><a href=\"#Objective-C-Dispatch-Direct\" class=\"headerlink\" title=\"Objective-C Dispatch Direct\"></a>Objective-C Dispatch Direct</h2><h3 id=\"Method-通过给Clang-传递-objc-direct\"><a href=\"#Method-通过给Clang-传递-objc-direct\" class=\"headerlink\" title=\"Method 通过给Clang 传递 objc_direct\"></a>Method 通过给Clang 传递 objc_direct</h3><pre><code>@interface Tool : NSObject\n- (void)printMySelf;\n@end\n\n    0x100a60825 &lt;+85&gt;:  movq   %rax, -0x28(%rbp)\n-&gt;  0x100a60829 &lt;+89&gt;:  movq   -0x28(%rbp), %rax\n    0x100a6082d &lt;+93&gt;:  movq   0x7fec(%rip), %rsi        ; &quot;printMySelf&quot;\n    0x100a60834 &lt;+100&gt;: movq   %rax, %rdi\n    0x100a60837 &lt;+103&gt;: callq  *0x27d3(%rip)             ; (void *)0x00007fff20175280: objc_msgSend\n</code></pre>\n<p>上述代码 调用时，根据汇编显示callq 调用objc_msgSend发送“printMySelf”的消息</p>\n<pre><code>@interface Tool : NSObject\n- (void)printMySelf __attribute__((objc_direct));\n@end\n\n    0x10270c835 &lt;+85&gt;:  movq   %rax, -0x28(%rbp)\n-&gt;  0x10270c839 &lt;+89&gt;:  movq   -0x28(%rbp), %rax\n    0x10270c83d &lt;+93&gt;:  movq   %rax, %rdi\n    0x10270c840 &lt;+96&gt;:  callq  0x10270c2f0               ; -[Tool printMySelf] at Tool.m:33\n    0x10270c845 &lt;+101&gt;: xorl   %r8d, %r8d\n    0x10270c848 &lt;+104&gt;: movl   %r8d, %esi\n    \n    \n /**\n 打印类的实例方法\n */\nvoid printAllInstanceMethod(Class cls) &#123;\n    unsigned int count;\n    Method *methods = class_copyMethodList(cls, &amp;count);\n    NSMutableArray *mutableA = [NSMutableArray arrayWithCapacity:10];\n    for (int i = 0; i &lt; count; i++) &#123;\n        NSString *methodName = NSStringFromSelector(method_getName(methods[i]));\n        [mutableA addObject:methodName];\n    &#125;\n    for (NSString *methodName in mutableA) &#123;\n        NSLog(@&quot;%@ has Method - %@&quot;, cls, methodName);\n    &#125;\n&#125;\n</code></pre>\n<ol>\n<li>上述代码 给函数通过给Clang传递<strong>objc_direct</strong>属性调用时，汇编显示callq 直接调用函数</li>\n<li>此时通过 <code>Method originMethod = class_getInstanceMethod([self class], @selector(printMySelf));</code>  获取该方法的Method时，会报如下错误 @selector expression formed with direct selector ‘printMySelf’ ，证明此时该方法不能被常见的runtime进行方法交换</li>\n<li>通过NSSelectorFromString 反射获取的SEL 为 0x0</li>\n<li>所以通过performSelector 调用方式会报 找不到方法的错误</li>\n<li>通过runtime获取类的方法，并获取不到被direct修饰的方法，应该在编译器确定了调用地址，直接调用</li>\n<li>一个direct method，不能被子类重写，会报如下错误 Cannot override a method that is declared direct by a superclass，同时在direct method中调用super也会报错</li>\n<li>协议中不能声明属性和方法为 direct，会报以下错误 ‘objc_direct’ attribute cannot be applied to properties declared in an Objective-C protocol</li>\n</ol>\n<h3 id=\"Property-通过-direct进行修饰\"><a href=\"#Property-通过-direct进行修饰\" class=\"headerlink\" title=\"Property 通过 direct进行修饰\"></a>Property 通过 <strong>direct</strong>进行修饰</h3><pre><code>@interface Tool : NSObject\n@property (nonatomic, strong) NSString *name;\n@end\n</code></pre>\n<p>我们都知道平时声明属性时，编译器会帮助我们生成_name成员变量、setter、getter方法</p>\n<pre><code>@interface Tool : NSObject\n@property (nonatomic, strong, direct) NSString *name;\n@end\n\n/**\n 打印实例对象的成员变量\n */\nvoid printAllIvars(NSObject *obj) &#123;\n    unsigned int count;\n    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n    Ivar *list = class_copyIvarList([obj class], &amp;count);\n    for (int i = 0; i &lt; count; i++) &#123;\n        NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(list[i])];\n        id ivarValue = [obj valueForKey:ivarName];\n        if (ivarValue) &#123;\n            dict[ivarName] = ivarValue;\n        &#125;else&#123;\n            dict[ivarName] = @&quot;&quot;;\n        &#125;\n    &#125;\n    for (NSString *ivarName in dict.allKeys) &#123;\n        NSLog(@&quot;ivarName:%@,ivarValue:%@&quot;,ivarName,dict[ivarName]);\n    &#125;\n&#125;\n</code></pre>\n<p>通过查看汇编，对应的setter 和 getter方法都是直接调用，不再走objc_msgSend流程；通过runtime获取成员变量列表，仍然有对应的_name成员变量</p>\n<pre><code>t.name= @&quot;zhangsan&quot;;\n[t addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil];\nt.name = @&quot;lisi&quot;;\n</code></pre>\n<p>由于没有setter方法，故kvo时，并没有任何回调</p>\n<p>现在属性修饰词有以下16个</p>\n<pre><code> setter getter\n readwrite readonly\n strong weak copy assign unsafe_unretained\n nullable nonnull null_resettable\n atomic nonatomic\n class direct\n</code></pre>\n<h3 id=\"objc-direct-members-修饰\"><a href=\"#objc-direct-members-修饰\" class=\"headerlink\" title=\"objc_direct_members 修饰\"></a><code>objc_direct_members</code> 修饰</h3><pre><code>__attribute__((objc_direct_members))\n@interface Tool()\n\n@end\n</code></pre>\n<p>在接口处添加修饰，没有任何作用</p>\n<pre><code>__attribute__((objc_direct_members))\n@implementation Tool\n</code></pre>\n<p>在实现处添加修饰，则之前未声明的成员为直接成员，以及之前未声明的方法也会被直接调用</p>\n<blockquote>\n<p> 直接派发的效率和C语言调用一样，但是Objective-C的objc_msgSend在汇编和缓存层面做了很大的优化，调用效率相差并不会很大。</p>\n<p>禁止通过runtime动态调用，作为私有实现。</p>\n<p>最大的影响应该是在包体积方面的减少，主要是在SDK这方面。主要原因是因为方法不会放在method list中</p>\n<p>如果OC的方法直接派发，仍然想要被外部可见，可以包装在C函数中</p>\n</blockquote>\n<p>学习自：</p>\n<p><a href=\"https://nshipster.com/direct/\">Objective-C Direct Methods</a></p>\n<p><a href=\"https://clang.llvm.org/docs/AttributeReference.html#objc-direct\">https://clang.llvm.org/docs/AttributeReference.html#objc-direct</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Objective-C-Dispatch-Direct\"><a href=\"#Objective-C-Dispatch-Direct\" class=\"headerlink\" title=\"Objective-C Dispatch Direct\"></a>Objective-C Dispatch Direct</h2><h3 id=\"Method-通过给Clang-传递-objc-direct\"><a href=\"#Method-通过给Clang-传递-objc-direct\" class=\"headerlink\" title=\"Method 通过给Clang 传递 objc_direct\"></a>Method 通过给Clang 传递 objc_direct</h3><pre><code>@interface Tool : NSObject\n- (void)printMySelf;\n@end\n\n    0x100a60825 &lt;+85&gt;:  movq   %rax, -0x28(%rbp)\n-&gt;  0x100a60829 &lt;+89&gt;:  movq   -0x28(%rbp), %rax\n    0x100a6082d &lt;+93&gt;:  movq   0x7fec(%rip), %rsi        ; &quot;printMySelf&quot;\n    0x100a60834 &lt;+100&gt;: movq   %rax, %rdi\n    0x100a60837 &lt;+103&gt;: callq  *0x27d3(%rip)             ; (void *)0x00007fff20175280: objc_msgSend\n</code></pre>\n<p>上述代码 调用时，根据汇编显示callq 调用objc_msgSend发送“printMySelf”的消息</p>\n<pre><code>@interface Tool : NSObject\n- (void)printMySelf __attribute__((objc_direct));\n@end\n\n    0x10270c835 &lt;+85&gt;:  movq   %rax, -0x28(%rbp)\n-&gt;  0x10270c839 &lt;+89&gt;:  movq   -0x28(%rbp), %rax\n    0x10270c83d &lt;+93&gt;:  movq   %rax, %rdi\n    0x10270c840 &lt;+96&gt;:  callq  0x10270c2f0               ; -[Tool printMySelf] at Tool.m:33\n    0x10270c845 &lt;+101&gt;: xorl   %r8d, %r8d\n    0x10270c848 &lt;+104&gt;: movl   %r8d, %esi\n    \n    \n /**\n 打印类的实例方法\n */\nvoid printAllInstanceMethod(Class cls) &#123;\n    unsigned int count;\n    Method *methods = class_copyMethodList(cls, &amp;count);\n    NSMutableArray *mutableA = [NSMutableArray arrayWithCapacity:10];\n    for (int i = 0; i &lt; count; i++) &#123;\n        NSString *methodName = NSStringFromSelector(method_getName(methods[i]));\n        [mutableA addObject:methodName];\n    &#125;\n    for (NSString *methodName in mutableA) &#123;\n        NSLog(@&quot;%@ has Method - %@&quot;, cls, methodName);\n    &#125;\n&#125;\n</code></pre>\n<ol>\n<li>上述代码 给函数通过给Clang传递<strong>objc_direct</strong>属性调用时，汇编显示callq 直接调用函数</li>\n<li>此时通过 <code>Method originMethod = class_getInstanceMethod([self class], @selector(printMySelf));</code>  获取该方法的Method时，会报如下错误 @selector expression formed with direct selector ‘printMySelf’ ，证明此时该方法不能被常见的runtime进行方法交换</li>\n<li>通过NSSelectorFromString 反射获取的SEL 为 0x0</li>\n<li>所以通过performSelector 调用方式会报 找不到方法的错误</li>\n<li>通过runtime获取类的方法，并获取不到被direct修饰的方法，应该在编译器确定了调用地址，直接调用</li>\n<li>一个direct method，不能被子类重写，会报如下错误 Cannot override a method that is declared direct by a superclass，同时在direct method中调用super也会报错</li>\n<li>协议中不能声明属性和方法为 direct，会报以下错误 ‘objc_direct’ attribute cannot be applied to properties declared in an Objective-C protocol</li>\n</ol>\n<h3 id=\"Property-通过-direct进行修饰\"><a href=\"#Property-通过-direct进行修饰\" class=\"headerlink\" title=\"Property 通过 direct进行修饰\"></a>Property 通过 <strong>direct</strong>进行修饰</h3><pre><code>@interface Tool : NSObject\n@property (nonatomic, strong) NSString *name;\n@end\n</code></pre>\n<p>我们都知道平时声明属性时，编译器会帮助我们生成_name成员变量、setter、getter方法</p>\n<pre><code>@interface Tool : NSObject\n@property (nonatomic, strong, direct) NSString *name;\n@end\n\n/**\n 打印实例对象的成员变量\n */\nvoid printAllIvars(NSObject *obj) &#123;\n    unsigned int count;\n    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n    Ivar *list = class_copyIvarList([obj class], &amp;count);\n    for (int i = 0; i &lt; count; i++) &#123;\n        NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(list[i])];\n        id ivarValue = [obj valueForKey:ivarName];\n        if (ivarValue) &#123;\n            dict[ivarName] = ivarValue;\n        &#125;else&#123;\n            dict[ivarName] = @&quot;&quot;;\n        &#125;\n    &#125;\n    for (NSString *ivarName in dict.allKeys) &#123;\n        NSLog(@&quot;ivarName:%@,ivarValue:%@&quot;,ivarName,dict[ivarName]);\n    &#125;\n&#125;\n</code></pre>\n<p>通过查看汇编，对应的setter 和 getter方法都是直接调用，不再走objc_msgSend流程；通过runtime获取成员变量列表，仍然有对应的_name成员变量</p>\n<pre><code>t.name= @&quot;zhangsan&quot;;\n[t addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil];\nt.name = @&quot;lisi&quot;;\n</code></pre>\n<p>由于没有setter方法，故kvo时，并没有任何回调</p>\n<p>现在属性修饰词有以下16个</p>\n<pre><code> setter getter\n readwrite readonly\n strong weak copy assign unsafe_unretained\n nullable nonnull null_resettable\n atomic nonatomic\n class direct\n</code></pre>\n<h3 id=\"objc-direct-members-修饰\"><a href=\"#objc-direct-members-修饰\" class=\"headerlink\" title=\"objc_direct_members 修饰\"></a><code>objc_direct_members</code> 修饰</h3><pre><code>__attribute__((objc_direct_members))\n@interface Tool()\n\n@end\n</code></pre>\n<p>在接口处添加修饰，没有任何作用</p>\n<pre><code>__attribute__((objc_direct_members))\n@implementation Tool\n</code></pre>\n<p>在实现处添加修饰，则之前未声明的成员为直接成员，以及之前未声明的方法也会被直接调用</p>\n<blockquote>\n<p> 直接派发的效率和C语言调用一样，但是Objective-C的objc_msgSend在汇编和缓存层面做了很大的优化，调用效率相差并不会很大。</p>\n<p>禁止通过runtime动态调用，作为私有实现。</p>\n<p>最大的影响应该是在包体积方面的减少，主要是在SDK这方面。主要原因是因为方法不会放在method list中</p>\n<p>如果OC的方法直接派发，仍然想要被外部可见，可以包装在C函数中</p>\n</blockquote>\n<p>学习自：</p>\n<p><a href=\"https://nshipster.com/direct/\">Objective-C Direct Methods</a></p>\n<p><a href=\"https://clang.llvm.org/docs/AttributeReference.html#objc-direct\">https://clang.llvm.org/docs/AttributeReference.html#objc-direct</a></p>\n"},{"title":"HashMap分析","date":"2021-07-06T16:00:00.000Z","_content":"\n#### 学习HashMap源码\n\n##### Hash\n\n1. Hash函数\n\n   1. Hash函数是一种摘要算法，具有不可逆性\n   2. 常见的Hash算法有MD5，SHA256，SHA512\n\n2. Hash表\n\n   1. 是一种根据key，快速访问内存上数据的数据结构\n\n3. Hash冲突，如以下代码一样\n\n   ``` \n   15 & (10 - 1) = 9\n   13 & (10 - 1) = 9\n   ```\n\n##### Dictionary <key: value>\n\n1. 实现方式：数组 + 链表\n   1. 数组：查找O(1)，插入/删除O(n)\n   2. 链表：查找O(n)，插入/删除O(1)\n\n2. 伪代码\n\n   1.  \n```\n      数据结构\n      Class Node {\t//链表结构\n      \thash,\t\t\t//key的hash值\n      \tkey,\n      \tvalue,\n      \tNode *next\n      };\n      \n      Class Table {\t//数组结构\n      \tNodes<Node>,\t\t//存放Node的数组\n      \tCapacity,\t\t\t\t//存放元素的个数\n      \tLength,\t\t\t\t\t//数组的大小 default 1<<4 = 16\n      \tFactory,\t\t\t\t//扩容因子 defalut 0.75\n      }\n      ```\n\n   2. 数组的index计算方式\n\n      1. Node.hash & (Table.Length - 1)\n\n         > Table.Length 初始值为16，之后扩容方式为2的N次幂，这样(Table.Length - 1)为奇数，最后一位为1，和key的hash进行位运算之后，可能为奇数，可能为偶数，减少空间浪费。如果(Table.Length - 1)为偶数，则最后一位是0，与任何值进行hash与的运算均为偶数。\n\n   3. 根据key 获取value\n\n      1. ```\n         Node getNode(key) {\n         \tint hash = hash(key);\n         \tint n; \n         \tNode first;\n         \tif (table != null && (n = table.Nodes.Length) > 0 && (first = table.Nodes[hash & (n - 1)]) != null) {\n         \t\tif (first.hash == hash && first.key == key) {\n         \t\t\treturn first;\n         \t\t}\n         \t\twhile (first.next != null) {\n         \t\t\tNode tempNode = first.next;\n         \t\t\tif (tempNode.hash == hash && tempNode.key == key) {\n         \t\t\t\treturn tempNode;\n         \t\t\t}\n         \t\t\tfirst = first.next;\n         \t\t}\n         \t}\n         \treturn null;\n         }\n         ```\n\n         首先判断数组不为空，数组长度大于0，根据hash算出第一个Node所在的index，取出对应的Node\n\n         然后先判断第一个节点是否匹配，我理解的是因为hash冲突概率低，一般取出第一个即可命中，不需要进入循环\n\n         之后如果不匹配，则遍历链表\n\n   4.  存储key-value\n\n      1. 在Android中，当冲突中的链表长度大于8时，则将链表转化为红黑树\n      2. 使用红黑树的原因是查找效率更高\n      3. 个数小于8时，不使用红黑树，是为了节省内存\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2021-07-07 HashMap分析.md","raw":"---\ntitle:      \"HashMap分析\" \ndate:       2021-07-07\ntags:\n    - iOS\ncategories:\n    - iOS\n---\n\n#### 学习HashMap源码\n\n##### Hash\n\n1. Hash函数\n\n   1. Hash函数是一种摘要算法，具有不可逆性\n   2. 常见的Hash算法有MD5，SHA256，SHA512\n\n2. Hash表\n\n   1. 是一种根据key，快速访问内存上数据的数据结构\n\n3. Hash冲突，如以下代码一样\n\n   ``` \n   15 & (10 - 1) = 9\n   13 & (10 - 1) = 9\n   ```\n\n##### Dictionary <key: value>\n\n1. 实现方式：数组 + 链表\n   1. 数组：查找O(1)，插入/删除O(n)\n   2. 链表：查找O(n)，插入/删除O(1)\n\n2. 伪代码\n\n   1.  \n```\n      数据结构\n      Class Node {\t//链表结构\n      \thash,\t\t\t//key的hash值\n      \tkey,\n      \tvalue,\n      \tNode *next\n      };\n      \n      Class Table {\t//数组结构\n      \tNodes<Node>,\t\t//存放Node的数组\n      \tCapacity,\t\t\t\t//存放元素的个数\n      \tLength,\t\t\t\t\t//数组的大小 default 1<<4 = 16\n      \tFactory,\t\t\t\t//扩容因子 defalut 0.75\n      }\n      ```\n\n   2. 数组的index计算方式\n\n      1. Node.hash & (Table.Length - 1)\n\n         > Table.Length 初始值为16，之后扩容方式为2的N次幂，这样(Table.Length - 1)为奇数，最后一位为1，和key的hash进行位运算之后，可能为奇数，可能为偶数，减少空间浪费。如果(Table.Length - 1)为偶数，则最后一位是0，与任何值进行hash与的运算均为偶数。\n\n   3. 根据key 获取value\n\n      1. ```\n         Node getNode(key) {\n         \tint hash = hash(key);\n         \tint n; \n         \tNode first;\n         \tif (table != null && (n = table.Nodes.Length) > 0 && (first = table.Nodes[hash & (n - 1)]) != null) {\n         \t\tif (first.hash == hash && first.key == key) {\n         \t\t\treturn first;\n         \t\t}\n         \t\twhile (first.next != null) {\n         \t\t\tNode tempNode = first.next;\n         \t\t\tif (tempNode.hash == hash && tempNode.key == key) {\n         \t\t\t\treturn tempNode;\n         \t\t\t}\n         \t\t\tfirst = first.next;\n         \t\t}\n         \t}\n         \treturn null;\n         }\n         ```\n\n         首先判断数组不为空，数组长度大于0，根据hash算出第一个Node所在的index，取出对应的Node\n\n         然后先判断第一个节点是否匹配，我理解的是因为hash冲突概率低，一般取出第一个即可命中，不需要进入循环\n\n         之后如果不匹配，则遍历链表\n\n   4.  存储key-value\n\n      1. 在Android中，当冲突中的链表长度大于8时，则将链表转化为红黑树\n      2. 使用红黑树的原因是查找效率更高\n      3. 个数小于8时，不使用红黑树，是为了节省内存\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"2021-07-07 HashMap分析","published":1,"updated":"2021-07-07T12:24:31.259Z","_id":"ckqtgbka40000f1rj7xhc2khd","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"学习HashMap源码\"><a href=\"#学习HashMap源码\" class=\"headerlink\" title=\"学习HashMap源码\"></a>学习HashMap源码</h4><h5 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h5><ol>\n<li><p>Hash函数</p>\n<ol>\n<li>Hash函数是一种摘要算法，具有不可逆性</li>\n<li>常见的Hash算法有MD5，SHA256，SHA512</li>\n</ol>\n</li>\n<li><p>Hash表</p>\n<ol>\n<li>是一种根据key，快速访问内存上数据的数据结构</li>\n</ol>\n</li>\n<li><p>Hash冲突，如以下代码一样</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">15 </span>&amp; (<span class=\"number\">10</span> - <span class=\"number\">1</span>) = <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"symbol\">13 </span>&amp; (<span class=\"number\">10</span> - <span class=\"number\">1</span>) = <span class=\"number\">9</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h5 id=\"Dictionary-lt-key-value-gt\"><a href=\"#Dictionary-lt-key-value-gt\" class=\"headerlink\" title=\"Dictionary &lt;key: value&gt;\"></a>Dictionary &lt;key: value&gt;</h5><ol>\n<li><p>实现方式：数组 + 链表</p>\n<ol>\n<li>数组：查找O(1)，插入/删除O(n)</li>\n<li>链表：查找O(n)，插入/删除O(1)</li>\n</ol>\n</li>\n<li><p>伪代码</p>\n<ol>\n<li><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数据结构</span><br><span class=\"line\">Class Node &#123;\t<span class=\"regexp\">//</span>链表结构</span><br><span class=\"line\">\thash,\t\t\t<span class=\"regexp\">//</span>key的hash值</span><br><span class=\"line\">\tkey,</span><br><span class=\"line\">\tvalue,</span><br><span class=\"line\">\tNode *<span class=\"keyword\">next</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Class Table &#123;\t<span class=\"regexp\">//</span>数组结构</span><br><span class=\"line\">\tNodes&lt;Node&gt;,\t\t<span class=\"regexp\">//</span>存放Node的数组</span><br><span class=\"line\">\tCapacity,\t\t\t\t<span class=\"regexp\">//</span>存放元素的个数</span><br><span class=\"line\">\tLength,\t\t\t\t\t<span class=\"regexp\">//</span>数组的大小 default <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">4</span> = <span class=\"number\">16</span></span><br><span class=\"line\">\tFactory,\t\t\t\t<span class=\"regexp\">//</span>扩容因子 defalut <span class=\"number\">0.75</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>数组的index计算方式</p>\n<ol>\n<li><p>Node.hash &amp; (Table.Length - 1)</p>\n<blockquote>\n<p>Table.Length 初始值为16，之后扩容方式为2的N次幂，这样(Table.Length - 1)为奇数，最后一位为1，和key的hash进行位运算之后，可能为奇数，可能为偶数，减少空间浪费。如果(Table.Length - 1)为偶数，则最后一位是0，与任何值进行hash与的运算均为偶数。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>根据key 获取value</p>\n<ol>\n<li><pre><code>Node getNode(key) &#123;\n    int hash = hash(key);\n    int n; \n    Node first;\n    if (table != null &amp;&amp; (n = table.Nodes.Length) &gt; 0 &amp;&amp; (first = table.Nodes[hash &amp; (n - 1)]) != null) &#123;\n        if (first.hash == hash &amp;&amp; first.key == key) &#123;\n            return first;\n        &#125;\n        while (first.next != null) &#123;\n            Node tempNode = first.next;\n            if (tempNode.hash == hash &amp;&amp; tempNode.key == key) &#123;\n                return tempNode;\n            &#125;\n            first = first.next;\n        &#125;\n    &#125;\n    return null;\n&#125;\n</code></pre>\n<p>首先判断数组不为空，数组长度大于0，根据hash算出第一个Node所在的index，取出对应的Node</p>\n<p>然后先判断第一个节点是否匹配，我理解的是因为hash冲突概率低，一般取出第一个即可命中，不需要进入循环</p>\n<p>之后如果不匹配，则遍历链表</p>\n</li>\n</ol>\n</li>\n<li><p> 存储key-value</p>\n</li>\n<li><p>在Android中，当冲突中的链表长度大于8时，则将链表转化为红黑树</p>\n</li>\n<li><p>使用红黑树的原因是查找效率更高</p>\n</li>\n<li><p>个数小于8时，不使用红黑树，是为了节省内存</p>\n</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"学习HashMap源码\"><a href=\"#学习HashMap源码\" class=\"headerlink\" title=\"学习HashMap源码\"></a>学习HashMap源码</h4><h5 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h5><ol>\n<li><p>Hash函数</p>\n<ol>\n<li>Hash函数是一种摘要算法，具有不可逆性</li>\n<li>常见的Hash算法有MD5，SHA256，SHA512</li>\n</ol>\n</li>\n<li><p>Hash表</p>\n<ol>\n<li>是一种根据key，快速访问内存上数据的数据结构</li>\n</ol>\n</li>\n<li><p>Hash冲突，如以下代码一样</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">15 </span>&amp; (<span class=\"number\">10</span> - <span class=\"number\">1</span>) = <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"symbol\">13 </span>&amp; (<span class=\"number\">10</span> - <span class=\"number\">1</span>) = <span class=\"number\">9</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h5 id=\"Dictionary-lt-key-value-gt\"><a href=\"#Dictionary-lt-key-value-gt\" class=\"headerlink\" title=\"Dictionary &lt;key: value&gt;\"></a>Dictionary &lt;key: value&gt;</h5><ol>\n<li><p>实现方式：数组 + 链表</p>\n<ol>\n<li>数组：查找O(1)，插入/删除O(n)</li>\n<li>链表：查找O(n)，插入/删除O(1)</li>\n</ol>\n</li>\n<li><p>伪代码</p>\n<ol>\n<li><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数据结构</span><br><span class=\"line\">Class Node &#123;\t<span class=\"regexp\">//</span>链表结构</span><br><span class=\"line\">\thash,\t\t\t<span class=\"regexp\">//</span>key的hash值</span><br><span class=\"line\">\tkey,</span><br><span class=\"line\">\tvalue,</span><br><span class=\"line\">\tNode *<span class=\"keyword\">next</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Class Table &#123;\t<span class=\"regexp\">//</span>数组结构</span><br><span class=\"line\">\tNodes&lt;Node&gt;,\t\t<span class=\"regexp\">//</span>存放Node的数组</span><br><span class=\"line\">\tCapacity,\t\t\t\t<span class=\"regexp\">//</span>存放元素的个数</span><br><span class=\"line\">\tLength,\t\t\t\t\t<span class=\"regexp\">//</span>数组的大小 default <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">4</span> = <span class=\"number\">16</span></span><br><span class=\"line\">\tFactory,\t\t\t\t<span class=\"regexp\">//</span>扩容因子 defalut <span class=\"number\">0.75</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>数组的index计算方式</p>\n<ol>\n<li><p>Node.hash &amp; (Table.Length - 1)</p>\n<blockquote>\n<p>Table.Length 初始值为16，之后扩容方式为2的N次幂，这样(Table.Length - 1)为奇数，最后一位为1，和key的hash进行位运算之后，可能为奇数，可能为偶数，减少空间浪费。如果(Table.Length - 1)为偶数，则最后一位是0，与任何值进行hash与的运算均为偶数。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p>根据key 获取value</p>\n<ol>\n<li><pre><code>Node getNode(key) &#123;\n    int hash = hash(key);\n    int n; \n    Node first;\n    if (table != null &amp;&amp; (n = table.Nodes.Length) &gt; 0 &amp;&amp; (first = table.Nodes[hash &amp; (n - 1)]) != null) &#123;\n        if (first.hash == hash &amp;&amp; first.key == key) &#123;\n            return first;\n        &#125;\n        while (first.next != null) &#123;\n            Node tempNode = first.next;\n            if (tempNode.hash == hash &amp;&amp; tempNode.key == key) &#123;\n                return tempNode;\n            &#125;\n            first = first.next;\n        &#125;\n    &#125;\n    return null;\n&#125;\n</code></pre>\n<p>首先判断数组不为空，数组长度大于0，根据hash算出第一个Node所在的index，取出对应的Node</p>\n<p>然后先判断第一个节点是否匹配，我理解的是因为hash冲突概率低，一般取出第一个即可命中，不需要进入循环</p>\n<p>之后如果不匹配，则遍历链表</p>\n</li>\n</ol>\n</li>\n<li><p> 存储key-value</p>\n</li>\n<li><p>在Android中，当冲突中的链表长度大于8时，则将链表转化为红黑树</p>\n</li>\n<li><p>使用红黑树的原因是查找效率更高</p>\n</li>\n<li><p>个数小于8时，不使用红黑树，是为了节省内存</p>\n</li>\n</ol>\n</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckq3hjboz0000bjrj4zc53a4m","category_id":"ckq3hjbp60002bjrjgbpl7yar","_id":"ckq3hjbpd000cbjrj7s8m736j"},{"post_id":"ckq3hjbpb000abjrj3t6cahtl","category_id":"ckq3hjbpa0007bjrj4bcobo5x","_id":"ckq3hjbpg000jbjrj4yo76jll"},{"post_id":"ckq3hjbp40001bjrjfl1bhipo","category_id":"ckq3hjbpa0007bjrj4bcobo5x","_id":"ckq3hjbpi000objrj9513gmsi"},{"post_id":"ckq3hjbpc000bbjrjchna0fo9","category_id":"ckq3hjbpa0007bjrj4bcobo5x","_id":"ckq3hjbpj000rbjrj2e54ehar"},{"post_id":"ckq3hjbp70004bjrj2zdr9bi5","category_id":"ckq3hjbpd000dbjrjdq4f7yyd","_id":"ckq3hjbpl000wbjrjfj378zyl"},{"post_id":"ckq3hjbpf000ibjrj2e6g7m7w","category_id":"ckq3hjbpa0007bjrj4bcobo5x","_id":"ckq3hjbpm000zbjrjadunh02u"},{"post_id":"ckq3hjbp90005bjrj3cxz3icx","category_id":"ckq3hjbpg000kbjrj0ywpb3sq","_id":"ckq3hjbpn0011bjrj19yadrk7"},{"post_id":"ckq3hjbp90006bjrj8ax394lv","category_id":"ckq3hjbpj000tbjrja4dt4ow3","_id":"ckq3hjbpq0019bjrj8ts84aig"},{"post_id":"ckq3hjbpm0010bjrj0s3q9bw9","category_id":"ckq3hjbpj000tbjrja4dt4ow3","_id":"ckq3hjbpt001dbjrj2z7o12kv"},{"post_id":"ckq3hjbpe000gbjrjemz5hd90","category_id":"ckq3hjbpj000tbjrja4dt4ow3","_id":"ckq3hjbpu001gbjrj40jchu40"},{"post_id":"ckq3hjbph000nbjrjh0k310wf","category_id":"ckq3hjbpj000tbjrja4dt4ow3","_id":"ckq3hjbpw001mbjrj4a85e6wu"},{"post_id":"ckq3hjbpi000qbjrj00ove4hs","category_id":"ckq3hjbpj000tbjrja4dt4ow3","_id":"ckq3hjbpz001sbjrj3urxakg8"},{"post_id":"ckq3hjbpk000vbjrjfgy57mmq","category_id":"ckq3hjbpj000tbjrja4dt4ow3","_id":"ckq3hjbq1001xbjrje5zkg0wg"},{"post_id":"ckq3hjbpl000ybjrj1kzq04c2","category_id":"ckq3hjbpa0007bjrj4bcobo5x","_id":"ckq3hjbq30023bjrj4hsa0ynl"},{"post_id":"ckq3hjbpl000ybjrj1kzq04c2","category_id":"ckq3hjbpz001rbjrj90pphxbx","_id":"ckq3hjbq30026bjrj1hdf0ggj"},{"post_id":"ckq3hjbpo0015bjrj2rmj3rcz","category_id":"ckq3hjbq1001ybjrjejcb2pvs","_id":"ckq3hjbq40029bjrj3gxn6zpt"},{"post_id":"ckq3hjbpr001cbjrjhjy22qbh","category_id":"ckq3hjbq1001ybjrjejcb2pvs","_id":"ckq3hjbq5002ebjrjd9qr93z2"},{"post_id":"ckq3hjbpu001ebjrj3hxu9lrt","category_id":"ckq3hjbq4002bbjrj4kii6hrs","_id":"ckq3hjbq6002kbjrjdwb16z4a"},{"post_id":"ckq3hjbpv001jbjrj3df85i8p","category_id":"ckq3hjbq4002bbjrj4kii6hrs","_id":"ckq3hjbq7002objrj5jsihro8"},{"post_id":"ckq3hjbpw001kbjrj31ocent4","category_id":"ckq3hjbq4002bbjrj4kii6hrs","_id":"ckq3hjbq8002sbjrj8mwf67xy"},{"post_id":"ckq3hjbpx001pbjrj4cj346b0","category_id":"ckq3hjbq4002bbjrj4kii6hrs","_id":"ckq3hjbq9002wbjrj5nnu6b32"},{"post_id":"ckq3hjbpy001qbjrj0vf0f2re","category_id":"ckq3hjbq4002bbjrj4kii6hrs","_id":"ckq3hjbqa0030bjrj84jd4vib"},{"post_id":"ckq3hjbq0001vbjrj0cdm53h3","category_id":"ckq3hjbq4002bbjrj4kii6hrs","_id":"ckq3hjbqb0034bjrj7lfk4fdr"},{"post_id":"ckq3hjbq0001wbjrj5vqn0kyl","category_id":"ckq3hjbq4002bbjrj4kii6hrs","_id":"ckq3hjbqc0038bjrjhy1fg0ck"},{"post_id":"ckq3hjbq20020bjrj870mgsby","category_id":"ckq3hjbq4002bbjrj4kii6hrs","_id":"ckq3hjbqc003bbjrjhnlx2ubf"},{"post_id":"ckq3hjbpp0017bjrjei1lbgub","category_id":"ckq3hjbq1001ybjrjejcb2pvs","_id":"ckq3hjbqd003dbjrj987fchvq"},{"post_id":"ckq3hjbpp0017bjrjei1lbgub","category_id":"ckq3hjbqb0037bjrj0t0vdlcs","_id":"ckq3hjbqd003ebjrj39855xe3"},{"post_id":"ckq3hjbqp003fbjrjhlu8ccxq","category_id":"ckq3hjbq4002bbjrj4kii6hrs","_id":"ckq3hjbqq003hbjrjhxfhfiro"},{"post_id":"ckqboczt300002crjes33cjl8","category_id":"ckq3hjbpa0007bjrj4bcobo5x","_id":"ckqboczt900022crjenne75w2"},{"post_id":"ckqtgbka40000f1rj7xhc2khd","category_id":"ckq3hjbpa0007bjrj4bcobo5x","_id":"ckqtgbkad0002f1rj84vzh14n"}],"PostTag":[{"post_id":"ckq3hjboz0000bjrj4zc53a4m","tag_id":"ckq3hjbp70003bjrja5qqhzir","_id":"ckq3hjbpb0009bjrj2me55857"},{"post_id":"ckq3hjbpb000abjrj3t6cahtl","tag_id":"ckq3hjbpa0008bjrj96g0amka","_id":"ckq3hjbpe000fbjrjb26igjxi"},{"post_id":"ckq3hjbp40001bjrjfl1bhipo","tag_id":"ckq3hjbpa0008bjrj96g0amka","_id":"ckq3hjbpf000hbjrjb38n8ae8"},{"post_id":"ckq3hjbpc000bbjrjchna0fo9","tag_id":"ckq3hjbpa0008bjrj96g0amka","_id":"ckq3hjbpg000mbjrj8ir864pp"},{"post_id":"ckq3hjbp70004bjrj2zdr9bi5","tag_id":"ckq3hjbpe000ebjrj24adguuh","_id":"ckq3hjbpi000pbjrjc3t5hl2c"},{"post_id":"ckq3hjbpf000ibjrj2e6g7m7w","tag_id":"ckq3hjbpa0008bjrj96g0amka","_id":"ckq3hjbpj000sbjrjb9n436dp"},{"post_id":"ckq3hjbp90005bjrj3cxz3icx","tag_id":"ckq3hjbpg000lbjrj7jmz7pho","_id":"ckq3hjbpl000xbjrj1kfs1oeq"},{"post_id":"ckq3hjbp90006bjrj8ax394lv","tag_id":"ckq3hjbpk000ubjrjdov88c9i","_id":"ckq3hjbpo0014bjrjdo0v6jr8"},{"post_id":"ckq3hjbpm0010bjrj0s3q9bw9","tag_id":"ckq3hjbpk000ubjrjdov88c9i","_id":"ckq3hjbpp0016bjrjb2skg5xm"},{"post_id":"ckq3hjbpe000gbjrjemz5hd90","tag_id":"ckq3hjbpk000ubjrjdov88c9i","_id":"ckq3hjbpr001bbjrjez13frtu"},{"post_id":"ckq3hjbph000nbjrjh0k310wf","tag_id":"ckq3hjbpk000ubjrjdov88c9i","_id":"ckq3hjbpv001ibjrj2cjbaixm"},{"post_id":"ckq3hjbpi000qbjrj00ove4hs","tag_id":"ckq3hjbpk000ubjrjdov88c9i","_id":"ckq3hjbpx001objrjgwgrbgjh"},{"post_id":"ckq3hjbpk000vbjrjfgy57mmq","tag_id":"ckq3hjbpk000ubjrjdov88c9i","_id":"ckq3hjbpz001ubjrj4v7aet2a"},{"post_id":"ckq3hjbpl000ybjrj1kzq04c2","tag_id":"ckq3hjbpa0008bjrj96g0amka","_id":"ckq3hjbq20021bjrj1sgx9adi"},{"post_id":"ckq3hjbpl000ybjrj1kzq04c2","tag_id":"ckq3hjbpz001tbjrj6v5lekvk","_id":"ckq3hjbq30022bjrj0a7bfpih"},{"post_id":"ckq3hjbpo0015bjrj2rmj3rcz","tag_id":"ckq3hjbq1001zbjrjftw86g0h","_id":"ckq3hjbq30027bjrjfcmp8u1s"},{"post_id":"ckq3hjbpp0017bjrjei1lbgub","tag_id":"ckq3hjbq1001zbjrjftw86g0h","_id":"ckq3hjbq5002dbjrj4pk0bwk8"},{"post_id":"ckq3hjbpp0017bjrjei1lbgub","tag_id":"ckq3hjbq4002abjrj32c74qz3","_id":"ckq3hjbq5002fbjrjcojj6x1o"},{"post_id":"ckq3hjbpr001cbjrjhjy22qbh","tag_id":"ckq3hjbq1001zbjrjftw86g0h","_id":"ckq3hjbq6002ibjrj7eblbka4"},{"post_id":"ckq3hjbpu001ebjrj3hxu9lrt","tag_id":"ckq3hjbq5002hbjrjchtj7823","_id":"ckq3hjbq7002mbjrj23d806yr"},{"post_id":"ckq3hjbpv001jbjrj3df85i8p","tag_id":"ckq3hjbq5002hbjrjchtj7823","_id":"ckq3hjbq8002qbjrjhg7h2290"},{"post_id":"ckq3hjbpw001kbjrj31ocent4","tag_id":"ckq3hjbq5002hbjrjchtj7823","_id":"ckq3hjbq9002ubjrjf0us4yf3"},{"post_id":"ckq3hjbpx001pbjrj4cj346b0","tag_id":"ckq3hjbq5002hbjrjchtj7823","_id":"ckq3hjbqa002ybjrj86423evr"},{"post_id":"ckq3hjbpy001qbjrj0vf0f2re","tag_id":"ckq3hjbq5002hbjrjchtj7823","_id":"ckq3hjbqa0032bjrj6wn17ldl"},{"post_id":"ckq3hjbq0001vbjrj0cdm53h3","tag_id":"ckq3hjbq5002hbjrjchtj7823","_id":"ckq3hjbqb0036bjrj4mbi1acy"},{"post_id":"ckq3hjbq0001wbjrj5vqn0kyl","tag_id":"ckq3hjbq5002hbjrjchtj7823","_id":"ckq3hjbqc003abjrjdgwpfmab"},{"post_id":"ckq3hjbq20020bjrj870mgsby","tag_id":"ckq3hjbq5002hbjrjchtj7823","_id":"ckq3hjbqc003cbjrj3m1h2yl1"},{"post_id":"ckq3hjbqp003fbjrjhlu8ccxq","tag_id":"ckq3hjbq5002hbjrjchtj7823","_id":"ckq3hjbqp003gbjrj64fk6wid"},{"post_id":"ckqboczt300002crjes33cjl8","tag_id":"ckq3hjbpa0008bjrj96g0amka","_id":"ckqboczt900012crj0mx07t0u"},{"post_id":"ckqtgbka40000f1rj7xhc2khd","tag_id":"ckq3hjbpa0008bjrj96g0amka","_id":"ckqtgbkac0001f1rjavml4x87"}],"Tag":[{"name":"生活","_id":"ckq3hjbp70003bjrja5qqhzir"},{"name":"iOS","_id":"ckq3hjbpa0008bjrj96g0amka"},{"name":"WebRTC学习","_id":"ckq3hjbpe000ebjrj24adguuh"},{"name":"React Native","_id":"ckq3hjbpg000lbjrj7jmz7pho"},{"name":"OpenGL","_id":"ckq3hjbpk000ubjrjdov88c9i"},{"name":"Cocoapods","_id":"ckq3hjbpz001tbjrj6v5lekvk"},{"name":"OpenGL ES","_id":"ckq3hjbq1001zbjrjftw86g0h"},{"name":"GLSL","_id":"ckq3hjbq4002abjrj32c74qz3"},{"name":"iOS底层原理","_id":"ckq3hjbq5002hbjrjchtj7823"}]}}